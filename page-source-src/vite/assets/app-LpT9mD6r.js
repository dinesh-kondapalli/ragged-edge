const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["assets/SwiperCarousel-BlR1ZK0H.js", "assets/SwiperCarousel-nJALpa1S.css", "assets/VideoPlayer-CR6nB002.js", "assets/VideoPlayer-D-CmUKS5.css"]))) => i.map(i => d[i]);
var i_ = Object.defineProperty;
var Ah = i => {
    throw TypeError(i)
}
;
var r_ = (i, e, t) => e in i ? i_(i, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : i[e] = t;
var xe = (i, e, t) => r_(i, typeof e != "symbol" ? e + "" : e, t)
  , pc = (i, e, t) => e.has(i) || Ah("Cannot " + t);
var ye = (i, e, t) => (pc(i, e, "read from private field"),
t ? t.call(i) : e.get(i))
  , Fn = (i, e, t) => e.has(i) ? Ah("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t)
  , Bn = (i, e, t, n) => (pc(i, e, "write to private field"),
n ? n.call(i, t) : e.set(i, t),
t)
  , _t = (i, e, t) => (pc(i, e, "access private method"),
t);
function Zw() {
    import.meta.url,
    import("_").catch( () => 1),
    (async function*() {}
    )().next()
}
const s_ = "modulepreload"
  , o_ = function(i) {
    return "/vite/" + i
}
  , Rh = {}
  , An = function(e, t, n) {
    let r = Promise.resolve();
    if (t && t.length > 0) {
        let o = function(c) {
            return Promise.all(c.map(u => Promise.resolve(u).then(f => ({
                status: "fulfilled",
                value: f
            }), f => ({
                status: "rejected",
                reason: f
            }))))
        };
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , l = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
        r = o(t.map(c => {
            if (c = o_(c),
            c in Rh)
                return;
            Rh[c] = !0;
            const u = c.endsWith(".css")
              , f = u ? '[rel="stylesheet"]' : "";
            if (document.querySelector('link[href="'.concat(c, '"]').concat(f)))
                return;
            const h = document.createElement("link");
            if (h.rel = u ? "stylesheet" : s_,
            u || (h.as = "script"),
            h.crossOrigin = "",
            h.href = c,
            l && h.setAttribute("nonce", l),
            document.head.appendChild(h),
            u)
                return new Promise( (d, _) => {
                    h.addEventListener("load", d),
                    h.addEventListener("error", () => _(new Error("Unable to preload CSS for ".concat(c))))
                }
                )
        }
        ))
    }
    function s(o) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = o,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw o
    }
    return r.then(o => {
        for (const a of o || [])
            a.status === "rejected" && s(a.reason);
        return e().catch(s)
    }
    )
}
  , a_ = (i, e, t) => {
    const n = i[e];
    return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise( (r, s) => {
        (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(s.bind(null, new Error("Unknown variable dynamic import: " + e + (e.split("/").length !== t ? ". Note that variables only represent file names one level deep." : ""))))
    }
    )
}
  , hn = new Map;
function l_(i) {
    requestAnimationFrame(i)
}
function Gn({module: i, id: e, keepAlive: t, node: n, ...r}) {
    const s = hn.get(e);
    if (s) {
        const {destroy: a, plugins: l=[]} = s;
        [a, ...l].forEach(c => {
            typeof c == "function" && c()
        }
        )
    }
    const o = i({
        node: n,
        name: e,
        ...r
    });
    hn.set(e, {
        ...hn.get(e) || {
            name: e
        },
        keepAlive: t,
        destroy: o,
        hasLoaded: !0
    })
}
function vu(i) {
    const e = hn.get(i);
    if (!e)
        return;
    const {destroy: t, plugins: n=[], query: r} = e;
    r && r.mql && r.handle && r.mql.removeEventListener("change", r.handle),
    [t, ...n].forEach(s => {
        typeof s == "function" && s()
    }
    ),
    hn.delete(i)
}
function c_(i, e) {
    function t({behaviour: s, id: o, keepAlive: a, node: l}) {
        i(s).then(c => {
            const {default: u} = c;
            Gn({
                module: u,
                id: o,
                keepAlive: a,
                node: l
            })
        }
        )
    }
    function n(s=document.body) {
        l_( () => {
            Array.from(s.querySelectorAll("[data-behaviour]")).forEach(a => {
                const {behaviour: l, query: c, keepAlive: u} = a.dataset
                  , f = a.id;
                if (!f || !l || l.split(" ").length > 1) {
                    console.warn("Skipping node. Each [data-behaviour] node must have a unique id and exactly one behaviour. Node:", a);
                    return
                }
                if (hn.has(f))
                    return;
                const d = {
                    behaviour: l.trim(),
                    id: f,
                    keepAlive: u,
                    node: a
                };
                if (hn.set(f, {
                    name: f,
                    hasLoaded: !1
                }),
                c) {
                    const _ = window.matchMedia(c)
                      , g = ({matches: m}) => {
                        const p = hn.get(f);
                        if (p)
                            if (!m && p.hasLoaded) {
                                const {destroy: E, plugins: S=[], ...v} = p;
                                [E, ...S].forEach(b => {
                                    typeof b == "function" && b()
                                }
                                ),
                                hn.set(f, {
                                    ...v,
                                    hasLoaded: !1
                                })
                            } else
                                m && !p.hasLoaded && t(d)
                    }
                    ;
                    _.addEventListener("change", g),
                    _.matches && t(d),
                    hn.set(f, {
                        ...hn.get(f),
                        query: {
                            mql: _,
                            handle: g
                        }
                    })
                } else
                    t(d)
            }
            )
        }
        )
    }
    function r() {
        const s = [];
        hn.forEach( (o, a) => {
            const {keepAlive: l} = o;
            l || s.push(a)
        }
        ),
        s.forEach(o => {
            const a = hn.get(o);
            if (!a)
                return;
            const {query: l, destroy: c, plugins: u=[]} = a;
            if (l && l.mql && l.handle)
                try {
                    l.mql.removeEventListener("change", l.handle)
                } catch (f) {
                    console.error('Error removing matchMedia listener for module "'.concat(o, '":'), f)
                }
            if (typeof c == "function")
                try {
                    c()
                } catch (f) {
                    console.error('Error destroying module "'.concat(o, '":'), f)
                }
            u.forEach( (f, h) => {
                if (typeof f == "function")
                    try {
                        f()
                    } catch (d) {
                        console.error("Error destroying plugin #".concat(h, ' for module "').concat(o, '":'), d)
                    }
            }
            ),
            hn.delete(o)
        }
        ),
        hn.size > 0 && console.warn("Some modules remain in cache after destroy:", Array.from(hn.keys()))
    }
    return {
        hydrate: n,
        destroy: r,
        get cache() {
            return hn
        }
    }
}
function u_(i) {
    if (Array.isArray(i))
        return i
}
var Ap = u_;
function f_(i) {
    if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]")
        return Array.from(i)
}
var h_ = f_;
function d_() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance")
}
var Rp = d_;
function p_(i) {
    return Ap(i) || h_(i) || Rp()
}
var m_ = p_;
function g_(i, e) {
    var t = []
      , n = !0
      , r = !1
      , s = void 0;
    try {
        for (var o, a = i[Symbol.iterator](); !(n = (o = a.next()).done) && (t.push(o.value),
        !e || t.length !== e); n = !0)
            ;
    } catch (l) {
        r = !0,
        s = l
    } finally {
        try {
            n || a.return == null || a.return()
        } finally {
            if (r)
                throw s
        }
    }
    return t
}
var __ = g_;
function v_(i, e) {
    return Ap(i) || __(i, e) || Rp()
}
var Ch = v_
  , Cp = or;
function or(i) {
    this.listenerMap = [{}, {}],
    i && this.root(i),
    this.handle = or.prototype.handle.bind(this),
    this._removedListeners = []
}
or.prototype.root = function(i) {
    var e, t = this.listenerMap;
    if (this.rootElement) {
        for (e in t[1])
            t[1].hasOwnProperty(e) && this.rootElement.removeEventListener(e, this.handle, !0);
        for (e in t[0])
            t[0].hasOwnProperty(e) && this.rootElement.removeEventListener(e, this.handle, !1)
    }
    if (!i || !i.addEventListener)
        return this.rootElement && delete this.rootElement,
        this;
    for (e in this.rootElement = i,
    t[1])
        t[1].hasOwnProperty(e) && this.rootElement.addEventListener(e, this.handle, !0);
    for (e in t[0])
        t[0].hasOwnProperty(e) && this.rootElement.addEventListener(e, this.handle, !1);
    return this
}
,
or.prototype.captureForType = function(i) {
    return ["blur", "error", "focus", "load", "resize", "scroll"].indexOf(i) !== -1
}
,
or.prototype.on = function(i, e, t, n) {
    var r, s, o, a;
    if (!i)
        throw new TypeError("Invalid event type: " + i);
    if (typeof e == "function" && (n = t,
    t = e,
    e = null),
    n === void 0 && (n = this.captureForType(i)),
    typeof t != "function")
        throw new TypeError("Handler must be a type of Function");
    return r = this.rootElement,
    (s = this.listenerMap[n ? 1 : 0])[i] || (r && r.addEventListener(i, this.handle, n),
    s[i] = []),
    e ? /^[a-z]+$/i.test(e) ? (a = e,
    o = y_) : /^#[a-z0-9\-_]+$/i.test(e) ? (a = e.slice(1),
    o = E_) : (a = e,
    o = x_) : (a = null,
    o = S_.bind(this)),
    s[i].push({
        selector: e,
        handler: t,
        matcher: o,
        matcherParam: a
    }),
    this
}
,
or.prototype.off = function(i, e, t, n) {
    var r, s, o, a, l;
    if (typeof e == "function" && (n = t,
    t = e,
    e = null),
    n === void 0)
        return this.off(i, e, t, !0),
        this.off(i, e, t, !1),
        this;
    if (o = this.listenerMap[n ? 1 : 0],
    !i) {
        for (l in o)
            o.hasOwnProperty(l) && this.off(l, e, t);
        return this
    }
    if (!(a = o[i]) || !a.length)
        return this;
    for (r = a.length - 1; 0 <= r; r--)
        s = a[r],
        e && e !== s.selector || t && t !== s.handler || (this._removedListeners.push(s),
        a.splice(r, 1));
    return a.length || (delete o[i],
    this.rootElement && this.rootElement.removeEventListener(i, this.handle, n)),
    this
}
,
or.prototype.handle = function(i) {
    var e, t, n, r, s, o, a = i.type, l = [], c = "ftLabsDelegateIgnore";
    if (i[c] !== !0) {
        (o = i.target).nodeType === 3 && (o = o.parentNode),
        o.correspondingUseElement && (o = o.correspondingUseElement),
        n = this.rootElement,
        (r = i.eventPhase || (i.target === i.currentTarget ? 2 : 3)) === 1 ? l = this.listenerMap[1][a] : r === 2 ? (this.listenerMap[0] && this.listenerMap[0][a] && (l = l.concat(this.listenerMap[0][a])),
        this.listenerMap[1] && this.listenerMap[1][a] && (l = l.concat(this.listenerMap[1][a]))) : r === 3 && (l = this.listenerMap[0][a]);
        var u, f = [];
        for (t = l.length; o && t; ) {
            for (e = 0; e < t && (s = l[e]); e++)
                o.tagName && -1 < ["button", "input", "select", "textarea"].indexOf(o.tagName.toLowerCase()) && o.hasAttribute("disabled") ? f = [] : s.matcher.call(o, s.matcherParam, o) && f.push([i, o, s]);
            if (o === n || (t = l.length,
            (o = o.parentElement || o.parentNode)instanceof HTMLDocument))
                break
        }
        for (e = 0; e < f.length; e++)
            if (!(-1 < this._removedListeners.indexOf(f[e][2])) && this.fire.apply(this, f[e]) === !1) {
                f[e][0][c] = !0,
                f[e][0].preventDefault(),
                u = !1;
                break
            }
        return u
    }
}
,
or.prototype.fire = function(i, e, t) {
    return t.handler.call(e, i, e)
}
;
var x_ = (function(i) {
    if (i) {
        var e = i.prototype;
        return e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector
    }
}
)(Element);
function y_(i, e) {
    return i.toLowerCase() === e.tagName.toLowerCase()
}
function S_(i, e) {
    return this.rootElement === window ? e === document || e === document.documentElement || e === window : this.rootElement === e
}
function E_(i, e) {
    return i === e.id
}
or.prototype.destroy = function() {
    this.off(),
    this.root()
}
;
var xu = function(i) {
    return new Cp(i)
}
  , M_ = Cp;
xu.Delegate = M_;
var T_ = function() {
    var i = {};
    return {
        add: function(e, t) {
            i[e] = t
        },
        delete: function(e) {
            delete i[e]
        },
        get store() {
            return i
        }
    }
};
function b_() {
    var i = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : document.body
      , e = xu(i)
      , t = T_();
    return {
        addEvents: function() {
            var n = 1 < arguments.length
              , r = n ? 1 >= arguments.length ? void 0 : arguments[1] : 0 >= arguments.length ? void 0 : arguments[0]
              , s = n ? xu(0 >= arguments.length ? void 0 : arguments[0]) : e;
            Object.entries(r).forEach(function(o) {
                var a = Ch(o, 2)
                  , l = a[0]
                  , c = a[1]
                  , u = l.split(" ")
                  , f = m_(u)
                  , h = f[0]
                  , d = f.slice(1).join(" ")
                  , _ = typeof c == "function" ? c : c[0]
                  , g = typeof c != "function" && c[1];
                t.add("".concat(h, " ").concat(d), {
                    func: _,
                    rootNode: s,
                    capture: g
                }),
                s.on(h, d, _, g)
            })
        },
        removeEvents: function() {
            e.destroy()
        },
        removeEvent: function(n) {
            var r = n.split(" ")
              , s = Ch(r, 2)
              , o = s[0]
              , a = s[1]
              , l = t.store[n]
              , c = l.func
              , u = l.rootNode
              , f = l.capture;
            t.delete(n),
            u.off(o, a, c, f)
        }
    }
}
function w_(i, e, t) {
    return e in i ? Object.defineProperty(i, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : i[e] = t,
    i
}
function Ph(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e && (n = n.filter((function(r) {
            return Object.getOwnPropertyDescriptor(i, r).enumerable
        }
        ))),
        t.push.apply(t, n)
    }
    return t
}
function A_(i) {
    for (var e, t = 1; t < arguments.length; t++)
        e = arguments[t] == null ? {} : arguments[t],
        t % 2 ? Ph(e, !0).forEach((function(n) {
            w_(i, n, e[n])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : Ph(e).forEach((function(n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        }
        ));
    return i
}
function R_(i) {
    return (function(e) {
        if (Array.isArray(e)) {
            for (var t = 0, n = Array(e.length); t < e.length; t++)
                n[t] = e[t];
            return n
        }
    }
    )(i) || (function(e) {
        if (Symbol.iterator in Object(e) || Object.prototype.toString.call(e) === "[object Arguments]")
            return Array.from(e)
    }
    )(i) || (function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance")
    }
    )()
}
var No, C_ = new Map, P_ = (No = C_,
function(i) {
    return function(e) {
        if (No.has(i)) {
            var t = No.get(i)
              , n = t.plugins
              , r = n === void 0 ? [] : n;
            No.set(i, A_({}, t, {
                plugins: [].concat(R_(r), [e])
            }))
        } else
            No.set(i, {
                name: i,
                plugins: [e]
            })
    }
}
), Pp = function(i, e, t) {
    return e in i ? Object.defineProperty(i, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : i[e] = t,
    i
}, D_ = function(i, e) {
    if (i == null)
        return {};
    var t, n, r = {}, s = Object.keys(i);
    for (n = 0; n < s.length; n++)
        t = s[n],
        0 <= e.indexOf(t) || (r[t] = i[t]);
    return r
}, L_ = function(i, e) {
    if (i == null)
        return {};
    var t, n, r = D_(i, e);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(i);
        for (n = 0; n < s.length; n++)
            t = s[n],
            !(0 <= e.indexOf(t)) && Object.prototype.propertyIsEnumerable.call(i, t) && (r[t] = i[t])
    }
    return r
}, I_ = function(i) {
    if (Array.isArray(i))
        return i
}, U_ = function(i, e) {
    if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]") {
        var t = []
          , n = !0
          , r = !1
          , s = void 0;
        try {
            for (var o, a = i[Symbol.iterator](); !(n = (o = a.next()).done) && (t.push(o.value),
            !e || t.length !== e); n = !0)
                ;
        } catch (l) {
            r = !0,
            s = l
        } finally {
            try {
                n || a.return == null || a.return()
            } finally {
                if (r)
                    throw s
            }
        }
        return t
    }
}, N_ = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance")
}, O_ = function(i, e) {
    return I_(i) || U_(i, e) || N_()
}, Oo, F_ = (function(i, e) {
    return i(e = {
        exports: {}
    }, e.exports),
    e.exports
}
)((function(i, e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.default = function(t) {
        var n = void 0
          , r = function(o, a) {
            return function() {
                n = null,
                t.apply(o, a)
            }
        }
          , s = function() {
            if (n == null) {
                for (var o = arguments.length, a = Array(o), l = 0; l < o; l++)
                    a[l] = arguments[l];
                n = requestAnimationFrame(r(this, a))
            }
        };
        return s.cancel = function() {
            return cancelAnimationFrame(n)
        }
        ,
        s
    }
}
)), B_ = (Oo = F_) && Oo.__esModule && Object.prototype.hasOwnProperty.call(Oo, "default") ? Oo.default : Oo, to = {};
function ia(i, e) {
    if (to[e] || (to[e] = i),
    !ia.isRunning) {
        var t = B_((function() {
            var n = Object.entries(to);
            n.forEach((function(r) {
                var s = O_(r, 2)[1];
                typeof s == "function" && s()
            }
            )),
            n.length === 0 && (window.removeEventListener("resize", t),
            ia.isRunning = !1)
        }
        ));
        Object.entries(to).length && (window.addEventListener("resize", t),
        ia.isRunning = !0)
    }
}
function z_(i) {
    var e, t, n = i.register, r = i.name, s = [];
    return n((function() {
        (function(o) {
            o.forEach((function(a) {
                delete to[a]
            }
            ))
        }
        )(s),
        e && e.removeListener(t)
    }
    )),
    {
        device: {
            resize: function(o) {
                var a = "".concat(r, "-r");
                return s.push(a),
                ia(o, a),
                this
            },
            cancel: function() {
                var o = "".concat(r, "-r");
                return s = s.filter((function(a) {
                    return a !== o
                }
                )),
                delete to[o],
                this
            },
            at: function(o, a) {
                var l = this
                  , c = a.on
                  , u = a.off
                  , f = "".concat(r, "-").concat(o);
                s.includes(f) || s.push(f),
                e = window.matchMedia(o);
                var h = function(d) {
                    d ? c({
                        width: l.width,
                        height: l.height
                    }) : u({
                        width: l.width,
                        height: l.height
                    })
                };
                return t = function(d) {
                    return h(d.matches)
                }
                ,
                h(e.matches),
                e.addListener(t),
                this
            },
            get width() {
                return window.innerWidth
            },
            get height() {
                return window.innerHeight
            }
        }
    }
}
function Dp(i) {
    var e = i.node
      , t = i.register
      , n = b_(e);
    return t(n.removeEvents),
    n
}
ia.isRunning = !1;
var k_ = function(i) {
    if (Array.isArray(i)) {
        for (var e = 0, t = Array(i.length); e < i.length; e++)
            t[e] = i[e];
        return t
    }
}
  , H_ = function(i) {
    if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]")
        return Array.from(i)
}
  , V_ = function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance")
}
  , G_ = function(i) {
    return k_(i) || H_(i) || V_()
};
function Dh(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e && (n = n.filter((function(r) {
            return Object.getOwnPropertyDescriptor(i, r).enumerable
        }
        ))),
        t.push.apply(t, n)
    }
    return t
}
function W_(i) {
    for (var e, t = 1; t < arguments.length; t++)
        e = arguments[t] == null ? {} : arguments[t],
        t % 2 ? Dh(e, !0).forEach((function(n) {
            Pp(i, n, e[n])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : Dh(e).forEach((function(n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        }
        ));
    return i
}
function Lp(i) {
    var e, t = i.register, n = i.node, r = {
        rootMargin: "0px",
        threshold: 0
    };
    return t((function() {
        e && e.disconnect()
    }
    )),
    {
        inview: {
            settings: {},
            observe: function() {
                var s = 1 < arguments.length ? 0 >= arguments.length ? void 0 : arguments[0] : n
                  , o = 1 < arguments.length ? 1 >= arguments.length ? void 0 : arguments[1] : 0 >= arguments.length ? void 0 : arguments[0]
                  , a = o.enter
                  , l = o.exit;
                e = new IntersectionObserver((function(c, u) {
                    c.forEach((function(f) {
                        f.isIntersecting ? typeof a == "function" && a(f, u) : typeof l == "function" && l(f, u)
                    }
                    ))
                }
                ),W_({}, r, {}, this.settings)),
                typeof s.length == "number" ? G_(s).forEach((function(c) {
                    e.observe(c)
                }
                )) : e.observe(s)
            },
            disconnect: function() {
                e.disconnect()
            }
        }
    }
}
var It = (function(i) {
    return i = i || Object.create(null),
    {
        on: function(e, t) {
            (i[e] || (i[e] = [])).push(t)
        },
        off: function(e, t) {
            i[e] && i[e].splice(i[e].indexOf(t) >>> 0, 1)
        },
        emit: function(e, t) {
            (i[e] || []).slice().map((function(n) {
                n(t)
            }
            )),
            (i["*"] || []).slice().map((function(n) {
                n(e, t)
            }
            ))
        }
    }
}
)();
function Lh(i, e) {
    var t = Object.keys(i);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        e && (n = n.filter((function(r) {
            return Object.getOwnPropertyDescriptor(i, r).enumerable
        }
        ))),
        t.push.apply(t, n)
    }
    return t
}
function ka(i) {
    for (var e, t = 1; t < arguments.length; t++)
        e = arguments[t] == null ? {} : arguments[t],
        t % 2 ? Lh(e, !0).forEach((function(n) {
            Pp(i, n, e[n])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : Lh(e).forEach((function(n) {
            Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(e, n))
        }
        ));
    return i
}
function Da() {
    for (var i = arguments.length, e = Array(i), t = 0; t < i; t++)
        e[t] = arguments[t];
    return function(n) {
        return function(r) {
            var s = r.name
              , o = L_(r, ["name"]);
            return n(ka({}, o, {
                name: s,
                plugins: ka({}, e.reduce((function(a, l) {
                    return ka({}, a, {}, l(ka({
                        register: P_(s),
                        name: s
                    }, o)))
                }
                ), {}))
            }))
        }
    }
}
function rc(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
}
var mc = {
    exports: {}
}, Ih;
function Ip() {
    return Ih || (Ih = 1,
    (function(i) {
        (function(e, t) {
            var n = t(e, e.document, Date);
            e.lazySizes = n,
            i.exports && (i.exports = n)
        }
        )(typeof window < "u" ? window : {}, function(t, n, r) {
            var s, o;
            if ((function() {
                var N, k = {
                    lazyClass: "lazyload",
                    loadedClass: "lazyloaded",
                    loadingClass: "lazyloading",
                    preloadClass: "lazypreload",
                    errorClass: "lazyerror",
                    autosizesClass: "lazyautosizes",
                    fastLoadedClass: "ls-is-cached",
                    iframeLoadMode: 0,
                    srcAttr: "data-src",
                    srcsetAttr: "data-srcset",
                    sizesAttr: "data-sizes",
                    minSize: 40,
                    customMedia: {},
                    init: !0,
                    expFactor: 1.5,
                    hFac: .8,
                    loadMode: 2,
                    loadHidden: !0,
                    ricTimeout: 0,
                    throttleDelay: 125
                };
                o = t.lazySizesConfig || t.lazysizesConfig || {};
                for (N in k)
                    N in o || (o[N] = k[N])
            }
            )(),
            !n || !n.getElementsByClassName)
                return {
                    init: function() {},
                    cfg: o,
                    noSupport: !0
                };
            var a = n.documentElement
              , l = t.HTMLPictureElement
              , c = "addEventListener"
              , u = "getAttribute"
              , f = t[c].bind(t)
              , h = t.setTimeout
              , d = t.requestAnimationFrame || h
              , _ = t.requestIdleCallback
              , g = /^picture$/i
              , m = ["load", "error", "lazyincluded", "_lazyloaded"]
              , p = {}
              , E = Array.prototype.forEach
              , S = function(N, k) {
                return p[k] || (p[k] = new RegExp("(\\s|^)" + k + "(\\s|$)")),
                p[k].test(N[u]("class") || "") && p[k]
            }
              , v = function(N, k) {
                S(N, k) || N.setAttribute("class", (N[u]("class") || "").trim() + " " + k)
            }
              , b = function(N, k) {
                var C;
                (C = S(N, k)) && N.setAttribute("class", (N[u]("class") || "").replace(C, " "))
            }
              , A = function(N, k, C) {
                var re = C ? c : "removeEventListener";
                C && A(N, k),
                m.forEach(function(ue) {
                    N[re](ue, k)
                })
            }
              , T = function(N, k, C, re, ue) {
                var we = n.createEvent("Event");
                return C || (C = {}),
                C.instance = s,
                we.initEvent(k, !re, !ue),
                we.detail = C,
                N.dispatchEvent(we),
                we
            }
              , R = function(N, k) {
                var C;
                !l && (C = t.picturefill || o.pf) ? (k && k.src && !N[u]("srcset") && N.setAttribute("srcset", k.src),
                C({
                    reevaluate: !0,
                    elements: [N]
                })) : k && k.src && (N.src = k.src)
            }
              , y = function(N, k) {
                return (getComputedStyle(N, null) || {})[k]
            }
              , x = function(N, k, C) {
                for (C = C || N.offsetWidth; C < o.minSize && k && !N._lazysizesWidth; )
                    C = k.offsetWidth,
                    k = k.parentNode;
                return C
            }
              , P = (function() {
                var N, k, C = [], re = [], ue = C, we = function() {
                    var te = ue;
                    for (ue = C.length ? re : C,
                    N = !0,
                    k = !1; te.length; )
                        te.shift()();
                    N = !1
                }, q = function(te, fe) {
                    N && !fe ? te.apply(this, arguments) : (ue.push(te),
                    k || (k = !0,
                    (n.hidden ? h : d)(we)))
                };
                return q._lsFlush = we,
                q
            }
            )()
              , U = function(N, k) {
                return k ? function() {
                    P(N)
                }
                : function() {
                    var C = this
                      , re = arguments;
                    P(function() {
                        N.apply(C, re)
                    })
                }
            }
              , O = function(N) {
                var k, C = 0, re = o.throttleDelay, ue = o.ricTimeout, we = function() {
                    k = !1,
                    C = r.now(),
                    N()
                }, q = _ && ue > 49 ? function() {
                    _(we, {
                        timeout: ue
                    }),
                    ue !== o.ricTimeout && (ue = o.ricTimeout)
                }
                : U(function() {
                    h(we)
                }, !0);
                return function(te) {
                    var fe;
                    (te = te === !0) && (ue = 33),
                    !k && (k = !0,
                    fe = re - (r.now() - C),
                    fe < 0 && (fe = 0),
                    te || fe < 9 ? q() : h(q, fe))
                }
            }
              , B = function(N) {
                var k, C, re = 99, ue = function() {
                    k = null,
                    N()
                }, we = function() {
                    var q = r.now() - C;
                    q < re ? h(we, re - q) : (_ || ue)(ue)
                };
                return function() {
                    C = r.now(),
                    k || (k = h(we, re))
                }
            }
              , X = (function() {
                var N, k, C, re, ue, we, q, te, fe, oe, me, He, ze = /^img$/i, Qe = /^iframe$/i, et = "onscroll"in t && !/(gle|ing)bot/.test(navigator.userAgent), De = 0, I = 0, Je = 0, Ge = -1, G = function($) {
                    Je--,
                    (!$ || Je < 0 || !$.target) && (Je = 0)
                }, Ee = function($) {
                    return He == null && (He = y(n.body, "visibility") == "hidden"),
                    He || !(y($.parentNode, "visibility") == "hidden" && y($, "visibility") == "hidden")
                }, Ke = function($, K) {
                    var ae, Me = $, Te = Ee($);
                    for (te -= K,
                    me += K,
                    fe -= K,
                    oe += K; Te && (Me = Me.offsetParent) && Me != n.body && Me != a; )
                        Te = (y(Me, "opacity") || 1) > 0,
                        Te && y(Me, "overflow") != "visible" && (ae = Me.getBoundingClientRect(),
                        Te = oe > ae.left && fe < ae.right && me > ae.top - 1 && te < ae.bottom + 1);
                    return Te
                }, Ue = function() {
                    var $, K, ae, Me, Te, ce, Ne, L, he, ie, pe, se, Q = s.elements;
                    if ((re = o.loadMode) && Je < 8 && ($ = Q.length)) {
                        for (K = 0,
                        Ge++; K < $; K++)
                            if (!(!Q[K] || Q[K]._lazyRace)) {
                                if (!et || s.prematureUnveil && s.prematureUnveil(Q[K])) {
                                    J(Q[K]);
                                    continue
                                }
                                if ((!(L = Q[K][u]("data-expand")) || !(ce = L * 1)) && (ce = I),
                                ie || (ie = !o.expand || o.expand < 1 ? a.clientHeight > 500 && a.clientWidth > 500 ? 500 : 370 : o.expand,
                                s._defEx = ie,
                                pe = ie * o.expFactor,
                                se = o.hFac,
                                He = null,
                                I < pe && Je < 1 && Ge > 2 && re > 2 && !n.hidden ? (I = pe,
                                Ge = 0) : re > 1 && Ge > 1 && Je < 6 ? I = ie : I = De),
                                he !== ce && (we = innerWidth + ce * se,
                                q = innerHeight + ce,
                                Ne = ce * -1,
                                he = ce),
                                ae = Q[K].getBoundingClientRect(),
                                (me = ae.bottom) >= Ne && (te = ae.top) <= q && (oe = ae.right) >= Ne * se && (fe = ae.left) <= we && (me || oe || fe || te) && (o.loadHidden || Ee(Q[K])) && (k && Je < 3 && !L && (re < 3 || Ge < 4) || Ke(Q[K], ce))) {
                                    if (J(Q[K]),
                                    Te = !0,
                                    Je > 9)
                                        break
                                } else
                                    !Te && k && !Me && Je < 4 && Ge < 4 && re > 2 && (N[0] || o.preloadAfterLoad) && (N[0] || !L && (me || oe || fe || te || Q[K][u](o.sizesAttr) != "auto")) && (Me = N[0] || Q[K])
                            }
                        Me && !Te && J(Me)
                    }
                }, ge = O(Ue), ht = function($) {
                    var K = $.target;
                    if (K._lazyCache) {
                        delete K._lazyCache;
                        return
                    }
                    G($),
                    v(K, o.loadedClass),
                    b(K, o.loadingClass),
                    A(K, M),
                    T(K, "lazyloaded")
                }, D = U(ht), M = function($) {
                    D({
                        target: $.target
                    })
                }, V = function($, K) {
                    var ae = $.getAttribute("data-load-mode") || o.iframeLoadMode;
                    ae == 0 ? $.contentWindow.location.replace(K) : ae == 1 && ($.src = K)
                }, ne = function($) {
                    var K, ae = $[u](o.srcsetAttr);
                    (K = o.customMedia[$[u]("data-media") || $[u]("media")]) && $.setAttribute("media", K),
                    ae && $.setAttribute("srcset", ae)
                }, ee = U(function($, K, ae, Me, Te) {
                    var ce, Ne, L, he, ie, pe;
                    (ie = T($, "lazybeforeunveil", K)).defaultPrevented || (Me && (ae ? v($, o.autosizesClass) : $.setAttribute("sizes", Me)),
                    Ne = $[u](o.srcsetAttr),
                    ce = $[u](o.srcAttr),
                    Te && (L = $.parentNode,
                    he = L && g.test(L.nodeName || "")),
                    pe = K.firesLoad || "src"in $ && (Ne || ce || he),
                    ie = {
                        target: $
                    },
                    v($, o.loadingClass),
                    pe && (clearTimeout(C),
                    C = h(G, 2500),
                    A($, M, !0)),
                    he && E.call(L.getElementsByTagName("source"), ne),
                    Ne ? $.setAttribute("srcset", Ne) : ce && !he && (Qe.test($.nodeName) ? V($, ce) : $.src = ce),
                    Te && (Ne || he) && R($, {
                        src: ce
                    })),
                    $._lazyRace && delete $._lazyRace,
                    b($, o.lazyClass),
                    P(function() {
                        var se = $.complete && $.naturalWidth > 1;
                        (!pe || se) && (se && v($, o.fastLoadedClass),
                        ht(ie),
                        $._lazyCache = !0,
                        h(function() {
                            "_lazyCache"in $ && delete $._lazyCache
                        }, 9)),
                        $.loading == "lazy" && Je--
                    }, !0)
                }), J = function($) {
                    if (!$._lazyRace) {
                        var K, ae = ze.test($.nodeName), Me = ae && ($[u](o.sizesAttr) || $[u]("sizes")), Te = Me == "auto";
                        (Te || !k) && ae && ($[u]("src") || $.srcset) && !$.complete && !S($, o.errorClass) && S($, o.lazyClass) || (K = T($, "lazyunveilread").detail,
                        Te && H.updateElem($, !0, $.offsetWidth),
                        $._lazyRace = !0,
                        Je++,
                        ee($, K, Te, Me, ae))
                    }
                }, Ae = B(function() {
                    o.loadMode = 3,
                    ge()
                }), de = function() {
                    o.loadMode == 3 && (o.loadMode = 2),
                    Ae()
                }, Ce = function() {
                    if (!k) {
                        if (r.now() - ue < 999) {
                            h(Ce, 999);
                            return
                        }
                        k = !0,
                        o.loadMode = 3,
                        ge(),
                        f("scroll", de, !0)
                    }
                };
                return {
                    _: function() {
                        ue = r.now(),
                        s.elements = n.getElementsByClassName(o.lazyClass),
                        N = n.getElementsByClassName(o.lazyClass + " " + o.preloadClass),
                        f("scroll", ge, !0),
                        f("resize", ge, !0),
                        f("pageshow", function($) {
                            if ($.persisted) {
                                var K = n.querySelectorAll("." + o.loadingClass);
                                K.length && K.forEach && d(function() {
                                    K.forEach(function(ae) {
                                        ae.complete && J(ae)
                                    })
                                })
                            }
                        }),
                        t.MutationObserver ? new MutationObserver(ge).observe(a, {
                            childList: !0,
                            subtree: !0,
                            attributes: !0
                        }) : (a[c]("DOMNodeInserted", ge, !0),
                        a[c]("DOMAttrModified", ge, !0),
                        setInterval(ge, 999)),
                        f("hashchange", ge, !0),
                        ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach(function($) {
                            n[c]($, ge, !0)
                        }),
                        /d$|^c/.test(n.readyState) ? Ce() : (f("load", Ce),
                        n[c]("DOMContentLoaded", ge),
                        h(Ce, 2e4)),
                        s.elements.length ? (Ue(),
                        P._lsFlush()) : ge()
                    },
                    checkElems: ge,
                    unveil: J,
                    _aLSL: de
                }
            }
            )()
              , H = (function() {
                var N, k = U(function(we, q, te, fe) {
                    var oe, me, He;
                    if (we._lazysizesWidth = fe,
                    fe += "px",
                    we.setAttribute("sizes", fe),
                    g.test(q.nodeName || ""))
                        for (oe = q.getElementsByTagName("source"),
                        me = 0,
                        He = oe.length; me < He; me++)
                            oe[me].setAttribute("sizes", fe);
                    te.detail.dataAttr || R(we, te.detail)
                }), C = function(we, q, te) {
                    var fe, oe = we.parentNode;
                    oe && (te = x(we, oe, te),
                    fe = T(we, "lazybeforesizes", {
                        width: te,
                        dataAttr: !!q
                    }),
                    fe.defaultPrevented || (te = fe.detail.width,
                    te && te !== we._lazysizesWidth && k(we, oe, fe, te)))
                }, re = function() {
                    var we, q = N.length;
                    if (q)
                        for (we = 0; we < q; we++)
                            C(N[we])
                }, ue = B(re);
                return {
                    _: function() {
                        N = n.getElementsByClassName(o.autosizesClass),
                        f("resize", ue)
                    },
                    checkElems: ue,
                    updateElem: C
                }
            }
            )()
              , Y = function() {
                !Y.i && n.getElementsByClassName && (Y.i = !0,
                H._(),
                X._())
            };
            return h(function() {
                o.init && Y()
            }),
            s = {
                cfg: o,
                autoSizer: H,
                loader: X,
                init: Y,
                uP: R,
                aC: v,
                rC: b,
                hC: S,
                fire: T,
                gW: x,
                rAF: P
            },
            s
        })
    }
    )(mc)),
    mc.exports
}
Ip();
var gc = {
    exports: {}
}, Uh;
function X_() {
    return Uh || (Uh = 1,
    (function(i) {
        (function(e, t) {
            if (e) {
                var n = function() {
                    t(e.lazySizes),
                    e.removeEventListener("lazyunveilread", n, !0)
                };
                t = t.bind(null, e, e.document),
                i.exports ? t(Ip()) : e.lazySizes ? n() : e.addEventListener("lazyunveilread", n, !0)
            }
        }
        )(typeof window < "u" ? window : 0, function(e, t, n) {
            var r, s = n.cfg, o = t.createElement("img"), a = "sizes"in o && "srcset"in o, l = /\s+\d+h/g, c = (function() {
                var u = /\s+(\d+)(w|h)\s+(\d+)(w|h)/
                  , f = Array.prototype.forEach;
                return function() {
                    var h = t.createElement("img")
                      , d = function(m) {
                        var p, E, S = m.getAttribute(s.srcsetAttr);
                        S && (E = S.match(u)) && (E[2] == "w" ? p = E[1] / E[3] : p = E[3] / E[1],
                        p && m.setAttribute("data-aspectratio", p),
                        m.setAttribute(s.srcsetAttr, S.replace(l, "")))
                    }
                      , _ = function(m) {
                        if (m.detail.instance == n) {
                            var p = m.target.parentNode;
                            p && p.nodeName == "PICTURE" && f.call(p.getElementsByTagName("source"), d),
                            d(m.target)
                        }
                    }
                      , g = function() {
                        h.currentSrc && t.removeEventListener("lazybeforeunveil", _)
                    };
                    t.addEventListener("lazybeforeunveil", _),
                    h.onload = g,
                    h.onerror = g,
                    h.srcset = "data:,a 1w 1h",
                    h.complete && g()
                }
            }
            )();
            if (s.supportsType || (s.supportsType = function(u) {
                return !u
            }
            ),
            e.HTMLPictureElement && a) {
                !n.hasHDescriptorFix && t.msElementsFromPoint && (n.hasHDescriptorFix = !0,
                c());
                return
            }
            e.picturefill || s.pf || (s.pf = function(u) {
                var f, h;
                if (!e.picturefill)
                    for (f = 0,
                    h = u.elements.length; f < h; f++)
                        r(u.elements[f])
            }
            ,
            r = (function() {
                var u = function(v, b) {
                    return v.w - b.w
                }
                  , f = /^\s*\d+\.*\d*px\s*$/
                  , h = function(v) {
                    var b, A, T = v.length, R = v[T - 1], y = 0;
                    for (y; y < T; y++)
                        if (R = v[y],
                        R.d = R.w / v.w,
                        R.d >= v.d) {
                            !R.cached && (b = v[y - 1]) && b.d > v.d - .13 * Math.pow(v.d, 2.2) && (A = Math.pow(b.d - .6, 1.6),
                            b.cached && (b.d += .15 * A),
                            b.d + (R.d - v.d) * A > v.d && (R = b));
                            break
                        }
                    return R
                }
                  , d = (function() {
                    var v, b = /(([^,\s].[^\s]+)\s+(\d+)w)/g, A = /\s/, T = function(R, y, x, P) {
                        v.push({
                            c: y,
                            u: x,
                            w: P * 1
                        })
                    };
                    return function(R) {
                        return v = [],
                        R = R.trim(),
                        R.replace(l, "").replace(b, T),
                        !v.length && R && !A.test(R) && v.push({
                            c: R,
                            u: R,
                            w: 99
                        }),
                        v
                    }
                }
                )()
                  , _ = function() {
                    _.init || (_.init = !0,
                    addEventListener("resize", (function() {
                        var v, b = t.getElementsByClassName("lazymatchmedia"), A = function() {
                            var T, R;
                            for (T = 0,
                            R = b.length; T < R; T++)
                                r(b[T])
                        };
                        return function() {
                            clearTimeout(v),
                            v = setTimeout(A, 66)
                        }
                    }
                    )()))
                }
                  , g = function(v, b) {
                    var A, T = v.getAttribute("srcset") || v.getAttribute(s.srcsetAttr);
                    !T && b && (T = v._lazypolyfill ? v._lazypolyfill._set : v.getAttribute(s.srcAttr) || v.getAttribute("src")),
                    (!v._lazypolyfill || v._lazypolyfill._set != T) && (A = d(T || ""),
                    b && v.parentNode && (A.isPicture = v.parentNode.nodeName.toUpperCase() == "PICTURE",
                    A.isPicture && e.matchMedia && (n.aC(v, "lazymatchmedia"),
                    _())),
                    A._set = T,
                    Object.defineProperty(v, "_lazypolyfill", {
                        value: A,
                        writable: !0
                    }))
                }
                  , m = function(v) {
                    var b = e.devicePixelRatio || 1
                      , A = n.getX && n.getX(v);
                    return Math.min(A || b, 2.5, b)
                }
                  , p = function(v) {
                    if (e.matchMedia)
                        p = function(b) {
                            return !b || (matchMedia(b) || {}).matches
                        }
                        ;
                    else
                        return !v;
                    return p(v)
                }
                  , E = function(v) {
                    var b, A, T, R, y, x, P;
                    if (R = v,
                    g(R, !0),
                    y = R._lazypolyfill,
                    y.isPicture) {
                        for (A = 0,
                        b = v.parentNode.getElementsByTagName("source"),
                        T = b.length; A < T; A++)
                            if (s.supportsType(b[A].getAttribute("type"), v) && p(b[A].getAttribute("media"))) {
                                R = b[A],
                                g(R),
                                y = R._lazypolyfill;
                                break
                            }
                    }
                    return y.length > 1 ? (P = R.getAttribute("sizes") || "",
                    P = f.test(P) && parseInt(P, 10) || n.gW(v, v.parentNode),
                    y.d = m(v),
                    !y.src || !y.w || y.w < P ? (y.w = P,
                    x = h(y.sort(u)),
                    y.src = x) : x = y.src) : x = y[0],
                    x
                }
                  , S = function(v) {
                    if (!(a && v.parentNode && v.parentNode.nodeName.toUpperCase() != "PICTURE")) {
                        var b = E(v);
                        b && b.u && v._lazypolyfill.cur != b.u && (v._lazypolyfill.cur = b.u,
                        b.cached = !0,
                        v.setAttribute(s.srcAttr, b.u),
                        v.setAttribute("src", b.u))
                    }
                };
                return S.parse = d,
                S
            }
            )(),
            s.loadedClass && s.loadingClass && (function() {
                var u = [];
                ['img[sizes$="px"][srcset].', "picture > img:not([srcset])."].forEach(function(f) {
                    u.push(f + s.loadedClass),
                    u.push(f + s.loadingClass)
                }),
                s.pf({
                    elements: t.querySelectorAll(u.join(", "))
                })
            }
            )())
        })
    }
    )(gc)),
    gc.exports
}
X_();
function q_(i, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(i, typeof (r = (function(s, o) {
            if (typeof s != "object" || s === null)
                return s;
            var a = s[Symbol.toPrimitive];
            if (a !== void 0) {
                var l = a.call(s, "string");
                if (typeof l != "object")
                    return l;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(s)
        }
        )(n.key)) == "symbol" ? r : String(r), n)
    }
    var r
}
function zf(i, e, t) {
    return e && q_(i.prototype, e),
    Object.defineProperty(i, "prototype", {
        writable: !1
    }),
    i
}
function qi() {
    return qi = Object.assign ? Object.assign.bind() : function(i) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n])
        }
        return i
    }
    ,
    qi.apply(this, arguments)
}
function sc(i, e) {
    i.prototype = Object.create(e.prototype),
    i.prototype.constructor = i,
    _a(i, e)
}
function yu(i) {
    return yu = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    }
    ,
    yu(i)
}
function _a(i, e) {
    return _a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
        return t.__proto__ = n,
        t
    }
    ,
    _a(i, e)
}
function Y_() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch (i) {
        return !1
    }
}
function Su(i, e, t) {
    return Su = Y_() ? Reflect.construct.bind() : function(n, r, s) {
        var o = [null];
        o.push.apply(o, r);
        var a = new (Function.bind.apply(n, o));
        return s && _a(a, s.prototype),
        a
    }
    ,
    Su.apply(null, arguments)
}
function Eu(i) {
    var e = typeof Map == "function" ? new Map : void 0;
    return Eu = function(t) {
        if (t === null || Function.toString.call(t).indexOf("[native code]") === -1)
            return t;
        if (typeof t != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (e !== void 0) {
            if (e.has(t))
                return e.get(t);
            e.set(t, n)
        }
        function n() {
            return Su(t, arguments, yu(this).constructor)
        }
        return n.prototype = Object.create(t.prototype, {
            constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        _a(n, t)
    }
    ,
    Eu(i)
}
function $_(i) {
    if (i === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return i
}
var Rr, j_ = function() {
    this.before = void 0,
    this.beforeLeave = void 0,
    this.leave = void 0,
    this.afterLeave = void 0,
    this.beforeEnter = void 0,
    this.enter = void 0,
    this.afterEnter = void 0,
    this.after = void 0
};
(function(i) {
    i[i.off = 0] = "off",
    i[i.error = 1] = "error",
    i[i.warning = 2] = "warning",
    i[i.info = 3] = "info",
    i[i.debug = 4] = "debug"
}
)(Rr || (Rr = {}));
var Nh = Rr.off
  , hs = (function() {
    function i(t) {
        this.t = void 0,
        this.t = t
    }
    i.getLevel = function() {
        return Nh
    }
    ,
    i.setLevel = function(t) {
        return Nh = Rr[t]
    }
    ;
    var e = i.prototype;
    return e.error = function() {
        this.i(console.error, Rr.error, [].slice.call(arguments))
    }
    ,
    e.warn = function() {
        this.i(console.warn, Rr.warning, [].slice.call(arguments))
    }
    ,
    e.info = function() {
        this.i(console.info, Rr.info, [].slice.call(arguments))
    }
    ,
    e.debug = function() {
        this.i(console.log, Rr.debug, [].slice.call(arguments))
    }
    ,
    e.i = function(t, n, r) {
        n <= i.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(r))
    }
    ,
    i
}
)();
function Us(i) {
    return i.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
}
function Oh(i) {
    return i && i.sensitive ? "" : "i"
}
var ji = {
    container: "container",
    history: "history",
    namespace: "namespace",
    prefix: "data-barba",
    prevent: "prevent",
    wrapper: "wrapper"
}
  , ds = new ((function() {
    function i() {
        this.o = ji,
        this.u = void 0,
        this.h = {
            after: null,
            before: null,
            parent: null
        }
    }
    var e = i.prototype;
    return e.toString = function(t) {
        return t.outerHTML
    }
    ,
    e.toDocument = function(t) {
        return this.u || (this.u = new DOMParser),
        this.u.parseFromString(t, "text/html")
    }
    ,
    e.toElement = function(t) {
        var n = document.createElement("div");
        return n.innerHTML = t,
        n
    }
    ,
    e.getHtml = function(t) {
        return t === void 0 && (t = document),
        this.toString(t.documentElement)
    }
    ,
    e.getWrapper = function(t) {
        return t === void 0 && (t = document),
        t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
    }
    ,
    e.getContainer = function(t) {
        return t === void 0 && (t = document),
        t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
    }
    ,
    e.removeContainer = function(t) {
        document.body.contains(t) && (this.v(t),
        t.parentNode.removeChild(t))
    }
    ,
    e.addContainer = function(t, n) {
        var r = this.getContainer() || this.h.before;
        r ? this.l(t, r) : this.h.after ? this.h.after.parentNode.insertBefore(t, this.h.after) : this.h.parent ? this.h.parent.appendChild(t) : n.appendChild(t)
    }
    ,
    e.getSibling = function() {
        return this.h
    }
    ,
    e.getNamespace = function(t) {
        t === void 0 && (t = document);
        var n = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
        return n ? n.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
    }
    ,
    e.getHref = function(t) {
        if (t.tagName && t.tagName.toLowerCase() === "a") {
            if (typeof t.href == "string")
                return t.href;
            var n = t.getAttribute("href") || t.getAttribute("xlink:href");
            if (n)
                return this.resolveUrl(n.baseVal || n)
        }
        return null
    }
    ,
    e.resolveUrl = function() {
        var t = [].slice.call(arguments).length;
        if (t === 0)
            throw new Error("resolveUrl requires at least one argument; got none.");
        var n = document.createElement("base");
        if (n.href = arguments[0],
        t === 1)
            return n.href;
        var r = document.getElementsByTagName("head")[0];
        r.insertBefore(n, r.firstChild);
        for (var s, o = document.createElement("a"), a = 1; a < t; a++)
            o.href = arguments[a],
            n.href = s = o.href;
        return r.removeChild(n),
        s
    }
    ,
    e.l = function(t, n) {
        n.parentNode.insertBefore(t, n.nextSibling)
    }
    ,
    e.v = function(t) {
        return this.h = {
            after: t.nextElementSibling,
            before: t.previousElementSibling,
            parent: t.parentElement
        },
        this.h
    }
    ,
    i
}
)())
  , K_ = (function() {
    function i() {
        this.p = void 0,
        this.m = [],
        this.P = -1
    }
    var e = i.prototype;
    return e.init = function(t, n) {
        this.p = "barba";
        var r = {
            data: {},
            ns: n,
            scroll: {
                x: window.scrollX,
                y: window.scrollY
            },
            url: t
        };
        this.P = 0,
        this.m.push(r);
        var s = {
            from: this.p,
            index: this.P,
            states: [].concat(this.m)
        };
        window.history && window.history.replaceState(s, "", t)
    }
    ,
    e.change = function(t, n, r) {
        if (r && r.state) {
            var s = r.state
              , o = s.index;
            n = this.g(this.P - o),
            this.replace(s.states),
            this.P = o
        } else
            this.add(t, n);
        return n
    }
    ,
    e.add = function(t, n, r, s) {
        var o = r != null ? r : this.R(n)
          , a = {
            data: s != null ? s : {},
            ns: "tmp",
            scroll: {
                x: window.scrollX,
                y: window.scrollY
            },
            url: t
        };
        switch (o) {
        case "push":
            this.P = this.size,
            this.m.push(a);
            break;
        case "replace":
            this.set(this.P, a)
        }
        var l = {
            from: this.p,
            index: this.P,
            states: [].concat(this.m)
        };
        switch (o) {
        case "push":
            window.history && window.history.pushState(l, "", t);
            break;
        case "replace":
            window.history && window.history.replaceState(l, "", t)
        }
    }
    ,
    e.store = function(t, n) {
        var r = n || this.P
          , s = this.get(r);
        s.data = qi({}, s.data, t),
        this.set(r, s);
        var o = {
            from: this.p,
            index: this.P,
            states: [].concat(this.m)
        };
        window.history.replaceState(o, "")
    }
    ,
    e.update = function(t, n) {
        var r = n || this.P
          , s = qi({}, this.get(r), t);
        this.set(r, s)
    }
    ,
    e.remove = function(t) {
        t ? this.m.splice(t, 1) : this.m.pop(),
        this.P--
    }
    ,
    e.clear = function() {
        this.m = [],
        this.P = -1
    }
    ,
    e.replace = function(t) {
        this.m = t
    }
    ,
    e.get = function(t) {
        return this.m[t]
    }
    ,
    e.set = function(t, n) {
        return this.m[t] = n
    }
    ,
    e.R = function(t) {
        var n = "push"
          , r = t
          , s = ji.prefix + "-" + ji.history;
        return r.hasAttribute && r.hasAttribute(s) && (n = r.getAttribute(s)),
        n
    }
    ,
    e.g = function(t) {
        return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : t === 0 ? "popstate" : t > 0 ? "back" : "forward"
    }
    ,
    zf(i, [{
        key: "current",
        get: function() {
            return this.m[this.P]
        }
    }, {
        key: "previous",
        get: function() {
            return this.P < 1 ? null : this.m[this.P - 1]
        }
    }, {
        key: "size",
        get: function() {
            return this.m.length
        }
    }]),
    i
}
)()
  , Up = new K_
  , kl = function(i, e) {
    try {
        var t = (function() {
            if (!e.next.html)
                return Promise.resolve(i).then(function(n) {
                    var r = e.next;
                    if (n) {
                        var s = ds.toElement(n.html);
                        r.namespace = ds.getNamespace(s),
                        r.container = ds.getContainer(s),
                        r.url = n.url,
                        r.html = n.html,
                        Up.update({
                            ns: r.namespace
                        });
                        var o = ds.toDocument(n.html);
                        document.title = o.title
                    }
                })
        }
        )();
        return Promise.resolve(t && t.then ? t.then(function() {}) : void 0)
    } catch (n) {
        return Promise.reject(n)
    }
}
  , Np = function i(e, t, n) {
    return e instanceof RegExp ? (function(r, s) {
        if (!s)
            return r;
        for (var o = /\((?:\?<(.*?)>)?(?!\?)/g, a = 0, l = o.exec(r.source); l; )
            s.push({
                name: l[1] || a++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            }),
            l = o.exec(r.source);
        return r
    }
    )(e, t) : Array.isArray(e) ? (function(r, s, o) {
        var a = r.map(function(l) {
            return i(l, s, o).source
        });
        return new RegExp("(?:".concat(a.join("|"), ")"),Oh(o))
    }
    )(e, t, n) : (function(r, s, o) {
        return (function(a, l, c) {
            c === void 0 && (c = {});
            for (var u = c.strict, f = u !== void 0 && u, h = c.start, d = h === void 0 || h, _ = c.end, g = _ === void 0 || _, m = c.encode, p = m === void 0 ? function(H) {
                return H
            }
            : m, E = c.delimiter, S = E === void 0 ? "/#?" : E, v = c.endsWith, b = "[".concat(Us(v === void 0 ? "" : v), "]|$"), A = "[".concat(Us(S), "]"), T = d ? "^" : "", R = 0, y = a; R < y.length; R++) {
                var x = y[R];
                if (typeof x == "string")
                    T += Us(p(x));
                else {
                    var P = Us(p(x.prefix))
                      , U = Us(p(x.suffix));
                    if (x.pattern)
                        if (l && l.push(x),
                        P || U)
                            if (x.modifier === "+" || x.modifier === "*") {
                                var O = x.modifier === "*" ? "?" : "";
                                T += "(?:".concat(P, "((?:").concat(x.pattern, ")(?:").concat(U).concat(P, "(?:").concat(x.pattern, "))*)").concat(U, ")").concat(O)
                            } else
                                T += "(?:".concat(P, "(").concat(x.pattern, ")").concat(U, ")").concat(x.modifier);
                        else
                            T += x.modifier === "+" || x.modifier === "*" ? "((?:".concat(x.pattern, ")").concat(x.modifier, ")") : "(".concat(x.pattern, ")").concat(x.modifier);
                    else
                        T += "(?:".concat(P).concat(U, ")").concat(x.modifier)
                }
            }
            if (g)
                f || (T += "".concat(A, "?")),
                T += c.endsWith ? "(?=".concat(b, ")") : "$";
            else {
                var B = a[a.length - 1]
                  , X = typeof B == "string" ? A.indexOf(B[B.length - 1]) > -1 : B === void 0;
                f || (T += "(?:".concat(A, "(?=").concat(b, "))?")),
                X || (T += "(?=".concat(A, "|").concat(b, ")"))
            }
            return new RegExp(T,Oh(c))
        }
        )((function(a, l) {
            l === void 0 && (l = {});
            for (var c = (function(U) {
                for (var O = [], B = 0; B < U.length; ) {
                    var X = U[B];
                    if (X !== "*" && X !== "+" && X !== "?")
                        if (X !== "\\")
                            if (X !== "{")
                                if (X !== "}")
                                    if (X !== ":")
                                        if (X !== "(")
                                            O.push({
                                                type: "CHAR",
                                                index: B,
                                                value: U[B++]
                                            });
                                        else {
                                            var H = 1
                                              , Y = "";
                                            if (U[k = B + 1] === "?")
                                                throw new TypeError('Pattern cannot start with "?" at '.concat(k));
                                            for (; k < U.length; )
                                                if (U[k] !== "\\") {
                                                    if (U[k] === ")") {
                                                        if (--H == 0) {
                                                            k++;
                                                            break
                                                        }
                                                    } else if (U[k] === "(" && (H++,
                                                    U[k + 1] !== "?"))
                                                        throw new TypeError("Capturing groups are not allowed at ".concat(k));
                                                    Y += U[k++]
                                                } else
                                                    Y += U[k++] + U[k++];
                                            if (H)
                                                throw new TypeError("Unbalanced pattern at ".concat(B));
                                            if (!Y)
                                                throw new TypeError("Missing pattern at ".concat(B));
                                            O.push({
                                                type: "PATTERN",
                                                index: B,
                                                value: Y
                                            }),
                                            B = k
                                        }
                                    else {
                                        for (var N = "", k = B + 1; k < U.length; ) {
                                            var C = U.charCodeAt(k);
                                            if (!(C >= 48 && C <= 57 || C >= 65 && C <= 90 || C >= 97 && C <= 122 || C === 95))
                                                break;
                                            N += U[k++]
                                        }
                                        if (!N)
                                            throw new TypeError("Missing parameter name at ".concat(B));
                                        O.push({
                                            type: "NAME",
                                            index: B,
                                            value: N
                                        }),
                                        B = k
                                    }
                                else
                                    O.push({
                                        type: "CLOSE",
                                        index: B,
                                        value: U[B++]
                                    });
                            else
                                O.push({
                                    type: "OPEN",
                                    index: B,
                                    value: U[B++]
                                });
                        else
                            O.push({
                                type: "ESCAPED_CHAR",
                                index: B++,
                                value: U[B++]
                            });
                    else
                        O.push({
                            type: "MODIFIER",
                            index: B,
                            value: U[B++]
                        })
                }
                return O.push({
                    type: "END",
                    index: B,
                    value: ""
                }),
                O
            }
            )(a), u = l.prefixes, f = u === void 0 ? "./" : u, h = "[^".concat(Us(l.delimiter || "/#?"), "]+?"), d = [], _ = 0, g = 0, m = "", p = function(U) {
                if (g < c.length && c[g].type === U)
                    return c[g++].value
            }, E = function(U) {
                var O = p(U);
                if (O !== void 0)
                    return O;
                var B = c[g]
                  , X = B.index;
                throw new TypeError("Unexpected ".concat(B.type, " at ").concat(X, ", expected ").concat(U))
            }, S = function() {
                for (var U, O = ""; U = p("CHAR") || p("ESCAPED_CHAR"); )
                    O += U;
                return O
            }; g < c.length; ) {
                var v = p("CHAR")
                  , b = p("NAME")
                  , A = p("PATTERN");
                if (b || A)
                    f.indexOf(R = v || "") === -1 && (m += R,
                    R = ""),
                    m && (d.push(m),
                    m = ""),
                    d.push({
                        name: b || _++,
                        prefix: R,
                        suffix: "",
                        pattern: A || h,
                        modifier: p("MODIFIER") || ""
                    });
                else {
                    var T = v || p("ESCAPED_CHAR");
                    if (T)
                        m += T;
                    else if (m && (d.push(m),
                    m = ""),
                    p("OPEN")) {
                        var R = S()
                          , y = p("NAME") || ""
                          , x = p("PATTERN") || ""
                          , P = S();
                        E("CLOSE"),
                        d.push({
                            name: y || (x ? _++ : ""),
                            pattern: y && !x ? h : x,
                            prefix: R,
                            suffix: P,
                            modifier: p("MODIFIER") || ""
                        })
                    } else
                        E("END")
                }
            }
            return d
        }
        )(r, o), s, o)
    }
    )(e, t, n)
}
  , Z_ = {
    __proto__: null,
    update: kl,
    nextTick: function() {
        return new Promise(function(i) {
            window.requestAnimationFrame(i)
        }
        )
    },
    pathToRegexp: Np
}
  , Op = function() {
    return window.location.origin
}
  , va = function(i) {
    return i === void 0 && (i = window.location.href),
    Cr(i).port
}
  , Cr = function(i) {
    var e, t = i.match(/:\d+/);
    if (t === null)
        /^http/.test(i) && (e = 80),
        /^https/.test(i) && (e = 443);
    else {
        var n = t[0].substring(1);
        e = parseInt(n, 10)
    }
    var r, s = i.replace(Op(), ""), o = {}, a = s.indexOf("#");
    a >= 0 && (r = s.slice(a + 1),
    s = s.slice(0, a));
    var l = s.indexOf("?");
    return l >= 0 && (o = Fp(s.slice(l + 1)),
    s = s.slice(0, l)),
    {
        hash: r,
        path: s,
        port: e,
        query: o
    }
}
  , Fp = function(i) {
    return i.split("&").reduce(function(e, t) {
        var n = t.split("=");
        return e[n[0]] = n[1],
        e
    }, {})
}
  , Mu = function(i) {
    return i === void 0 && (i = window.location.href),
    i.replace(/(\/#.*|\/|#.*)$/, "")
}
  , J_ = {
    __proto__: null,
    getHref: function() {
        return window.location.href
    },
    getAbsoluteHref: function(i, e) {
        return e === void 0 && (e = document.baseURI),
        new URL(i,e).href
    },
    getOrigin: Op,
    getPort: va,
    getPath: function(i) {
        return i === void 0 && (i = window.location.href),
        Cr(i).path
    },
    getQuery: function(i, e) {
        return e === void 0 && (e = !1),
        e ? JSON.stringify(Cr(i).query) : Cr(i).query
    },
    getHash: function(i) {
        return Cr(i).hash
    },
    parse: Cr,
    parseQuery: Fp,
    clean: Mu
};
function Q_(i, e, t, n, r) {
    return e === void 0 && (e = 2e3),
    new Promise(function(s, o) {
        var a = new XMLHttpRequest;
        a.onreadystatechange = function() {
            if (a.readyState === XMLHttpRequest.DONE) {
                if (a.status === 200) {
                    var l = a.responseURL !== "" && a.responseURL !== i ? a.responseURL : i;
                    s({
                        html: a.responseText,
                        url: qi({
                            href: l
                        }, Cr(l))
                    }),
                    n.update(i, {
                        status: "fulfilled",
                        target: l
                    })
                } else if (a.status) {
                    var c = {
                        status: a.status,
                        statusText: a.statusText
                    };
                    t(i, c),
                    o(c),
                    n.update(i, {
                        status: "rejected"
                    })
                }
            }
        }
        ,
        a.ontimeout = function() {
            var l = new Error("Timeout error [" + e + "]");
            t(i, l),
            o(l),
            n.update(i, {
                status: "rejected"
            })
        }
        ,
        a.onerror = function() {
            var l = new Error("Fetch error");
            t(i, l),
            o(l),
            n.update(i, {
                status: "rejected"
            })
        }
        ,
        a.open("GET", i),
        a.timeout = e,
        a.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"),
        a.setRequestHeader("x-barba", "yes"),
        r.all().forEach(function(l, c) {
            a.setRequestHeader(c, l)
        }),
        a.send()
    }
    )
}
function ev(i) {
    return !!i && (typeof i == "object" || typeof i == "function") && typeof i.then == "function"
}
function no(i, e) {
    return e === void 0 && (e = {}),
    function() {
        var t = arguments
          , n = !1
          , r = new Promise(function(s, o) {
            e.async = function() {
                return n = !0,
                function(l, c) {
                    l ? o(l) : s(c)
                }
            }
            ;
            var a = i.apply(e, [].slice.call(t));
            n || (ev(a) ? a.then(s, o) : s(a))
        }
        );
        return r
    }
}
var Ar = new ((function(i) {
    function e() {
        var n;
        return (n = i.call(this) || this).logger = new hs("@barba/core"),
        n.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"],
        n.registered = new Map,
        n.init(),
        n
    }
    sc(e, i);
    var t = e.prototype;
    return t.init = function() {
        var n = this;
        this.registered.clear(),
        this.all.forEach(function(r) {
            n[r] || (n[r] = function(s, o) {
                n.registered.has(r) || n.registered.set(r, new Set),
                n.registered.get(r).add({
                    ctx: o || {},
                    fn: s
                })
            }
            )
        })
    }
    ,
    t.do = function(n) {
        var r = arguments
          , s = this;
        if (this.registered.has(n)) {
            var o = Promise.resolve();
            return this.registered.get(n).forEach(function(a) {
                o = o.then(function() {
                    return no(a.fn, a.ctx).apply(void 0, [].slice.call(r, 1))
                })
            }),
            o.catch(function(a) {
                s.logger.debug("Hook error [" + n + "]"),
                s.logger.error(a)
            })
        }
        return Promise.resolve()
    }
    ,
    t.clear = function() {
        var n = this;
        this.all.forEach(function(r) {
            delete n[r]
        }),
        this.init()
    }
    ,
    t.help = function() {
        this.logger.info("Available hooks: " + this.all.join(","));
        var n = [];
        this.registered.forEach(function(r, s) {
            return n.push(s)
        }),
        this.logger.info("Registered hooks: " + n.join(","))
    }
    ,
    e
}
)(j_))
  , Bp = (function() {
    function i(e) {
        if (this.k = void 0,
        this.O = [],
        typeof e == "boolean")
            this.k = e;
        else {
            var t = Array.isArray(e) ? e : [e];
            this.O = t.map(function(n) {
                return Np(n)
            })
        }
    }
    return i.prototype.checkHref = function(e) {
        if (typeof this.k == "boolean")
            return this.k;
        var t = Cr(e).path;
        return this.O.some(function(n) {
            return n.exec(t) !== null
        })
    }
    ,
    i
}
)()
  , tv = (function(i) {
    function e(n) {
        var r;
        return (r = i.call(this, n) || this).T = new Map,
        r
    }
    sc(e, i);
    var t = e.prototype;
    return t.set = function(n, r, s, o, a) {
        return this.T.set(n, {
            action: s,
            request: r,
            status: o,
            target: a != null ? a : n
        }),
        {
            action: s,
            request: r,
            status: o,
            target: a
        }
    }
    ,
    t.get = function(n) {
        return this.T.get(n)
    }
    ,
    t.getRequest = function(n) {
        return this.T.get(n).request
    }
    ,
    t.getAction = function(n) {
        return this.T.get(n).action
    }
    ,
    t.getStatus = function(n) {
        return this.T.get(n).status
    }
    ,
    t.getTarget = function(n) {
        return this.T.get(n).target
    }
    ,
    t.has = function(n) {
        return !this.checkHref(n) && this.T.has(n)
    }
    ,
    t.delete = function(n) {
        return this.T.delete(n)
    }
    ,
    t.update = function(n, r) {
        var s = qi({}, this.T.get(n), r);
        return this.T.set(n, s),
        s
    }
    ,
    e
}
)(Bp)
  , nv = (function() {
    function i() {
        this.A = new Map
    }
    var e = i.prototype;
    return e.set = function(t, n) {
        return this.A.set(t, n),
        {
            name: n
        }
    }
    ,
    e.get = function(t) {
        return this.A.get(t)
    }
    ,
    e.all = function() {
        return this.A
    }
    ,
    e.has = function(t) {
        return this.A.has(t)
    }
    ,
    e.delete = function(t) {
        return this.A.delete(t)
    }
    ,
    e.clear = function() {
        return this.A.clear()
    }
    ,
    i
}
)()
  , iv = function() {
    return !window.history.pushState
}
  , rv = function(i) {
    return !i.el || !i.href
}
  , sv = function(i) {
    var e = i.event;
    return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey
}
  , ov = function(i) {
    var e = i.el;
    return e.hasAttribute("target") && e.target === "_blank"
}
  , av = function(i) {
    var e = i.el;
    return e.protocol !== void 0 && window.location.protocol !== e.protocol || e.hostname !== void 0 && window.location.hostname !== e.hostname
}
  , lv = function(i) {
    var e = i.el;
    return e.port !== void 0 && va() !== va(e.href)
}
  , cv = function(i) {
    var e = i.el;
    return e.getAttribute && typeof e.getAttribute("download") == "string"
}
  , uv = function(i) {
    return i.el.hasAttribute(ji.prefix + "-" + ji.prevent)
}
  , fv = function(i) {
    return !!i.el.closest("[" + ji.prefix + "-" + ji.prevent + '="all"]')
}
  , hv = function(i) {
    var e = i.href;
    return Mu(e) === Mu() && va(e) === va()
}
  , dv = (function(i) {
    function e(n) {
        var r;
        return (r = i.call(this, n) || this).suite = [],
        r.tests = new Map,
        r.init(),
        r
    }
    sc(e, i);
    var t = e.prototype;
    return t.init = function() {
        this.add("pushState", iv),
        this.add("exists", rv),
        this.add("newTab", sv),
        this.add("blank", ov),
        this.add("corsDomain", av),
        this.add("corsPort", lv),
        this.add("download", cv),
        this.add("preventSelf", uv),
        this.add("preventAll", fv),
        this.add("sameUrl", hv, !1)
    }
    ,
    t.add = function(n, r, s) {
        s === void 0 && (s = !0),
        this.tests.set(n, r),
        s && this.suite.push(n)
    }
    ,
    t.run = function(n, r, s, o) {
        return this.tests.get(n)({
            el: r,
            event: s,
            href: o
        })
    }
    ,
    t.checkLink = function(n, r, s) {
        var o = this;
        return this.suite.some(function(a) {
            return o.run(a, n, r, s)
        })
    }
    ,
    e
}
)(Bp)
  , _c = (function(i) {
    function e(t, n) {
        var r;
        return n === void 0 && (n = "Barba error"),
        (r = i.call.apply(i, [this].concat([].slice.call(arguments, 2))) || this).error = void 0,
        r.label = void 0,
        r.error = t,
        r.label = n,
        Error.captureStackTrace && Error.captureStackTrace($_(r), e),
        r.name = "BarbaError",
        r
    }
    return sc(e, i),
    e
}
)(Eu(Error))
  , pv = (function() {
    function i(t) {
        t === void 0 && (t = []),
        this.logger = new hs("@barba/core"),
        this.all = [],
        this.page = [],
        this.once = [],
        this.j = [{
            name: "namespace",
            type: "strings"
        }, {
            name: "custom",
            type: "function"
        }],
        t && (this.all = this.all.concat(t)),
        this.update()
    }
    var e = i.prototype;
    return e.add = function(t, n) {
        t === "rule" ? this.j.splice(n.position || 0, 0, n.value) : this.all.push(n),
        this.update()
    }
    ,
    e.resolve = function(t, n) {
        var r = this;
        n === void 0 && (n = {});
        var s = n.once ? this.once : this.page;
        s = s.filter(n.self ? function(h) {
            return h.name && h.name === "self"
        }
        : function(h) {
            return !h.name || h.name !== "self"
        }
        );
        var o = new Map
          , a = s.find(function(h) {
            var d = !0
              , _ = {};
            return n.self && h.name === "self" ? (o.set(h, _),
            !0) : (r.j.reverse().forEach(function(g) {
                d && (d = r.M(h, g, t, _),
                h.from && h.to && (d = r.M(h, g, t, _, "from") && r.M(h, g, t, _, "to")),
                h.from && !h.to && (d = r.M(h, g, t, _, "from")),
                !h.from && h.to && (d = r.M(h, g, t, _, "to")))
            }),
            o.set(h, _),
            d)
        })
          , l = o.get(a)
          , c = [];
        if (c.push(n.once ? "once" : "page"),
        n.self && c.push("self"),
        l) {
            var u, f = [a];
            Object.keys(l).length > 0 && f.push(l),
            (u = this.logger).info.apply(u, ["Transition found [" + c.join(",") + "]"].concat(f))
        } else
            this.logger.info("No transition found [" + c.join(",") + "]");
        return a
    }
    ,
    e.update = function() {
        var t = this;
        this.all = this.all.map(function(n) {
            return t.N(n)
        }).sort(function(n, r) {
            return n.priority - r.priority
        }).reverse().map(function(n) {
            return delete n.priority,
            n
        }),
        this.page = this.all.filter(function(n) {
            return n.leave !== void 0 || n.enter !== void 0
        }),
        this.once = this.all.filter(function(n) {
            return n.once !== void 0
        })
    }
    ,
    e.M = function(t, n, r, s, o) {
        var a = !0
          , l = !1
          , c = t
          , u = n.name
          , f = u
          , h = u
          , d = u
          , _ = o ? c[o] : c
          , g = o === "to" ? r.next : r.current;
        if (o ? _ && _[u] : _[u]) {
            switch (n.type) {
            case "strings":
            default:
                var m = Array.isArray(_[f]) ? _[f] : [_[f]];
                g[f] && m.indexOf(g[f]) !== -1 && (l = !0),
                m.indexOf(g[f]) === -1 && (a = !1);
                break;
            case "object":
                var p = Array.isArray(_[h]) ? _[h] : [_[h]];
                g[h] ? (g[h].name && p.indexOf(g[h].name) !== -1 && (l = !0),
                p.indexOf(g[h].name) === -1 && (a = !1)) : a = !1;
                break;
            case "function":
                _[d](r) ? l = !0 : a = !1
            }
            l && (o ? (s[o] = s[o] || {},
            s[o][u] = c[o][u]) : s[u] = c[u])
        }
        return a
    }
    ,
    e.S = function(t, n, r) {
        var s = 0;
        return (t[n] || t.from && t.from[n] || t.to && t.to[n]) && (s += Math.pow(10, r),
        t.from && t.from[n] && (s += 1),
        t.to && t.to[n] && (s += 2)),
        s
    }
    ,
    e.N = function(t) {
        var n = this;
        t.priority = 0;
        var r = 0;
        return this.j.forEach(function(s, o) {
            r += n.S(t, s.name, o + 1)
        }),
        t.priority = r,
        t
    }
    ,
    i
}
)();
function Fo(i, e) {
    try {
        var t = i()
    } catch (n) {
        return e(n)
    }
    return t && t.then ? t.then(void 0, e) : t
}
var mv = (function() {
    function i(t) {
        t === void 0 && (t = []),
        this.logger = new hs("@barba/core"),
        this.store = void 0,
        this.C = !1,
        this.store = new pv(t)
    }
    var e = i.prototype;
    return e.get = function(t, n) {
        return this.store.resolve(t, n)
    }
    ,
    e.doOnce = function(t) {
        var n = t.data
          , r = t.transition;
        try {
            var s = function() {
                o.C = !1
            }
              , o = this
              , a = r || {};
            o.C = !0;
            var l = Fo(function() {
                return Promise.resolve(o.L("beforeOnce", n, a)).then(function() {
                    return Promise.resolve(o.once(n, a)).then(function() {
                        return Promise.resolve(o.L("afterOnce", n, a)).then(function() {})
                    })
                })
            }, function(c) {
                o.C = !1,
                o.logger.debug("Transition error [before/after/once]"),
                o.logger.error(c)
            });
            return Promise.resolve(l && l.then ? l.then(s) : s())
        } catch (c) {
            return Promise.reject(c)
        }
    }
    ,
    e.doPage = function(t) {
        var n = t.data
          , r = t.transition
          , s = t.page
          , o = t.wrapper;
        try {
            var a = function(h) {
                l.C = !1
            }
              , l = this
              , c = r || {}
              , u = c.sync === !0 || !1;
            l.C = !0;
            var f = Fo(function() {
                function h() {
                    return Promise.resolve(l.L("before", n, c)).then(function() {
                        function _(m) {
                            return Promise.resolve(l.remove(n)).then(function() {
                                return Promise.resolve(l.L("after", n, c)).then(function() {})
                            })
                        }
                        var g = (function() {
                            if (u)
                                return Fo(function() {
                                    return Promise.resolve(l.add(n, o)).then(function() {
                                        return Promise.resolve(l.L("beforeLeave", n, c)).then(function() {
                                            return Promise.resolve(l.L("beforeEnter", n, c)).then(function() {
                                                return Promise.resolve(Promise.all([l.leave(n, c), l.enter(n, c)])).then(function() {
                                                    return Promise.resolve(l.L("afterLeave", n, c)).then(function() {
                                                        return Promise.resolve(l.L("afterEnter", n, c)).then(function() {})
                                                    })
                                                })
                                            })
                                        })
                                    })
                                }, function(S) {
                                    if (l.H(S))
                                        throw new _c(S,"Transition error [sync]")
                                });
                            var m = function(S) {
                                return Fo(function() {
                                    var v = (function() {
                                        if (p !== !1)
                                            return Promise.resolve(l.add(n, o)).then(function() {
                                                return Promise.resolve(l.L("beforeEnter", n, c)).then(function() {
                                                    return Promise.resolve(l.enter(n, c, p)).then(function() {
                                                        return Promise.resolve(l.L("afterEnter", n, c)).then(function() {})
                                                    })
                                                })
                                            })
                                    }
                                    )();
                                    if (v && v.then)
                                        return v.then(function() {})
                                }, function(v) {
                                    if (l.H(v))
                                        throw new _c(v,"Transition error [before/after/enter]")
                                })
                            }
                              , p = !1
                              , E = Fo(function() {
                                return Promise.resolve(l.L("beforeLeave", n, c)).then(function() {
                                    return Promise.resolve(Promise.all([l.leave(n, c), kl(s, n)]).then(function(S) {
                                        return S[0]
                                    })).then(function(S) {
                                        return p = S,
                                        Promise.resolve(l.L("afterLeave", n, c)).then(function() {})
                                    })
                                })
                            }, function(S) {
                                if (l.H(S))
                                    throw new _c(S,"Transition error [before/after/leave]")
                            });
                            return E && E.then ? E.then(m) : m()
                        }
                        )();
                        return g && g.then ? g.then(_) : _()
                    })
                }
                var d = (function() {
                    if (u)
                        return Promise.resolve(kl(s, n)).then(function() {})
                }
                )();
                return d && d.then ? d.then(h) : h()
            }, function(h) {
                throw l.C = !1,
                h.name && h.name === "BarbaError" ? (l.logger.debug(h.label),
                l.logger.error(h.error),
                h) : (l.logger.debug("Transition error [page]"),
                l.logger.error(h),
                h)
            });
            return Promise.resolve(f && f.then ? f.then(a) : a())
        } catch (h) {
            return Promise.reject(h)
        }
    }
    ,
    e.once = function(t, n) {
        try {
            return Promise.resolve(Ar.do("once", t, n)).then(function() {
                return n.once ? no(n.once, n)(t) : Promise.resolve()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    e.leave = function(t, n) {
        try {
            return Promise.resolve(Ar.do("leave", t, n)).then(function() {
                return n.leave ? no(n.leave, n)(t) : Promise.resolve()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    e.enter = function(t, n, r) {
        try {
            return Promise.resolve(Ar.do("enter", t, n)).then(function() {
                return n.enter ? no(n.enter, n)(t, r) : Promise.resolve()
            })
        } catch (s) {
            return Promise.reject(s)
        }
    }
    ,
    e.add = function(t, n) {
        try {
            return ds.addContainer(t.next.container, n),
            Ar.do("nextAdded", t),
            Promise.resolve()
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    e.remove = function(t) {
        try {
            return ds.removeContainer(t.current.container),
            Ar.do("currentRemoved", t),
            Promise.resolve()
        } catch (n) {
            return Promise.reject(n)
        }
    }
    ,
    e.H = function(t) {
        return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status
    }
    ,
    e.L = function(t, n, r) {
        try {
            return Promise.resolve(Ar.do(t, n, r)).then(function() {
                return r[t] ? no(r[t], r)(n) : Promise.resolve()
            })
        } catch (s) {
            return Promise.reject(s)
        }
    }
    ,
    zf(i, [{
        key: "isRunning",
        get: function() {
            return this.C
        },
        set: function(t) {
            this.C = t
        }
    }, {
        key: "hasOnce",
        get: function() {
            return this.store.once.length > 0
        }
    }, {
        key: "hasSelf",
        get: function() {
            return this.store.all.some(function(t) {
                return t.name === "self"
            })
        }
    }, {
        key: "shouldWait",
        get: function() {
            return this.store.all.some(function(t) {
                return t.to && !t.to.route || t.sync
            })
        }
    }]),
    i
}
)()
  , gv = (function() {
    function i(e) {
        var t = this;
        this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"],
        this.byNamespace = new Map,
        e.length !== 0 && (e.forEach(function(n) {
            t.byNamespace.set(n.namespace, n)
        }),
        this.names.forEach(function(n) {
            Ar[n](t._(n))
        }))
    }
    return i.prototype._ = function(e) {
        var t = this;
        return function(n) {
            var r = e.match(/enter/i) ? n.next : n.current
              , s = t.byNamespace.get(r.namespace);
            return s && s[e] ? no(s[e], s)(n) : Promise.resolve()
        }
    }
    ,
    i
}
)();
Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector),
Element.prototype.closest || (Element.prototype.closest = function(i) {
    var e = this;
    do {
        if (e.matches(i))
            return e;
        e = e.parentElement || e.parentNode
    } while (e !== null && e.nodeType === 1);
    return null
}
);
var _v = {
    container: null,
    html: "",
    namespace: "",
    url: {
        hash: "",
        href: "",
        path: "",
        port: null,
        query: {}
    }
}
  , pr = new ((function() {
    function i() {
        this.version = "2.10.3",
        this.schemaPage = _v,
        this.Logger = hs,
        this.logger = new hs("@barba/core"),
        this.plugins = [],
        this.timeout = void 0,
        this.cacheIgnore = void 0,
        this.cacheFirstPage = void 0,
        this.prefetchIgnore = void 0,
        this.preventRunning = void 0,
        this.hooks = Ar,
        this.cache = void 0,
        this.headers = void 0,
        this.prevent = void 0,
        this.transitions = void 0,
        this.views = void 0,
        this.dom = ds,
        this.helpers = Z_,
        this.history = Up,
        this.request = Q_,
        this.url = J_,
        this.D = void 0,
        this.B = void 0,
        this.q = void 0,
        this.F = void 0
    }
    var e = i.prototype;
    return e.use = function(t, n) {
        var r = this.plugins;
        r.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : typeof t.install == "function" ? (t.install(this, n),
        r.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.')
    }
    ,
    e.init = function(t) {
        var n = t === void 0 ? {} : t
          , r = n.transitions
          , s = r === void 0 ? [] : r
          , o = n.views
          , a = o === void 0 ? [] : o
          , l = n.schema
          , c = l === void 0 ? ji : l
          , u = n.requestError
          , f = n.timeout
          , h = f === void 0 ? 2e3 : f
          , d = n.cacheIgnore
          , _ = d !== void 0 && d
          , g = n.cacheFirstPage
          , m = g !== void 0 && g
          , p = n.prefetchIgnore
          , E = p !== void 0 && p
          , S = n.preventRunning
          , v = S !== void 0 && S
          , b = n.prevent
          , A = b === void 0 ? null : b
          , T = n.debug
          , R = n.logLevel;
        if (hs.setLevel((T !== void 0 && T) === !0 ? "debug" : R === void 0 ? "off" : R),
        this.logger.info(this.version),
        Object.keys(c).forEach(function(P) {
            ji[P] && (ji[P] = c[P])
        }),
        this.B = u,
        this.timeout = h,
        this.cacheIgnore = _,
        this.cacheFirstPage = m,
        this.prefetchIgnore = E,
        this.preventRunning = v,
        this.q = this.dom.getWrapper(),
        !this.q)
            throw new Error("[@barba/core] No Barba wrapper found");
        this.I();
        var y = this.data.current;
        if (!y.container)
            throw new Error("[@barba/core] No Barba container found");
        if (this.cache = new tv(_),
        this.headers = new nv,
        this.prevent = new dv(E),
        this.transitions = new mv(s),
        this.views = new gv(a),
        A !== null) {
            if (typeof A != "function")
                throw new Error("[@barba/core] Prevent should be a function");
            this.prevent.add("preventCustom", A)
        }
        this.history.init(y.url.href, y.namespace),
        m && this.cache.set(y.url.href, Promise.resolve({
            html: y.html,
            url: y.url
        }), "init", "fulfilled"),
        this.U = this.U.bind(this),
        this.$ = this.$.bind(this),
        this.X = this.X.bind(this),
        this.G(),
        this.plugins.forEach(function(P) {
            return P.init()
        });
        var x = this.data;
        x.trigger = "barba",
        x.next = x.current,
        x.current = qi({}, this.schemaPage),
        this.hooks.do("ready", x),
        this.once(x),
        this.I()
    }
    ,
    e.destroy = function() {
        this.I(),
        this.J(),
        this.history.clear(),
        this.hooks.clear(),
        this.plugins = []
    }
    ,
    e.force = function(t) {
        window.location.assign(t)
    }
    ,
    e.go = function(t, n, r) {
        var s;
        if (n === void 0 && (n = "barba"),
        this.F = null,
        this.transitions.isRunning)
            this.force(t);
        else if (!(s = n === "popstate" ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) && this.url.getQuery(this.history.current.url, !0) === this.url.getQuery(t, !0) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf)
            return n = this.history.change(this.cache.has(t) ? this.cache.get(t).target : t, n, r),
            r && (r.stopPropagation(),
            r.preventDefault()),
            this.page(t, n, r != null ? r : void 0, s)
    }
    ,
    e.once = function(t) {
        try {
            var n = this;
            return Promise.resolve(n.hooks.do("beforeEnter", t)).then(function() {
                function r() {
                    return Promise.resolve(n.hooks.do("afterEnter", t)).then(function() {})
                }
                var s = (function() {
                    if (n.transitions.hasOnce) {
                        var o = n.transitions.get(t, {
                            once: !0
                        });
                        return Promise.resolve(n.transitions.doOnce({
                            transition: o,
                            data: t
                        })).then(function() {})
                    }
                }
                )();
                return s && s.then ? s.then(r) : r()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    e.page = function(t, n, r, s) {
        try {
            var o, a = function() {
                var f = l.data;
                return Promise.resolve(l.hooks.do("page", f)).then(function() {
                    var h = (function(d, _) {
                        try {
                            var g = (m = l.transitions.get(f, {
                                once: !1,
                                self: s
                            }),
                            Promise.resolve(l.transitions.doPage({
                                data: f,
                                page: o,
                                transition: m,
                                wrapper: l.q
                            })).then(function() {
                                l.I()
                            }))
                        } catch (p) {
                            return _()
                        }
                        var m;
                        return g && g.then ? g.then(void 0, _) : g
                    }
                    )(0, function() {
                        hs.getLevel() === 0 && l.force(f.next.url.href)
                    });
                    if (h && h.then)
                        return h.then(function() {})
                })
            }, l = this;
            if (l.data.next.url = qi({
                href: t
            }, l.url.parse(t)),
            l.data.trigger = n,
            l.data.event = r,
            l.cache.has(t))
                o = l.cache.update(t, {
                    action: "click"
                }).request;
            else {
                var c = l.request(t, l.timeout, l.onRequestError.bind(l, n), l.cache, l.headers);
                c.then(function(f) {
                    f.url.href !== t && l.history.add(f.url.href, n, "replace")
                }),
                o = l.cache.set(t, c, "click", "pending").request
            }
            var u = (function() {
                if (l.transitions.shouldWait)
                    return Promise.resolve(kl(o, l.data)).then(function() {})
            }
            )();
            return Promise.resolve(u && u.then ? u.then(a) : a())
        } catch (f) {
            return Promise.reject(f)
        }
    }
    ,
    e.onRequestError = function(t) {
        this.transitions.isRunning = !1;
        var n = [].slice.call(arguments, 1)
          , r = n[0]
          , s = n[1]
          , o = this.cache.getAction(r);
        return this.cache.delete(r),
        this.B && this.B(t, o, r, s) === !1 || o === "click" && this.force(r),
        !1
    }
    ,
    e.prefetch = function(t) {
        var n = this;
        t = this.url.getAbsoluteHref(t),
        this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba"), this.cache, this.headers).catch(function(r) {
            n.logger.error(r)
        }), "prefetch", "pending")
    }
    ,
    e.G = function() {
        this.prefetchIgnore !== !0 && (document.addEventListener("mouseover", this.U),
        document.addEventListener("touchstart", this.U)),
        document.addEventListener("click", this.$),
        window.addEventListener("popstate", this.X)
    }
    ,
    e.J = function() {
        this.prefetchIgnore !== !0 && (document.removeEventListener("mouseover", this.U),
        document.removeEventListener("touchstart", this.U)),
        document.removeEventListener("click", this.$),
        window.removeEventListener("popstate", this.X)
    }
    ,
    e.U = function(t) {
        var n = this
          , r = this.W(t);
        if (r) {
            var s = this.url.getAbsoluteHref(this.dom.getHref(r));
            this.prevent.checkHref(s) || this.cache.has(s) || this.cache.set(s, this.request(s, this.timeout, this.onRequestError.bind(this, r), this.cache, this.headers).catch(function(o) {
                n.logger.error(o)
            }), "enter", "pending")
        }
    }
    ,
    e.$ = function(t) {
        var n = this.W(t);
        if (n) {
            if (this.transitions.isRunning && this.preventRunning)
                return t.preventDefault(),
                void t.stopPropagation();
            this.F = t,
            this.go(this.dom.getHref(n), n, t)
        }
    }
    ,
    e.X = function(t) {
        this.go(this.url.getHref(), "popstate", t)
    }
    ,
    e.W = function(t) {
        for (var n = t.target; n && !this.dom.getHref(n); )
            n = n.parentNode;
        if (n && !this.prevent.checkLink(n, t, this.dom.getHref(n)))
            return n
    }
    ,
    e.I = function() {
        var t = this.url.getHref()
          , n = {
            container: this.dom.getContainer(),
            html: this.dom.getHtml(),
            namespace: this.dom.getNamespace(),
            url: qi({
                href: t
            }, this.url.parse(t))
        };
        this.D = {
            current: n,
            event: void 0,
            next: qi({}, this.schemaPage),
            trigger: void 0
        },
        this.hooks.do("reset", this.data)
    }
    ,
    zf(i, [{
        key: "data",
        get: function() {
            return this.D
        }
    }, {
        key: "wrapper",
        get: function() {
            return this.q
        }
    }]),
    i
}
)());
function sr(i) {
    if (i === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return i
}
function zp(i, e) {
    i.prototype = Object.create(e.prototype),
    i.prototype.constructor = i,
    i.__proto__ = e
}
/*!
 * GSAP 3.14.2
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var li = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, vo = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, kf, gn, Ut, Ti = 1e8, At = 1 / Ti, Tu = Math.PI * 2, vv = Tu / 4, xv = 0, kp = Math.sqrt, yv = Math.cos, Sv = Math.sin, un = function(e) {
    return typeof e == "string"
}, Ht = function(e) {
    return typeof e == "function"
}, mr = function(e) {
    return typeof e == "number"
}, Hf = function(e) {
    return typeof e > "u"
}, Ji = function(e) {
    return typeof e == "object"
}, Xn = function(e) {
    return e !== !1
}, Vf = function() {
    return typeof window < "u"
}, Ha = function(e) {
    return Ht(e) || un(e)
}, Hp = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Tn = Array.isArray, Ev = /random\([^)]+\)/g, Mv = /,\s*/g, Fh = /(?:-?\.?\d|\.)+/gi, Vp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, io = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, vc = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Gp = /[+-]=-?[.\d]+/, Tv = /[^,'"\[\]\s]+/gi, bv = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Ft, ki, bu, Gf, ui = {}, Hl = {}, Wp, Xp = function(e) {
    return (Hl = xo(e, ui)) && jn
}, Wf = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, xa = function(e, t) {
    return !t && console.warn(e)
}, qp = function(e, t) {
    return e && (ui[e] = t) && Hl && (Hl[e] = t) || ui
}, ya = function() {
    return 0
}, wv = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, Ml = {
    suppressEvents: !0,
    kill: !1
}, Av = {
    suppressEvents: !0
}, Xf = {}, Nr = [], wu = {}, Yp, ni = {}, xc = {}, Bh = 30, Tl = [], qf = "", Yf = function(e) {
    var t = e[0], n, r;
    if (Ji(t) || Ht(t) || (e = [e]),
    !(n = (t._gsap || {}).harness)) {
        for (r = Tl.length; r-- && !Tl[r].targetTest(t); )
            ;
        n = Tl[r]
    }
    for (r = e.length; r--; )
        e[r] && (e[r]._gsap || (e[r]._gsap = new _m(e[r],n))) || e.splice(r, 1);
    return e
}, ys = function(e) {
    return e._gsap || Yf(bi(e))[0]._gsap
}, $p = function(e, t, n) {
    return (n = e[t]) && Ht(n) ? e[t]() : Hf(n) && e.getAttribute && e.getAttribute(t) || n
}, qn = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, Gt = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, Ot = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, lo = function(e, t) {
    var n = t.charAt(0)
      , r = parseFloat(t.substr(2));
    return e = parseFloat(e),
    n === "+" ? e + r : n === "-" ? e - r : n === "*" ? e * r : e / r
}, Rv = function(e, t) {
    for (var n = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < n; )
        ;
    return r < n
}, Vl = function() {
    var e = Nr.length, t = Nr.slice(0), n, r;
    for (wu = {},
    Nr.length = 0,
    n = 0; n < e; n++)
        r = t[n],
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0)
}, $f = function(e) {
    return !!(e._initted || e._startAt || e.add)
}, jp = function(e, t, n, r) {
    Nr.length && !gn && Vl(),
    e.render(t, n, !!(gn && t < 0 && $f(e))),
    Nr.length && !gn && Vl()
}, Kp = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Tv).length < 2 ? t : un(e) ? e.trim() : e
}, Zp = function(e) {
    return e
}, fi = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, Cv = function(e) {
    return function(t, n) {
        for (var r in n)
            r in t || r === "duration" && e || r === "ease" || (t[r] = n[r])
    }
}, xo = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, zh = function i(e, t) {
    for (var n in t)
        n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Ji(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e
}, Gl = function(e, t) {
    var n = {}, r;
    for (r in e)
        r in t || (n[r] = e[r]);
    return n
}, ra = function(e) {
    var t = e.parent || Ft
      , n = e.keyframes ? Cv(Tn(e.keyframes)) : fi;
    if (Xn(e.inherit))
        for (; t; )
            n(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, Pv = function(e, t) {
    for (var n = e.length, r = n === t.length; r && n-- && e[n] === t[n]; )
        ;
    return n < 0
}, Jp = function(e, t, n, r, s) {
    var o = e[r], a;
    if (s)
        for (a = t[s]; o && o[s] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[n],
    e[n] = t),
    t._next ? t._next._prev = t : e[r] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, oc = function(e, t, n, r) {
    n === void 0 && (n = "_first"),
    r === void 0 && (r = "_last");
    var s = t._prev
      , o = t._next;
    s ? s._next = o : e[n] === t && (e[n] = o),
    o ? o._prev = s : e[r] === t && (e[r] = s),
    t._next = t._prev = t.parent = null
}, zr = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, Ss = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var n = e; n; )
            n._dirty = 1,
            n = n.parent;
    return e
}, Dv = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, Au = function(e, t, n, r) {
    return e._startAt && (gn ? e._startAt.revert(Ml) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r))
}, Lv = function i(e) {
    return !e || e._ts && i(e.parent)
}, kh = function(e) {
    return e._repeat ? yo(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, yo = function(e, t) {
    var n = Math.floor(e = Ot(e / t));
    return e && n === e ? n - 1 : n
}, Wl = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, ac = function(e) {
    return e._end = Ot(e._start + (e._tDur / Math.abs(e._ts || e._rts || At) || 0))
}, lc = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = Ot(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    ac(e),
    n._dirty || Ss(n, e)),
    e
}, Qp = function(e, t) {
    var n;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Wl(e.rawTime(), t),
    (!t._dur || La(0, t.totalDuration(), n) - t._tTime > At) && t.render(n, !0)),
    Ss(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        e._zTime = -At
    }
}, Wi = function(e, t, n, r) {
    return t.parent && zr(t),
    t._start = Ot((mr(n) ? n : n || e !== Ft ? _i(e, n, t) : e._time) + t._delay),
    t._end = Ot(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    Jp(e, t, "_first", "_last", e._sort ? "_start" : 0),
    Ru(t) || (e._recent = t),
    r || Qp(e, t),
    e._ts < 0 && lc(e, e._tTime),
    e
}, em = function(e, t) {
    return (ui.ScrollTrigger || Wf("scrollTrigger", t)) && ui.ScrollTrigger.create(t, e)
}, tm = function(e, t, n, r, s) {
    if (Kf(e, t, s),
    !e._initted)
        return 1;
    if (!n && e._pt && !gn && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && Yp !== ri.frame)
        return Nr.push(e),
        e._lazy = [s, r],
        1
}, Iv = function i(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t))
}, Ru = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, Uv = function(e, t, n, r) {
    var s = e.ratio, o = t < 0 || !t && (!e._start && Iv(e) && !(!e._initted && Ru(e)) || (e._ts < 0 || e._dp._ts < 0) && !Ru(e)) ? 0 : 1, a = e._rDelay, l = 0, c, u, f;
    if (a && e._repeat && (l = La(0, e._tDur, t),
    u = yo(l, a),
    e._yoyo && u & 1 && (o = 1 - o),
    u !== yo(e._tTime, a) && (s = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== s || gn || r || e._zTime === At || !t && e._zTime) {
        if (!e._initted && tm(e, t, r, n, l))
            return;
        for (f = e._zTime,
        e._zTime = t || (n ? At : 0),
        n || (n = t && !f),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = l,
        c = e._pt; c; )
            c.r(o, c.d),
            c = c._next;
        t < 0 && Au(e, t, n, !0),
        e._onUpdate && !n && oi(e, "onUpdate"),
        l && e._repeat && !n && e.parent && oi(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && zr(e, 1),
        !n && !gn && (oi(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, Nv = function(e, t, n) {
    var r;
    if (n > t)
        for (r = e._first; r && r._start <= n; ) {
            if (r.data === "isPause" && r._start > t)
                return r;
            r = r._next
        }
    else
        for (r = e._last; r && r._start >= n; ) {
            if (r.data === "isPause" && r._start < t)
                return r;
            r = r._prev
        }
}, So = function(e, t, n, r) {
    var s = e._repeat
      , o = Ot(t) || 0
      , a = e._tTime / e._tDur;
    return a && !r && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = s ? s < 0 ? 1e10 : Ot(o * (s + 1) + e._rDelay * s) : o,
    a > 0 && !r && lc(e, e._tTime = e._tDur * a),
    e.parent && ac(e),
    n || Ss(e.parent, e),
    e
}, Hh = function(e) {
    return e instanceof Un ? Ss(e) : So(e, e._dur)
}, Ov = {
    _start: 0,
    endTime: ya,
    totalDuration: ya
}, _i = function i(e, t, n) {
    var r = e.labels, s = e._recent || Ov, o = e.duration() >= Ti ? s.endTime(!1) : e._dur, a, l, c;
    return un(t) && (isNaN(t) || t in r) ? (l = t.charAt(0),
    c = t.substr(-1) === "%",
    a = t.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o),
    r[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    c && n && (l = l / 100 * (Tn(n) ? n[0] : n).totalDuration()),
    a > 1 ? i(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t
}, sa = function(e, t, n) {
    var r = mr(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, l;
    if (r && (o.duration = t[1]),
    o.parent = n,
    e) {
        for (a = o,
        l = n; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = Xn(l.vars.inherit) && l.parent;
        o.immediateRender = Xn(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
    }
    return new $t(t[0],o,t[s + 1])
}, qr = function(e, t) {
    return e || e === 0 ? t(e) : t
}, La = function(e, t, n) {
    return n < e ? e : n > t ? t : n
}, En = function(e, t) {
    return !un(e) || !(t = bv.exec(e)) ? "" : t[1]
}, Fv = function(e, t, n) {
    return qr(n, function(r) {
        return La(e, t, r)
    })
}, Cu = [].slice, nm = function(e, t) {
    return e && Ji(e) && "length"in e && (!t && !e.length || e.length - 1 in e && Ji(e[0])) && !e.nodeType && e !== ki
}, Bv = function(e, t, n) {
    return n === void 0 && (n = []),
    e.forEach(function(r) {
        var s;
        return un(r) && !t || nm(r, 1) ? (s = n).push.apply(s, bi(r)) : n.push(r)
    }) || n
}, bi = function(e, t, n) {
    return Ut && !t && Ut.selector ? Ut.selector(e) : un(e) && !n && (bu || !Eo()) ? Cu.call((t || Gf).querySelectorAll(e), 0) : Tn(e) ? Bv(e, n) : nm(e) ? Cu.call(e, 0) : e ? [e] : []
}, Pu = function(e) {
    return e = bi(e)[0] || xa("Invalid scope") || {},
    function(t) {
        var n = e.current || e.nativeElement || e;
        return bi(t, n.querySelectorAll ? n : n === e ? xa("Invalid scope") || Gf.createElement("div") : e)
    }
}, im = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, rm = function(e) {
    if (Ht(e))
        return e;
    var t = Ji(e) ? e : {
        each: e
    }
      , n = Es(t.ease)
      , r = t.from || 0
      , s = parseFloat(t.base) || 0
      , o = {}
      , a = r > 0 && r < 1
      , l = isNaN(r) || a
      , c = t.axis
      , u = r
      , f = r;
    return un(r) ? u = f = {
        center: .5,
        edges: .5,
        end: 1
    }[r] || 0 : !a && l && (u = r[0],
    f = r[1]),
    function(h, d, _) {
        var g = (_ || t).length, m = o[g], p, E, S, v, b, A, T, R, y;
        if (!m) {
            if (y = t.grid === "auto" ? 0 : (t.grid || [1, Ti])[1],
            !y) {
                for (T = -Ti; T < (T = _[y++].getBoundingClientRect().left) && y < g; )
                    ;
                y < g && y--
            }
            for (m = o[g] = [],
            p = l ? Math.min(y, g) * u - .5 : r % y,
            E = y === Ti ? 0 : l ? g * f / y - .5 : r / y | 0,
            T = 0,
            R = Ti,
            A = 0; A < g; A++)
                S = A % y - p,
                v = E - (A / y | 0),
                m[A] = b = c ? Math.abs(c === "y" ? v : S) : kp(S * S + v * v),
                b > T && (T = b),
                b < R && (R = b);
            r === "random" && im(m),
            m.max = T - R,
            m.min = R,
            m.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (y > g ? g - 1 : c ? c === "y" ? g / y : y : Math.max(y, g / y)) || 0) * (r === "edges" ? -1 : 1),
            m.b = g < 0 ? s - g : s,
            m.u = En(t.amount || t.each) || 0,
            n = n && g < 0 ? pm(n) : n
        }
        return g = (m[h] - m.min) / m.max || 0,
        Ot(m.b + (n ? n(g) : g) * m.v) + m.u
    }
}, Du = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
        var r = Ot(Math.round(parseFloat(n) / e) * e * t);
        return (r - r % 1) / t + (mr(n) ? 0 : En(n))
    }
}, sm = function(e, t) {
    var n = Tn(e), r, s;
    return !n && Ji(e) && (r = n = e.radius || Ti,
    e.values ? (e = bi(e.values),
    (s = !mr(e[0])) && (r *= r)) : e = Du(e.increment)),
    qr(t, n ? Ht(e) ? function(o) {
        return s = e(o),
        Math.abs(s - o) <= r ? s : o
    }
    : function(o) {
        for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = Ti, u = 0, f = e.length, h, d; f--; )
            s ? (h = e[f].x - a,
            d = e[f].y - l,
            h = h * h + d * d) : h = Math.abs(e[f] - a),
            h < c && (c = h,
            u = f);
        return u = !r || c <= r ? e[u] : o,
        s || u === o || mr(o) ? u : u + En(o)
    }
    : Du(e))
}, om = function(e, t, n, r) {
    return qr(Tn(e) ? !t : n === !0 ? !!(n = 0) : !r, function() {
        return Tn(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * r) / r
    })
}, zv = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return function(r) {
        return t.reduce(function(s, o) {
            return o(s)
        }, r)
    }
}, kv = function(e, t) {
    return function(n) {
        return e(parseFloat(n)) + (t || En(n))
    }
}, Hv = function(e, t, n) {
    return lm(e, t, 0, 1, n)
}, am = function(e, t, n) {
    return qr(n, function(r) {
        return e[~~t(r)]
    })
}, Vv = function i(e, t, n) {
    var r = t - e;
    return Tn(e) ? am(e, i(0, e.length), t) : qr(n, function(s) {
        return (r + (s - e) % r) % r + e
    })
}, Gv = function i(e, t, n) {
    var r = t - e
      , s = r * 2;
    return Tn(e) ? am(e, i(0, e.length - 1), t) : qr(n, function(o) {
        return o = (s + (o - e) % s) % s || 0,
        e + (o > r ? s - o : o)
    })
}, Sa = function(e) {
    return e.replace(Ev, function(t) {
        var n = t.indexOf("[") + 1
          , r = t.substring(n || 7, n ? t.indexOf("]") : t.length - 1).split(Mv);
        return om(n ? r : +r[0], n ? 0 : +r[1], +r[2] || 1e-5)
    })
}, lm = function(e, t, n, r, s) {
    var o = t - e
      , a = r - n;
    return qr(s, function(l) {
        return n + ((l - e) / o * a || 0)
    })
}, Wv = function i(e, t, n, r) {
    var s = isNaN(e + t) ? 0 : function(d) {
        return (1 - d) * e + d * t
    }
    ;
    if (!s) {
        var o = un(e), a = {}, l, c, u, f, h;
        if (n === !0 && (r = 1) && (n = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Tn(e) && !Tn(t)) {
            for (u = [],
            f = e.length,
            h = f - 2,
            c = 1; c < f; c++)
                u.push(i(e[c - 1], e[c]));
            f--,
            s = function(_) {
                _ *= f;
                var g = Math.min(h, ~~_);
                return u[g](_ - g)
            }
            ,
            n = t
        } else
            r || (e = xo(Tn(e) ? [] : {}, e));
        if (!u) {
            for (l in t)
                jf.call(a, e, l, "get", t[l]);
            s = function(_) {
                return Qf(_, a) || (o ? e.p : e)
            }
        }
    }
    return qr(n, s)
}, Vh = function(e, t, n) {
    var r = e.labels, s = Ti, o, a, l;
    for (o in r)
        a = r[o] - t,
        a < 0 == !!n && a && s > (a = Math.abs(a)) && (l = o,
        s = a);
    return l
}, oi = function(e, t, n) {
    var r = e.vars, s = r[t], o = Ut, a = e._ctx, l, c, u;
    if (s)
        return l = r[t + "Params"],
        c = r.callbackScope || e,
        n && Nr.length && Vl(),
        a && (Ut = a),
        u = l ? s.apply(c, l) : s.call(c),
        Ut = o,
        u
}, Yo = function(e) {
    return zr(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!gn),
    e.progress() < 1 && oi(e, "onInterrupt"),
    e
}, ro, cm = [], um = function(e) {
    if (e)
        if (e = !e.name && e.default || e,
        Vf() || e.headless) {
            var t = e.name
              , n = Ht(e)
              , r = t && !n && e.init ? function() {
                this._props = []
            }
            : e
              , s = {
                init: ya,
                render: Qf,
                add: jf,
                kill: o0,
                modifier: s0,
                rawVars: 0
            }
              , o = {
                targetTest: 0,
                get: 0,
                getSetter: Jf,
                aliases: {},
                register: 0
            };
            if (Eo(),
            e !== r) {
                if (ni[t])
                    return;
                fi(r, fi(Gl(e, s), o)),
                xo(r.prototype, xo(s, Gl(e, o))),
                ni[r.prop = t] = r,
                e.targetTest && (Tl.push(r),
                Xf[t] = 1),
                t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            qp(t, r),
            e.register && e.register(jn, r, Yn)
        } else
            cm.push(e)
}, wt = 255, $o = {
    aqua: [0, wt, wt],
    lime: [0, wt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, wt],
    navy: [0, 0, 128],
    white: [wt, wt, wt],
    olive: [128, 128, 0],
    yellow: [wt, wt, 0],
    orange: [wt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [wt, 0, 0],
    pink: [wt, 192, 203],
    cyan: [0, wt, wt],
    transparent: [wt, wt, wt, 0]
}, yc = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * wt + .5 | 0
}, fm = function(e, t, n) {
    var r = e ? mr(e) ? [e >> 16, e >> 8 & wt, e & wt] : 0 : $o.black, s, o, a, l, c, u, f, h, d, _;
    if (!r) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        $o[e])
            r = $o[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (s = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return r = parseInt(e.substr(1, 6), 16),
                [r >> 16, r >> 8 & wt, r & wt, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            r = [e >> 16, e >> 8 & wt, e & wt]
        } else if (e.substr(0, 3) === "hsl") {
            if (r = _ = e.match(Fh),
            !t)
                l = +r[0] % 360 / 360,
                c = +r[1] / 100,
                u = +r[2] / 100,
                o = u <= .5 ? u * (c + 1) : u + c - u * c,
                s = u * 2 - o,
                r.length > 3 && (r[3] *= 1),
                r[0] = yc(l + 1 / 3, s, o),
                r[1] = yc(l, s, o),
                r[2] = yc(l - 1 / 3, s, o);
            else if (~e.indexOf("="))
                return r = e.match(Vp),
                n && r.length < 4 && (r[3] = 1),
                r
        } else
            r = e.match(Fh) || $o.transparent;
        r = r.map(Number)
    }
    return t && !_ && (s = r[0] / wt,
    o = r[1] / wt,
    a = r[2] / wt,
    f = Math.max(s, o, a),
    h = Math.min(s, o, a),
    u = (f + h) / 2,
    f === h ? l = c = 0 : (d = f - h,
    c = u > .5 ? d / (2 - f - h) : d / (f + h),
    l = f === s ? (o - a) / d + (o < a ? 6 : 0) : f === o ? (a - s) / d + 2 : (s - o) / d + 4,
    l *= 60),
    r[0] = ~~(l + .5),
    r[1] = ~~(c * 100 + .5),
    r[2] = ~~(u * 100 + .5)),
    n && r.length < 4 && (r[3] = 1),
    r
}, hm = function(e) {
    var t = []
      , n = []
      , r = -1;
    return e.split(Or).forEach(function(s) {
        var o = s.match(io) || [];
        t.push.apply(t, o),
        n.push(r += o.length + 1)
    }),
    t.c = n,
    t
}, Gh = function(e, t, n) {
    var r = "", s = (e + r).match(Or), o = t ? "hsla(" : "rgba(", a = 0, l, c, u, f;
    if (!s)
        return e;
    if (s = s.map(function(h) {
        return (h = fm(h, t, 1)) && o + (t ? h[0] + "," + h[1] + "%," + h[2] + "%," + h[3] : h.join(",")) + ")"
    }),
    n && (u = hm(e),
    l = n.c,
    l.join(r) !== u.c.join(r)))
        for (c = e.replace(Or, "1").split(io),
        f = c.length - 1; a < f; a++)
            r += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (u.length ? u : s.length ? s : n).shift());
    if (!c)
        for (c = e.split(Or),
        f = c.length - 1; a < f; a++)
            r += c[a] + s[a];
    return r + c[f]
}, Or = (function() {
    var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in $o)
        i += "|" + e + "\\b";
    return new RegExp(i + ")","gi")
}
)(), Xv = /hsl[a]?\(/, dm = function(e) {
    var t = e.join(" "), n;
    if (Or.lastIndex = 0,
    Or.test(t))
        return n = Xv.test(t),
        e[1] = Gh(e[1], n),
        e[0] = Gh(e[0], n, hm(e[1])),
        !0
}, Ea, ri = (function() {
    var i = Date.now, e = 500, t = 33, n = i(), r = n, s = 1e3 / 240, o = s, a = [], l, c, u, f, h, d, _ = function g(m) {
        var p = i() - r, E = m === !0, S, v, b, A;
        if ((p > e || p < 0) && (n += p - t),
        r += p,
        b = r - n,
        S = b - o,
        (S > 0 || E) && (A = ++f.frame,
        h = b - f.time * 1e3,
        f.time = b = b / 1e3,
        o += S + (S >= s ? 4 : s - S),
        v = 1),
        E || (l = c(g)),
        v)
            for (d = 0; d < a.length; d++)
                a[d](b, h, A, m)
    };
    return f = {
        time: 0,
        frame: 0,
        tick: function() {
            _(!0)
        },
        deltaRatio: function(m) {
            return h / (1e3 / (m || 60))
        },
        wake: function() {
            Wp && (!bu && Vf() && (ki = bu = window,
            Gf = ki.document || {},
            ui.gsap = jn,
            (ki.gsapVersions || (ki.gsapVersions = [])).push(jn.version),
            Xp(Hl || ki.GreenSockGlobals || !ki.gsap && ki || {}),
            cm.forEach(um)),
            u = typeof requestAnimationFrame < "u" && requestAnimationFrame,
            l && f.sleep(),
            c = u || function(m) {
                return setTimeout(m, o - f.time * 1e3 + 1 | 0)
            }
            ,
            Ea = 1,
            _(2))
        },
        sleep: function() {
            (u ? cancelAnimationFrame : clearTimeout)(l),
            Ea = 0,
            c = ya
        },
        lagSmoothing: function(m, p) {
            e = m || 1 / 0,
            t = Math.min(p || 33, e)
        },
        fps: function(m) {
            s = 1e3 / (m || 240),
            o = f.time * 1e3 + s
        },
        add: function(m, p, E) {
            var S = p ? function(v, b, A, T) {
                m(v, b, A, T),
                f.remove(S)
            }
            : m;
            return f.remove(m),
            a[E ? "unshift" : "push"](S),
            Eo(),
            S
        },
        remove: function(m, p) {
            ~(p = a.indexOf(m)) && a.splice(p, 1) && d >= p && d--
        },
        _listeners: a
    },
    f
}
)(), Eo = function() {
    return !Ea && ri.wake()
}, ft = {}, qv = /^[\d.\-M][\d.\-,\s]/, Yv = /["']/g, $v = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), r = n[0], s = 1, o = n.length, a, l, c; s < o; s++)
        l = n[s],
        a = s !== o - 1 ? l.lastIndexOf(",") : l.length,
        c = l.substr(0, a),
        t[r] = isNaN(c) ? c.replace(Yv, "").trim() : +c,
        r = l.substr(a + 1).trim();
    return t
}, jv = function(e) {
    var t = e.indexOf("(") + 1
      , n = e.indexOf(")")
      , r = e.indexOf("(", t);
    return e.substring(t, ~r && r < n ? e.indexOf(")", n + 1) : n)
}, Kv = function(e) {
    var t = (e + "").split("(")
      , n = ft[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [$v(t[1])] : jv(e).split(",").map(Kp)) : ft._CE && qv.test(e) ? ft._CE("", e) : n
}, pm = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, mm = function i(e, t) {
    for (var n = e._first, r; n; )
        n instanceof Un ? i(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? i(n.timeline, t) : (r = n._ease,
        n._ease = n._yEase,
        n._yEase = r,
        n._yoyo = t)),
        n = n._next
}, Es = function(e, t) {
    return e && (Ht(e) ? e : ft[e] || Kv(e)) || t
}, Ls = function(e, t, n, r) {
    n === void 0 && (n = function(l) {
        return 1 - t(1 - l)
    }
    ),
    r === void 0 && (r = function(l) {
        return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
    }
    );
    var s = {
        easeIn: t,
        easeOut: n,
        easeInOut: r
    }, o;
    return qn(e, function(a) {
        ft[a] = ui[a] = s,
        ft[o = a.toLowerCase()] = n;
        for (var l in s)
            ft[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = ft[a + "." + l] = s[l]
    }),
    s
}, gm = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, Sc = function i(e, t, n) {
    var r = t >= 1 ? t : 1
      , s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = s / Tu * (Math.asin(1 / r) || 0)
      , a = function(u) {
        return u === 1 ? 1 : r * Math.pow(2, -10 * u) * Sv((u - o) * s) + 1
    }
      , l = e === "out" ? a : e === "in" ? function(c) {
        return 1 - a(1 - c)
    }
    : gm(a);
    return s = Tu / s,
    l.config = function(c, u) {
        return i(e, c, u)
    }
    ,
    l
}, Ec = function i(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , r = e === "out" ? n : e === "in" ? function(s) {
        return 1 - n(1 - s)
    }
    : gm(n);
    return r.config = function(s) {
        return i(e, s)
    }
    ,
    r
};
qn("Linear,Quad,Cubic,Quart,Quint,Strong", function(i, e) {
    var t = e < 5 ? e + 1 : e;
    Ls(i + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    }
    : function(n) {
        return n
    }
    , function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
ft.Linear.easeNone = ft.none = ft.Linear.easeIn;
Ls("Elastic", Sc("in"), Sc("out"), Sc());
(function(i, e) {
    var t = 1 / e
      , n = 2 * t
      , r = 2.5 * t
      , s = function(a) {
        return a < t ? i * a * a : a < n ? i * Math.pow(a - 1.5 / e, 2) + .75 : a < r ? i * (a -= 2.25 / e) * a + .9375 : i * Math.pow(a - 2.625 / e, 2) + .984375
    };
    Ls("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
}
)(7.5625, 2.75);
Ls("Expo", function(i) {
    return Math.pow(2, 10 * (i - 1)) * i + i * i * i * i * i * i * (1 - i)
});
Ls("Circ", function(i) {
    return -(kp(1 - i * i) - 1)
});
Ls("Sine", function(i) {
    return i === 1 ? 1 : -yv(i * vv) + 1
});
Ls("Back", Ec("in"), Ec("out"), Ec());
ft.SteppedEase = ft.steps = ui.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e
          , r = e + (t ? 0 : 1)
          , s = t ? 1 : 0
          , o = 1 - At;
        return function(a) {
            return ((r * La(0, o, a) | 0) + s) * n
        }
    }
};
vo.ease = ft["quad.out"];
qn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(i) {
    return qf += i + "," + i + "Params,"
});
var _m = function(e, t) {
    this.id = xv++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : $p,
    this.set = t ? t.getSetter : Jf
}
  , Ma = (function() {
    function i(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        So(this, +t.duration, 1, 1),
        this.data = t.data,
        Ut && (this._ctx = Ut,
        Ut.data.push(this)),
        Ea || ri.wake()
    }
    var e = i.prototype;
    return e.delay = function(n) {
        return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
        this._delay = n,
        this) : this._delay
    }
    ,
    e.duration = function(n) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(n) {
        return arguments.length ? (this._dirty = 0,
        So(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(n, r) {
        if (Eo(),
        !arguments.length)
            return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
            for (lc(this, n),
            !s._dp || s.parent || Qp(s, this); s && s.parent; )
                s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                s = s.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Wi(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== n || !this._dur && !r || this._initted && Math.abs(this._zTime) === At || !this._initted && this._dur && n || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n),
        jp(this, n, r)),
        this
    }
    ,
    e.time = function(n, r) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + kh(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), r) : this._time
    }
    ,
    e.totalProgress = function(n, r) {
        return arguments.length ? this.totalTime(this.totalDuration() * n, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
    }
    ,
    e.progress = function(n, r) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + kh(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(n, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (n - 1) * s, r) : this._repeat ? yo(this._tTime, s) + 1 : 1
    }
    ,
    e.timeScale = function(n, r) {
        if (!arguments.length)
            return this._rts === -At ? 0 : this._rts;
        if (this._rts === n)
            return this;
        var s = this.parent && this._ts ? Wl(this.parent._time, this) : this._tTime;
        return this._rts = +n || 0,
        this._ts = this._ps || n === -At ? 0 : this._rts,
        this.totalTime(La(-Math.abs(this._delay), this.totalDuration(), s), r !== !1),
        ac(this),
        Dv(this)
    }
    ,
    e.paused = function(n) {
        return arguments.length ? (this._ps !== n && (this._ps = n,
        n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (Eo(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== At && (this._tTime -= At)))),
        this) : this._ps
    }
    ,
    e.startTime = function(n) {
        if (arguments.length) {
            this._start = Ot(n);
            var r = this.parent || this._dp;
            return r && (r._sort || !this.parent) && Wi(r, this, this._start - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(n) {
        return this._start + (Xn(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(n) {
        var r = this.parent || this._dp;
        return r ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Wl(r.rawTime(n), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(n) {
        n === void 0 && (n = Av);
        var r = gn;
        return gn = n,
        $f(this) && (this.timeline && this.timeline.revert(n),
        this.totalTime(-.01, n.suppressEvents)),
        this.data !== "nested" && n.kill !== !1 && this.kill(),
        gn = r,
        this
    }
    ,
    e.globalTime = function(n) {
        for (var r = this, s = arguments.length ? n : r.rawTime(); r; )
            s = r._start + s / (Math.abs(r._ts) || 1),
            r = r._dp;
        return !this.parent && this._sat ? this._sat.globalTime(n) : s
    }
    ,
    e.repeat = function(n) {
        return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n,
        Hh(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(n) {
        if (arguments.length) {
            var r = this._time;
            return this._rDelay = n,
            Hh(this),
            r ? this.time(r) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(n) {
        return arguments.length ? (this._yoyo = n,
        this) : this._yoyo
    }
    ,
    e.seek = function(n, r) {
        return this.totalTime(_i(this, n), Xn(r))
    }
    ,
    e.restart = function(n, r) {
        return this.play().totalTime(n ? -this._delay : 0, Xn(r)),
        this._dur || (this._zTime = -At),
        this
    }
    ,
    e.play = function(n, r) {
        return n != null && this.seek(n, r),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(n, r) {
        return n != null && this.seek(n || this.totalDuration(), r),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(n, r) {
        return n != null && this.seek(n, r),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(n) {
        return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -At : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -At,
        this
    }
    ,
    e.isActive = function() {
        var n = this.parent || this._dp, r = this._start, s;
        return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= r && s < this.endTime(!0) - At)
    }
    ,
    e.eventCallback = function(n, r, s) {
        var o = this.vars;
        return arguments.length > 1 ? (r ? (o[n] = r,
        s && (o[n + "Params"] = s),
        n === "onUpdate" && (this._onUpdate = r)) : delete o[n],
        this) : o[n]
    }
    ,
    e.then = function(n) {
        var r = this
          , s = r._prom;
        return new Promise(function(o) {
            var a = Ht(n) ? n : Zp
              , l = function() {
                var u = r.then;
                r.then = null,
                s && s(),
                Ht(a) && (a = a(r)) && (a.then || a === r) && (r.then = u),
                o(a),
                r.then = u
            };
            r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? l() : r._prom = l
        }
        )
    }
    ,
    e.kill = function() {
        Yo(this)
    }
    ,
    i
}
)();
fi(Ma.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -At,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Un = (function(i) {
    zp(e, i);
    function e(n, r) {
        var s;
        return n === void 0 && (n = {}),
        s = i.call(this, n) || this,
        s.labels = {},
        s.smoothChildTiming = !!n.smoothChildTiming,
        s.autoRemoveChildren = !!n.autoRemoveChildren,
        s._sort = Xn(n.sortChildren),
        Ft && Wi(n.parent || Ft, sr(s), r),
        n.reversed && s.reverse(),
        n.paused && s.paused(!0),
        n.scrollTrigger && em(sr(s), n.scrollTrigger),
        s
    }
    var t = e.prototype;
    return t.to = function(r, s, o) {
        return sa(0, arguments, this),
        this
    }
    ,
    t.from = function(r, s, o) {
        return sa(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(r, s, o, a) {
        return sa(2, arguments, this),
        this
    }
    ,
    t.set = function(r, s, o) {
        return s.duration = 0,
        s.parent = this,
        ra(s).repeatDelay || (s.repeat = 0),
        s.immediateRender = !!s.immediateRender,
        new $t(r,s,_i(this, o),1),
        this
    }
    ,
    t.call = function(r, s, o) {
        return Wi(this, $t.delayedCall(0, r, s), o)
    }
    ,
    t.staggerTo = function(r, s, o, a, l, c, u) {
        return o.duration = s,
        o.stagger = o.stagger || a,
        o.onComplete = c,
        o.onCompleteParams = u,
        o.parent = this,
        new $t(r,o,_i(this, l)),
        this
    }
    ,
    t.staggerFrom = function(r, s, o, a, l, c, u) {
        return o.runBackwards = 1,
        ra(o).immediateRender = Xn(o.immediateRender),
        this.staggerTo(r, s, o, a, l, c, u)
    }
    ,
    t.staggerFromTo = function(r, s, o, a, l, c, u, f) {
        return a.startAt = o,
        ra(a).immediateRender = Xn(a.immediateRender),
        this.staggerTo(r, s, a, l, c, u, f)
    }
    ,
    t.render = function(r, s, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, u = r <= 0 ? 0 : Ot(r), f = this._zTime < 0 != r < 0 && (this._initted || !c), h, d, _, g, m, p, E, S, v, b, A, T;
        if (this !== Ft && u > l && r >= 0 && (u = l),
        u !== this._tTime || o || f) {
            if (a !== this._time && c && (u += this._time - a,
            r += this._time - a),
            h = u,
            v = this._start,
            S = this._ts,
            p = !S,
            f && (c || (a = this._zTime),
            (r || !s) && (this._zTime = r)),
            this._repeat) {
                if (A = this._yoyo,
                m = c + this._rDelay,
                this._repeat < -1 && r < 0)
                    return this.totalTime(m * 100 + r, s, o);
                if (h = Ot(u % m),
                u === l ? (g = this._repeat,
                h = c) : (b = Ot(u / m),
                g = ~~b,
                g && g === b && (h = c,
                g--),
                h > c && (h = c)),
                b = yo(this._tTime, m),
                !a && this._tTime && b !== g && this._tTime - b * m - this._dur <= 0 && (b = g),
                A && g & 1 && (h = c - h,
                T = 1),
                g !== b && !this._lock) {
                    var R = A && b & 1
                      , y = R === (A && g & 1);
                    if (g < b && (R = !R),
                    a = R ? 0 : u % c ? c : u,
                    this._lock = 1,
                    this.render(a || (T ? 0 : Ot(g * m)), s, !c)._lock = 0,
                    this._tTime = u,
                    !s && this.parent && oi(this, "onRepeat"),
                    this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1,
                    b = g),
                    a && a !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur,
                    l = this._tDur,
                    y && (this._lock = 2,
                    a = R ? c : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !T && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !p)
                        return this;
                    mm(this, T)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (E = Nv(this, Ot(a), Ot(h)),
            E && (u -= h - (h = E._start))),
            this._tTime = u,
            this._time = h,
            this._act = !S,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = r,
            a = 0),
            !a && u && c && !s && !b && (oi(this, "onStart"),
            this._tTime !== u))
                return this;
            if (h >= a && r >= 0)
                for (d = this._first; d; ) {
                    if (_ = d._next,
                    (d._act || h >= d._start) && d._ts && E !== d) {
                        if (d.parent !== this)
                            return this.render(r, s, o);
                        if (d.render(d._ts > 0 ? (h - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (h - d._start) * d._ts, s, o),
                        h !== this._time || !this._ts && !p) {
                            E = 0,
                            _ && (u += this._zTime = -At);
                            break
                        }
                    }
                    d = _
                }
            else {
                d = this._last;
                for (var x = r < 0 ? r : h; d; ) {
                    if (_ = d._prev,
                    (d._act || x <= d._end) && d._ts && E !== d) {
                        if (d.parent !== this)
                            return this.render(r, s, o);
                        if (d.render(d._ts > 0 ? (x - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (x - d._start) * d._ts, s, o || gn && $f(d)),
                        h !== this._time || !this._ts && !p) {
                            E = 0,
                            _ && (u += this._zTime = x ? -At : At);
                            break
                        }
                    }
                    d = _
                }
            }
            if (E && !s && (this.pause(),
            E.render(h >= a ? 0 : -At)._zTime = h >= a ? 1 : -1,
            this._ts))
                return this._start = v,
                ac(this),
                this.render(r, s, o);
            this._onUpdate && !s && oi(this, "onUpdate", !0),
            (u === l && this._tTime >= this.totalDuration() || !u && a) && (v === this._start || Math.abs(S) !== Math.abs(this._ts)) && (this._lock || ((r || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && zr(this, 1),
            !s && !(r < 0 && !a) && (u || a || !l) && (oi(this, u === l && r >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(r, s) {
        var o = this;
        if (mr(s) || (s = _i(this, s, r)),
        !(r instanceof Ma)) {
            if (Tn(r))
                return r.forEach(function(a) {
                    return o.add(a, s)
                }),
                this;
            if (un(r))
                return this.addLabel(r, s);
            if (Ht(r))
                r = $t.delayedCall(0, r);
            else
                return this
        }
        return this !== r ? Wi(this, r, s) : this
    }
    ,
    t.getChildren = function(r, s, o, a) {
        r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Ti);
        for (var l = [], c = this._first; c; )
            c._start >= a && (c instanceof $t ? s && l.push(c) : (o && l.push(c),
            r && l.push.apply(l, c.getChildren(!0, s, o)))),
            c = c._next;
        return l
    }
    ,
    t.getById = function(r) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
            if (s[o].vars.id === r)
                return s[o]
    }
    ,
    t.remove = function(r) {
        return un(r) ? this.removeLabel(r) : Ht(r) ? this.killTweensOf(r) : (r.parent === this && oc(this, r),
        r === this._recent && (this._recent = this._last),
        Ss(this))
    }
    ,
    t.totalTime = function(r, s) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = Ot(ri.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))),
        i.prototype.totalTime.call(this, r, s),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(r, s) {
        return this.labels[r] = _i(this, s),
        this
    }
    ,
    t.removeLabel = function(r) {
        return delete this.labels[r],
        this
    }
    ,
    t.addPause = function(r, s, o) {
        var a = $t.delayedCall(0, s || ya, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Wi(this, a, _i(this, r))
    }
    ,
    t.removePause = function(r) {
        var s = this._first;
        for (r = _i(this, r); s; )
            s._start === r && s.data === "isPause" && zr(s),
            s = s._next
    }
    ,
    t.killTweensOf = function(r, s, o) {
        for (var a = this.getTweensOf(r, o), l = a.length; l--; )
            Pr !== a[l] && a[l].kill(r, s);
        return this
    }
    ,
    t.getTweensOf = function(r, s) {
        for (var o = [], a = bi(r), l = this._first, c = mr(s), u; l; )
            l instanceof $t ? Rv(l._targets, a) && (c ? (!Pr || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, s)).length && o.push.apply(o, u),
            l = l._next;
        return o
    }
    ,
    t.tweenTo = function(r, s) {
        s = s || {};
        var o = this, a = _i(o, r), l = s, c = l.startAt, u = l.onStart, f = l.onStartParams, h = l.immediateRender, d, _ = $t.to(o, fi({
            ease: s.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: s.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale()) || At,
            onStart: function() {
                if (o.pause(),
                !d) {
                    var m = s.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale());
                    _._dur !== m && So(_, m, 0, 1).render(_._time, !0, !0),
                    d = 1
                }
                u && u.apply(_, f || [])
            }
        }, s));
        return h ? _.render(0) : _
    }
    ,
    t.tweenFromTo = function(r, s, o) {
        return this.tweenTo(s, fi({
            startAt: {
                time: _i(this, r)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(r) {
        return r === void 0 && (r = this._time),
        Vh(this, _i(this, r))
    }
    ,
    t.previousLabel = function(r) {
        return r === void 0 && (r = this._time),
        Vh(this, _i(this, r), 1)
    }
    ,
    t.currentLabel = function(r) {
        return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + At)
    }
    ,
    t.shiftChildren = function(r, s, o) {
        o === void 0 && (o = 0);
        var a = this._first, l = this.labels, c;
        for (r = Ot(r); a; )
            a._start >= o && (a._start += r,
            a._end += r),
            a = a._next;
        if (s)
            for (c in l)
                l[c] >= o && (l[c] += r);
        return Ss(this)
    }
    ,
    t.invalidate = function(r) {
        var s = this._first;
        for (this._lock = 0; s; )
            s.invalidate(r),
            s = s._next;
        return i.prototype.invalidate.call(this, r)
    }
    ,
    t.clear = function(r) {
        r === void 0 && (r = !0);
        for (var s = this._first, o; s; )
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        Ss(this)
    }
    ,
    t.totalDuration = function(r) {
        var s = 0, o = this, a = o._last, l = Ti, c, u, f;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
        if (o._dirty) {
            for (f = o.parent; a; )
                c = a._prev,
                a._dirty && a.totalDuration(),
                u = a._start,
                u > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Wi(o, a, u - a._delay, 1)._lock = 0) : l = u,
                u < 0 && a._ts && (s -= u,
                (!f && !o._dp || f && f.smoothChildTiming) && (o._start += Ot(u / o._ts),
                o._time -= u,
                o._tTime -= u),
                o.shiftChildren(-u, !1, -1 / 0),
                l = 0),
                a._end > s && a._ts && (s = a._end),
                a = c;
            So(o, o === Ft && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(r) {
        if (Ft._ts && (jp(Ft, Wl(r, Ft)),
        Yp = ri.frame),
        ri.frame >= Bh) {
            Bh += li.autoSleep || 120;
            var s = Ft._first;
            if ((!s || !s._ts) && li.autoSleep && ri._listeners.length < 2) {
                for (; s && !s._ts; )
                    s = s._next;
                s || ri.sleep()
            }
        }
    }
    ,
    e
}
)(Ma);
fi(Un.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var Zv = function(e, t, n, r, s, o, a) {
    var l = new Yn(this._pt,e,t,0,1,Mm,null,s), c = 0, u = 0, f, h, d, _, g, m, p, E;
    for (l.b = n,
    l.e = r,
    n += "",
    r += "",
    (p = ~r.indexOf("random(")) && (r = Sa(r)),
    o && (E = [n, r],
    o(E, e, t),
    n = E[0],
    r = E[1]),
    h = n.match(vc) || []; f = vc.exec(r); )
        _ = f[0],
        g = r.substring(c, f.index),
        d ? d = (d + 1) % 5 : g.substr(-5) === "rgba(" && (d = 1),
        _ !== h[u++] && (m = parseFloat(h[u - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: g || u === 1 ? g : ",",
            s: m,
            c: _.charAt(1) === "=" ? lo(m, _) - m : parseFloat(_) - m,
            m: d && d < 4 ? Math.round : 0
        },
        c = vc.lastIndex);
    return l.c = c < r.length ? r.substring(c, r.length) : "",
    l.fp = a,
    (Gp.test(r) || p) && (l.e = 0),
    this._pt = l,
    l
}, jf = function(e, t, n, r, s, o, a, l, c, u) {
    Ht(r) && (r = r(s || 0, e, o));
    var f = e[t], h = n !== "get" ? n : Ht(f) ? c ? e[t.indexOf("set") || !Ht(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : f, d = Ht(f) ? c ? n0 : Sm : Zf, _;
    if (un(r) && (~r.indexOf("random(") && (r = Sa(r)),
    r.charAt(1) === "=" && (_ = lo(h, r) + (En(h) || 0),
    (_ || _ === 0) && (r = _))),
    !u || h !== r || Lu)
        return !isNaN(h * r) && r !== "" ? (_ = new Yn(this._pt,e,t,+h || 0,r - (h || 0),typeof f == "boolean" ? r0 : Em,0,d),
        c && (_.fp = c),
        a && _.modifier(a, this, e),
        this._pt = _) : (!f && !(t in e) && Wf(t, r),
        Zv.call(this, e, t, h, r, d, l || li.stringFilter, c))
}, Jv = function(e, t, n, r, s) {
    if (Ht(e) && (e = oa(e, s, t, n, r)),
    !Ji(e) || e.style && e.nodeType || Tn(e) || Hp(e))
        return un(e) ? oa(e, s, t, n, r) : e;
    var o = {}, a;
    for (a in e)
        o[a] = oa(e[a], s, t, n, r);
    return o
}, vm = function(e, t, n, r, s, o) {
    var a, l, c, u;
    if (ni[e] && (a = new ni[e]).init(s, a.rawVars ? t[e] : Jv(t[e], r, s, o, n), n, r, o) !== !1 && (n._pt = l = new Yn(n._pt,s,e,0,1,a.render,a,0,a.priority),
    n !== ro))
        for (c = n._ptLookup[n._targets.indexOf(s)],
        u = a._props.length; u--; )
            c[a._props[u]] = l;
    return a
}, Pr, Lu, Kf = function i(e, t, n) {
    var r = e.vars, s = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, c = r.onUpdate, u = r.runBackwards, f = r.yoyoEase, h = r.keyframes, d = r.autoRevert, _ = e._dur, g = e._startAt, m = e._targets, p = e.parent, E = p && p.data === "nested" ? p.vars.targets : m, S = e._overwrite === "auto" && !kf, v = e.timeline, b, A, T, R, y, x, P, U, O, B, X, H, Y;
    if (v && (!h || !s) && (s = "none"),
    e._ease = Es(s, vo.ease),
    e._yEase = f ? pm(Es(f === !0 ? s : f, vo.ease)) : 0,
    f && e._yoyo && !e._repeat && (f = e._yEase,
    e._yEase = e._ease,
    e._ease = f),
    e._from = !v && !!r.runBackwards,
    !v || h && !r.stagger) {
        if (U = m[0] ? ys(m[0]).harness : 0,
        H = U && r[U.prop],
        b = Gl(r, Xf),
        g && (g._zTime < 0 && g.progress(1),
        t < 0 && u && a && !d ? g.render(-1, !0) : g.revert(u && _ ? Ml : wv),
        g._lazy = 0),
        o) {
            if (zr(e._startAt = $t.set(m, fi({
                data: "isStart",
                overwrite: !1,
                parent: p,
                immediateRender: !0,
                lazy: !g && Xn(l),
                startAt: null,
                delay: 0,
                onUpdate: c && function() {
                    return oi(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (gn || !a && !d) && e._startAt.revert(Ml),
            a && _ && t <= 0 && n <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (u && _ && !g) {
            if (t && (a = !1),
            T = fi({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !g && Xn(l),
                immediateRender: a,
                stagger: 0,
                parent: p
            }, b),
            H && (T[U.prop] = H),
            zr(e._startAt = $t.set(m, T)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (gn ? e._startAt.revert(Ml) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                i(e._startAt, At, At);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        l = _ && Xn(l) || l && !_,
        A = 0; A < m.length; A++) {
            if (y = m[A],
            P = y._gsap || Yf(m)[A]._gsap,
            e._ptLookup[A] = B = {},
            wu[P.id] && Nr.length && Vl(),
            X = E === m ? A : E.indexOf(y),
            U && (O = new U).init(y, H || b, e, X, E) !== !1 && (e._pt = R = new Yn(e._pt,y,O.name,0,1,O.render,O,0,O.priority),
            O._props.forEach(function(N) {
                B[N] = R
            }),
            O.priority && (x = 1)),
            !U || H)
                for (T in b)
                    ni[T] && (O = vm(T, b, e, X, y, E)) ? O.priority && (x = 1) : B[T] = R = jf.call(e, y, T, "get", b[T], X, E, 0, r.stringFilter);
            e._op && e._op[A] && e.kill(y, e._op[A]),
            S && e._pt && (Pr = e,
            Ft.killTweensOf(y, B, e.globalTime(t)),
            Y = !e.parent,
            Pr = 0),
            e._pt && l && (wu[P.id] = 1)
        }
        x && Tm(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = c,
    e._initted = (!e._op || e._pt) && !Y,
    h && t <= 0 && v.render(Ti, !0, !0)
}, Qv = function(e, t, n, r, s, o, a, l) {
    var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, f, h, d;
    if (!c)
        for (c = e._ptCache[t] = [],
        h = e._ptLookup,
        d = e._targets.length; d--; ) {
            if (u = h[d][t],
            u && u.d && u.d._pt)
                for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
                    u = u._next;
            if (!u)
                return Lu = 1,
                e.vars[t] = "+=0",
                Kf(e, a),
                Lu = 0,
                l ? xa(t + " not eligible for reset") : 1;
            c.push(u)
        }
    for (d = c.length; d--; )
        f = c[d],
        u = f._pt || f,
        u.s = (r || r === 0) && !s ? r : u.s + (r || 0) + o * u.c,
        u.c = n - u.s,
        f.e && (f.e = Gt(n) + En(f.e)),
        f.b && (f.b = u.s + En(f.b))
}, e0 = function(e, t) {
    var n = e[0] ? ys(e[0]).harness : 0, r = n && n.aliases, s, o, a, l;
    if (!r)
        return t;
    s = xo({}, t);
    for (o in r)
        if (o in s)
            for (l = r[o].split(","),
            a = l.length; a--; )
                s[l[a]] = s[o];
    return s
}, t0 = function(e, t, n, r) {
    var s = t.ease || r || "power1.inOut", o, a;
    if (Tn(t))
        a = n[e] || (n[e] = []),
        t.forEach(function(l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: s
            })
        });
    else
        for (o in t)
            a = n[o] || (n[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: s
            })
}, oa = function(e, t, n, r, s) {
    return Ht(e) ? e.call(t, n, r, s) : un(e) && ~e.indexOf("random(") ? Sa(e) : e
}, xm = qf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ym = {};
qn(xm + ",id,stagger,delay,duration,paused,scrollTrigger", function(i) {
    return ym[i] = 1
});
var $t = (function(i) {
    zp(e, i);
    function e(n, r, s, o) {
        var a;
        typeof r == "number" && (s.duration = r,
        r = s,
        s = null),
        a = i.call(this, o ? r : ra(r)) || this;
        var l = a.vars, c = l.duration, u = l.delay, f = l.immediateRender, h = l.stagger, d = l.overwrite, _ = l.keyframes, g = l.defaults, m = l.scrollTrigger, p = l.yoyoEase, E = r.parent || Ft, S = (Tn(n) || Hp(n) ? mr(n[0]) : "length"in r) ? [n] : bi(n), v, b, A, T, R, y, x, P;
        if (a._targets = S.length ? Yf(S) : xa("GSAP target " + n + " not found. https://gsap.com", !li.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = d,
        _ || h || Ha(c) || Ha(u)) {
            if (r = a.vars,
            v = a.timeline = new Un({
                data: "nested",
                defaults: g || {},
                targets: E && E.data === "nested" ? E.vars.targets : S
            }),
            v.kill(),
            v.parent = v._dp = sr(a),
            v._start = 0,
            h || Ha(c) || Ha(u)) {
                if (T = S.length,
                x = h && rm(h),
                Ji(h))
                    for (R in h)
                        ~xm.indexOf(R) && (P || (P = {}),
                        P[R] = h[R]);
                for (b = 0; b < T; b++)
                    A = Gl(r, ym),
                    A.stagger = 0,
                    p && (A.yoyoEase = p),
                    P && xo(A, P),
                    y = S[b],
                    A.duration = +oa(c, sr(a), b, y, S),
                    A.delay = (+oa(u, sr(a), b, y, S) || 0) - a._delay,
                    !h && T === 1 && A.delay && (a._delay = u = A.delay,
                    a._start += u,
                    A.delay = 0),
                    v.to(y, A, x ? x(b, y, S) : 0),
                    v._ease = ft.none;
                v.duration() ? c = u = 0 : a.timeline = 0
            } else if (_) {
                ra(fi(v.vars.defaults, {
                    ease: "none"
                })),
                v._ease = Es(_.ease || r.ease || "none");
                var U = 0, O, B, X;
                if (Tn(_))
                    _.forEach(function(H) {
                        return v.to(S, H, ">")
                    }),
                    v.duration();
                else {
                    A = {};
                    for (R in _)
                        R === "ease" || R === "easeEach" || t0(R, _[R], A, _.easeEach);
                    for (R in A)
                        for (O = A[R].sort(function(H, Y) {
                            return H.t - Y.t
                        }),
                        U = 0,
                        b = 0; b < O.length; b++)
                            B = O[b],
                            X = {
                                ease: B.e,
                                duration: (B.t - (b ? O[b - 1].t : 0)) / 100 * c
                            },
                            X[R] = B.v,
                            v.to(S, X, U),
                            U += X.duration;
                    v.duration() < c && v.to({}, {
                        duration: c - v.duration()
                    })
                }
            }
            c || a.duration(c = v.duration())
        } else
            a.timeline = 0;
        return d === !0 && !kf && (Pr = sr(a),
        Ft.killTweensOf(S),
        Pr = 0),
        Wi(E, sr(a), s),
        r.reversed && a.reverse(),
        r.paused && a.paused(!0),
        (f || !c && !_ && a._start === Ot(E._time) && Xn(f) && Lv(sr(a)) && E.data !== "nested") && (a._tTime = -At,
        a.render(Math.max(0, -u) || 0)),
        m && em(sr(a), m),
        a
    }
    var t = e.prototype;
    return t.render = function(r, s, o) {
        var a = this._time, l = this._tDur, c = this._dur, u = r < 0, f = r > l - At && !u ? l : r < At ? 0 : r, h, d, _, g, m, p, E, S, v;
        if (!c)
            Uv(this, r, s, o);
        else if (f !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u || this._lazy) {
            if (h = f,
            S = this.timeline,
            this._repeat) {
                if (g = c + this._rDelay,
                this._repeat < -1 && u)
                    return this.totalTime(g * 100 + r, s, o);
                if (h = Ot(f % g),
                f === l ? (_ = this._repeat,
                h = c) : (m = Ot(f / g),
                _ = ~~m,
                _ && _ === m ? (h = c,
                _--) : h > c && (h = c)),
                p = this._yoyo && _ & 1,
                p && (v = this._yEase,
                h = c - h),
                m = yo(this._tTime, g),
                h === a && !o && this._initted && _ === m)
                    return this._tTime = f,
                    this;
                _ !== m && (S && this._yEase && mm(S, p),
                this.vars.repeatRefresh && !p && !this._lock && h !== g && this._initted && (this._lock = o = 1,
                this.render(Ot(g * _), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (tm(this, u ? r : h, o, s, f))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && _ !== m))
                    return this;
                if (c !== this._dur)
                    return this.render(r, s, o)
            }
            if (this._tTime = f,
            this._time = h,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = E = (v || this._ease)(h / c),
            this._from && (this.ratio = E = 1 - E),
            !a && f && !s && !m && (oi(this, "onStart"),
            this._tTime !== f))
                return this;
            for (d = this._pt; d; )
                d.r(E, d.d),
                d = d._next;
            S && S.render(r < 0 ? r : S._dur * S._ease(h / this._dur), s, o) || this._startAt && (this._zTime = r),
            this._onUpdate && !s && (u && Au(this, r, s, o),
            oi(this, "onUpdate")),
            this._repeat && _ !== m && this.vars.onRepeat && !s && this.parent && oi(this, "onRepeat"),
            (f === this._tDur || !f) && this._tTime === f && (u && !this._onUpdate && Au(this, r, !0, !0),
            (r || !c) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && zr(this, 1),
            !s && !(u && !a) && (f || a || p) && (oi(this, f === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(f < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(r) {
        return (!r || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(r),
        i.prototype.invalidate.call(this, r)
    }
    ,
    t.resetTo = function(r, s, o, a, l) {
        Ea || ri.wake(),
        this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
        return this._initted || Kf(this, c),
        u = this._ease(c / this._dur),
        Qv(this, r, s, o, a, u, c, l) ? this.resetTo(r, s, o, a, 1) : (lc(this, 0),
        this.parent || Jp(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(r, s) {
        if (s === void 0 && (s = "all"),
        !r && (!s || s === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? Yo(this) : this.scrollTrigger && this.scrollTrigger.kill(!!gn),
            this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(r, s, Pr && Pr.vars.overwrite !== !0)._first || Yo(this),
            this.parent && o !== this.timeline.totalDuration() && So(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = r ? bi(r) : a, c = this._ptLookup, u = this._pt, f, h, d, _, g, m, p;
        if ((!s || s === "all") && Pv(a, l))
            return s === "all" && (this._pt = 0),
            Yo(this);
        for (f = this._op = this._op || [],
        s !== "all" && (un(s) && (g = {},
        qn(s, function(E) {
            return g[E] = 1
        }),
        s = g),
        s = e0(a, s)),
        p = a.length; p--; )
            if (~l.indexOf(a[p])) {
                h = c[p],
                s === "all" ? (f[p] = s,
                _ = h,
                d = {}) : (d = f[p] = f[p] || {},
                _ = s);
                for (g in _)
                    m = h && h[g],
                    m && ((!("kill"in m.d) || m.d.kill(g) === !0) && oc(this, m, "_pt"),
                    delete h[g]),
                    d !== "all" && (d[g] = 1)
            }
        return this._initted && !this._pt && u && Yo(this),
        this
    }
    ,
    e.to = function(r, s) {
        return new e(r,s,arguments[2])
    }
    ,
    e.from = function(r, s) {
        return sa(1, arguments)
    }
    ,
    e.delayedCall = function(r, s, o, a) {
        return new e(s,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: r,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(r, s, o) {
        return sa(2, arguments)
    }
    ,
    e.set = function(r, s) {
        return s.duration = 0,
        s.repeatDelay || (s.repeat = 0),
        new e(r,s)
    }
    ,
    e.killTweensOf = function(r, s, o) {
        return Ft.killTweensOf(r, s, o)
    }
    ,
    e
}
)(Ma);
fi($t.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
qn("staggerTo,staggerFrom,staggerFromTo", function(i) {
    $t[i] = function() {
        var e = new Un
          , t = Cu.call(arguments, 0);
        return t.splice(i === "staggerFromTo" ? 5 : 4, 0, 0),
        e[i].apply(e, t)
    }
});
var Zf = function(e, t, n) {
    return e[t] = n
}
  , Sm = function(e, t, n) {
    return e[t](n)
}
  , n0 = function(e, t, n, r) {
    return e[t](r.fp, n)
}
  , i0 = function(e, t, n) {
    return e.setAttribute(t, n)
}
  , Jf = function(e, t) {
    return Ht(e[t]) ? Sm : Hf(e[t]) && e.setAttribute ? i0 : Zf
}
  , Em = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , r0 = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , Mm = function(e, t) {
    var n = t._pt
      , r = "";
    if (!e && t.b)
        r = t.b;
    else if (e === 1 && t.e)
        r = t.e;
    else {
        for (; n; )
            r = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + r,
            n = n._next;
        r += t.c
    }
    t.set(t.t, t.p, r, t)
}
  , Qf = function(e, t) {
    for (var n = t._pt; n; )
        n.r(e, n.d),
        n = n._next
}
  , s0 = function(e, t, n, r) {
    for (var s = this._pt, o; s; )
        o = s._next,
        s.p === r && s.modifier(e, t, n),
        s = o
}
  , o0 = function(e) {
    for (var t = this._pt, n, r; t; )
        r = t._next,
        t.p === e && !t.op || t.op === e ? oc(this, t, "_pt") : t.dep || (n = 1),
        t = r;
    return !n
}
  , a0 = function(e, t, n, r) {
    r.mSet(e, t, r.m.call(r.tween, n, r.mt), r)
}
  , Tm = function(e) {
    for (var t = e._pt, n, r, s, o; t; ) {
        for (n = t._next,
        r = s; r && r.pr > t.pr; )
            r = r._next;
        (t._prev = r ? r._prev : o) ? t._prev._next = t : s = t,
        (t._next = r) ? r._prev = t : o = t,
        t = n
    }
    e._pt = s
}
  , Yn = (function() {
    function i(t, n, r, s, o, a, l, c, u) {
        this.t = n,
        this.s = s,
        this.c = o,
        this.p = r,
        this.r = a || Em,
        this.d = l || this,
        this.set = c || Zf,
        this.pr = u || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = i.prototype;
    return e.modifier = function(n, r, s) {
        this.mSet = this.mSet || this.set,
        this.set = a0,
        this.m = n,
        this.mt = s,
        this.tween = r
    }
    ,
    i
}
)();
qn(qf + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(i) {
    return Xf[i] = 1
});
ui.TweenMax = ui.TweenLite = $t;
ui.TimelineLite = ui.TimelineMax = Un;
Ft = new Un({
    sortChildren: !1,
    defaults: vo,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
li.stringFilter = dm;
var Ms = []
  , bl = {}
  , l0 = []
  , Wh = 0
  , c0 = 0
  , Mc = function(e) {
    return (bl[e] || l0).map(function(t) {
        return t()
    })
}
  , Iu = function() {
    var e = Date.now()
      , t = [];
    e - Wh > 2 && (Mc("matchMediaInit"),
    Ms.forEach(function(n) {
        var r = n.queries, s = n.conditions, o, a, l, c;
        for (a in r)
            o = ki.matchMedia(r[a]).matches,
            o && (l = 1),
            o !== s[a] && (s[a] = o,
            c = 1);
        c && (n.revert(),
        l && t.push(n))
    }),
    Mc("matchMediaRevert"),
    t.forEach(function(n) {
        return n.onMatch(n, function(r) {
            return n.add(null, r)
        })
    }),
    Wh = e,
    Mc("matchMedia"))
}
  , bm = (function() {
    function i(t, n) {
        this.selector = n && Pu(n),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = c0++,
        t && this.add(t)
    }
    var e = i.prototype;
    return e.add = function(n, r, s) {
        Ht(n) && (s = r,
        r = n,
        n = Ht);
        var o = this
          , a = function() {
            var c = Ut, u = o.selector, f;
            return c && c !== o && c.data.push(o),
            s && (o.selector = Pu(s)),
            Ut = o,
            f = r.apply(o, arguments),
            Ht(f) && o._r.push(f),
            Ut = c,
            o.selector = u,
            o.isReverted = !1,
            f
        };
        return o.last = a,
        n === Ht ? a(o, function(l) {
            return o.add(null, l)
        }) : n ? o[n] = a : a
    }
    ,
    e.ignore = function(n) {
        var r = Ut;
        Ut = null,
        n(this),
        Ut = r
    }
    ,
    e.getTweens = function() {
        var n = [];
        return this.data.forEach(function(r) {
            return r instanceof i ? n.push.apply(n, r.getTweens()) : r instanceof $t && !(r.parent && r.parent.data === "nested") && n.push(r)
        }),
        n
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(n, r) {
        var s = this;
        if (n ? (function() {
            for (var a = s.getTweens(), l = s.data.length, c; l--; )
                c = s.data[l],
                c.data === "isFlip" && (c.revert(),
                c.getChildren(!0, !0, !1).forEach(function(u) {
                    return a.splice(a.indexOf(u), 1)
                }));
            for (a.map(function(u) {
                return {
                    g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
                    t: u
                }
            }).sort(function(u, f) {
                return f.g - u.g || -1 / 0
            }).forEach(function(u) {
                return u.t.revert(n)
            }),
            l = s.data.length; l--; )
                c = s.data[l],
                c instanceof Un ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(),
                c.kill()) : !(c instanceof $t) && c.revert && c.revert(n);
            s._r.forEach(function(u) {
                return u(n, s)
            }),
            s.isReverted = !0
        }
        )() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        r)
            for (var o = Ms.length; o--; )
                Ms[o].id === this.id && Ms.splice(o, 1)
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    i
}
)()
  , u0 = (function() {
    function i(t) {
        this.contexts = [],
        this.scope = t,
        Ut && Ut.data.push(this)
    }
    var e = i.prototype;
    return e.add = function(n, r, s) {
        Ji(n) || (n = {
            matches: n
        });
        var o = new bm(0,s || this.scope), a = o.conditions = {}, l, c, u;
        Ut && !o.selector && (o.selector = Ut.selector),
        this.contexts.push(o),
        r = o.add("onMatch", r),
        o.queries = n;
        for (c in n)
            c === "all" ? u = 1 : (l = ki.matchMedia(n[c]),
            l && (Ms.indexOf(o) < 0 && Ms.push(o),
            (a[c] = l.matches) && (u = 1),
            l.addListener ? l.addListener(Iu) : l.addEventListener("change", Iu)));
        return u && r(o, function(f) {
            return o.add(null, f)
        }),
        this
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    e.kill = function(n) {
        this.contexts.forEach(function(r) {
            return r.kill(n, !0)
        })
    }
    ,
    i
}
)()
  , Xl = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        t.forEach(function(r) {
            return um(r)
        })
    },
    timeline: function(e) {
        return new Un(e)
    },
    getTweensOf: function(e, t) {
        return Ft.getTweensOf(e, t)
    },
    getProperty: function(e, t, n, r) {
        un(e) && (e = bi(e)[0]);
        var s = ys(e || {}).get
          , o = n ? Zp : Kp;
        return n === "native" && (n = ""),
        e && (t ? o((ni[t] && ni[t].get || s)(e, t, n, r)) : function(a, l, c) {
            return o((ni[a] && ni[a].get || s)(e, a, l, c))
        }
        )
    },
    quickSetter: function(e, t, n) {
        if (e = bi(e),
        e.length > 1) {
            var r = e.map(function(u) {
                return jn.quickSetter(u, t, n)
            })
              , s = r.length;
            return function(u) {
                for (var f = s; f--; )
                    r[f](u)
            }
        }
        e = e[0] || {};
        var o = ni[t]
          , a = ys(e)
          , l = a.harness && (a.harness.aliases || {})[t] || t
          , c = o ? function(u) {
            var f = new o;
            ro._pt = 0,
            f.init(e, n ? u + n : u, ro, 0, [e]),
            f.render(1, f),
            ro._pt && Qf(1, ro)
        }
        : a.set(e, l);
        return o ? c : function(u) {
            return c(e, l, n ? u + n : u, a, 1)
        }
    },
    quickTo: function(e, t, n) {
        var r, s = jn.to(e, fi((r = {},
        r[t] = "+=0.1",
        r.paused = !0,
        r.stagger = 0,
        r), n || {})), o = function(l, c, u) {
            return s.resetTo(t, l, c, u)
        };
        return o.tween = s,
        o
    },
    isTweening: function(e) {
        return Ft.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = Es(e.ease, vo.ease)),
        zh(vo, e || {})
    },
    config: function(e) {
        return zh(li, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , n = e.effect
          , r = e.plugins
          , s = e.defaults
          , o = e.extendTimeline;
        (r || "").split(",").forEach(function(a) {
            return a && !ni[a] && !ui[a] && xa(t + " effect requires " + a + " plugin.")
        }),
        xc[t] = function(a, l, c) {
            return n(bi(a), fi(l || {}, s), c)
        }
        ,
        o && (Un.prototype[t] = function(a, l, c) {
            return this.add(xc[t](a, Ji(l) ? l : (c = l) && {}, this), c)
        }
        )
    },
    registerEase: function(e, t) {
        ft[e] = Es(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? Es(e, t) : ft
    },
    getById: function(e) {
        return Ft.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var n = new Un(e), r, s;
        for (n.smoothChildTiming = Xn(e.smoothChildTiming),
        Ft.remove(n),
        n._dp = 0,
        n._time = n._tTime = Ft._time,
        r = Ft._first; r; )
            s = r._next,
            (t || !(!r._dur && r instanceof $t && r.vars.onComplete === r._targets[0])) && Wi(n, r, r._start - r._delay),
            r = s;
        return Wi(Ft, n, 0),
        n
    },
    context: function(e, t) {
        return e ? new bm(e,t) : Ut
    },
    matchMedia: function(e) {
        return new u0(e)
    },
    matchMediaRefresh: function() {
        return Ms.forEach(function(e) {
            var t = e.conditions, n, r;
            for (r in t)
                t[r] && (t[r] = !1,
                n = 1);
            n && e.revert()
        }) || Iu()
    },
    addEventListener: function(e, t) {
        var n = bl[e] || (bl[e] = []);
        ~n.indexOf(t) || n.push(t)
    },
    removeEventListener: function(e, t) {
        var n = bl[e]
          , r = n && n.indexOf(t);
        r >= 0 && n.splice(r, 1)
    },
    utils: {
        wrap: Vv,
        wrapYoyo: Gv,
        distribute: rm,
        random: om,
        snap: sm,
        normalize: Hv,
        getUnit: En,
        clamp: Fv,
        splitColor: fm,
        toArray: bi,
        selector: Pu,
        mapRange: lm,
        pipe: zv,
        unitize: kv,
        interpolate: Wv,
        shuffle: im
    },
    install: Xp,
    effects: xc,
    ticker: ri,
    updateRoot: Un.updateRoot,
    plugins: ni,
    globalTimeline: Ft,
    core: {
        PropTween: Yn,
        globals: qp,
        Tween: $t,
        Timeline: Un,
        Animation: Ma,
        getCache: ys,
        _removeLinkedListItem: oc,
        reverting: function() {
            return gn
        },
        context: function(e) {
            return e && Ut && (Ut.data.push(e),
            e._ctx = Ut),
            Ut
        },
        suppressOverwrites: function(e) {
            return kf = e
        }
    }
};
qn("to,from,fromTo,delayedCall,set,killTweensOf", function(i) {
    return Xl[i] = $t[i]
});
ri.add(Un.updateRoot);
ro = Xl.to({}, {
    duration: 0
});
var f0 = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
        n = n._next;
    return n
}
  , h0 = function(e, t) {
    var n = e._targets, r, s, o;
    for (r in t)
        for (s = n.length; s--; )
            o = e._ptLookup[s][r],
            o && (o = o.d) && (o._pt && (o = f0(o, r)),
            o && o.modifier && o.modifier(t[r], e, n[s], r))
}
  , Tc = function(e, t) {
    return {
        name: e,
        headless: 1,
        rawVars: 1,
        init: function(r, s, o) {
            o._onInit = function(a) {
                var l, c;
                if (un(s) && (l = {},
                qn(s, function(u) {
                    return l[u] = 1
                }),
                s = l),
                t) {
                    l = {};
                    for (c in s)
                        l[c] = t(s[c]);
                    s = l
                }
                h0(a, s)
            }
        }
    }
}
  , jn = Xl.registerPlugin({
    name: "attr",
    init: function(e, t, n, r, s) {
        var o, a, l;
        this.tween = n;
        for (o in t)
            l = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (l || 0) + "", t[o], r, s, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var n = t._pt; n; )
            gn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    headless: 1,
    init: function(e, t) {
        for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
    }
}, Tc("roundProps", Du), Tc("modifiers"), Tc("snap", sm)) || Xl;
$t.version = Un.version = jn.version = "3.14.2";
Wp = 1;
Vf() && Eo();
ft.Power0;
ft.Power1;
ft.Power2;
ft.Power3;
ft.Power4;
ft.Linear;
ft.Quad;
ft.Cubic;
ft.Quart;
ft.Quint;
ft.Strong;
ft.Elastic;
ft.Back;
ft.SteppedEase;
ft.Bounce;
ft.Sine;
ft.Expo;
ft.Circ;
/*!
 * CSSPlugin 3.14.2
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var Xh, Dr, co, eh, ps, qh, th, d0 = function() {
    return typeof window < "u"
}, gr = {}, ss = 180 / Math.PI, uo = Math.PI / 180, Ns = Math.atan2, Yh = 1e8, nh = /([A-Z])/g, p0 = /(left|right|width|margin|padding|x)/i, m0 = /[\s,\(]\S/, Yi = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, Uu = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, g0 = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, _0 = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, v0 = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, x0 = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
}, wm = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, Am = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, y0 = function(e, t, n) {
    return e.style[t] = n
}, S0 = function(e, t, n) {
    return e.style.setProperty(t, n)
}, E0 = function(e, t, n) {
    return e._gsap[t] = n
}, M0 = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n
}, T0 = function(e, t, n, r, s) {
    var o = e._gsap;
    o.scaleX = o.scaleY = n,
    o.renderTransform(s, o)
}, b0 = function(e, t, n, r, s) {
    var o = e._gsap;
    o[t] = n,
    o.renderTransform(s, o)
}, Bt = "transform", $n = Bt + "Origin", w0 = function i(e, t) {
    var n = this
      , r = this.target
      , s = r.style
      , o = r._gsap;
    if (e in gr && s) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Yi[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return n.tfm[a] = ar(r, a)
            }) : this.tfm[e] = o.x ? o[e] : ar(r, e),
            e === $n && (this.tfm.zOrigin = o.zOrigin);
        else
            return Yi.transform.split(",").forEach(function(a) {
                return i.call(n, a, t)
            });
        if (this.props.indexOf(Bt) >= 0)
            return;
        o.svg && (this.svgo = r.getAttribute("data-svg-origin"),
        this.props.push($n, t, "")),
        e = Bt
    }
    (s || t) && this.props.push(e, t, s[e])
}, Rm = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, A0 = function() {
    var e = this.props, t = this.target, n = t.style, r = t._gsap, s, o;
    for (s = 0; s < e.length; s += 3)
        e[s + 1] ? e[s + 1] === 2 ? t[e[s]](e[s + 2]) : t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(nh, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            r[o] = this.tfm[o];
        r.svg && (r.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        s = th(),
        (!s || !s.isStart) && !n[Bt] && (Rm(n),
        r.zOrigin && n[$n] && (n[$n] += " " + r.zOrigin + "px",
        r.zOrigin = 0,
        r.renderTransform()),
        r.uncache = 1)
    }
}, Cm = function(e, t) {
    var n = {
        target: e,
        props: [],
        revert: A0,
        save: w0
    };
    return e._gsap || jn.core.getCache(e),
    t && e.style && e.nodeType && t.split(",").forEach(function(r) {
        return n.save(r)
    }),
    n
}, Pm, Nu = function(e, t) {
    var n = Dr.createElementNS ? Dr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Dr.createElement(e);
    return n && n.style ? n : Dr.createElement(e)
}, ai = function i(e, t, n) {
    var r = getComputedStyle(e);
    return r[t] || r.getPropertyValue(t.replace(nh, "-$1").toLowerCase()) || r.getPropertyValue(t) || !n && i(e, Mo(t) || t, 1) || ""
}, $h = "O,Moz,ms,Ms,Webkit".split(","), Mo = function(e, t, n) {
    var r = t || ps
      , s = r.style
      , o = 5;
    if (e in s && !n)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !($h[o] + e in s); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? $h[o] : "") + e
}, Ou = function() {
    d0() && window.document && (Xh = window,
    Dr = Xh.document,
    co = Dr.documentElement,
    ps = Nu("div") || {
        style: {}
    },
    Nu("div"),
    Bt = Mo(Bt),
    $n = Bt + "Origin",
    ps.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    Pm = !!Mo("perspective"),
    th = jn.core.reverting,
    eh = 1)
}, jh = function(e) {
    var t = e.ownerSVGElement, n = Nu("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = e.cloneNode(!0), s;
    r.style.display = "block",
    n.appendChild(r),
    co.appendChild(n);
    try {
        s = r.getBBox()
    } catch (o) {}
    return n.removeChild(r),
    co.removeChild(n),
    s
}, Kh = function(e, t) {
    for (var n = t.length; n--; )
        if (e.hasAttribute(t[n]))
            return e.getAttribute(t[n])
}, Dm = function(e) {
    var t, n;
    try {
        t = e.getBBox()
    } catch (r) {
        t = jh(e),
        n = 1
    }
    return t && (t.width || t.height) || n || (t = jh(e)),
    t && !t.width && !t.x && !t.y ? {
        x: +Kh(e, ["x", "cx", "x1"]) || 0,
        y: +Kh(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, Lm = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Dm(e))
}, kr = function(e, t) {
    if (t) {
        var n = e.style, r;
        t in gr && t !== $n && (t = Bt),
        n.removeProperty ? (r = t.substr(0, 2),
        (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        n.removeProperty(r === "--" ? t : t.replace(nh, "-$1").toLowerCase())) : n.removeAttribute(t)
    }
}, Lr = function(e, t, n, r, s, o) {
    var a = new Yn(e._pt,t,n,0,1,o ? Am : wm);
    return e._pt = a,
    a.b = r,
    a.e = s,
    e._props.push(n),
    a
}, Zh = {
    deg: 1,
    rad: 1,
    turn: 1
}, R0 = {
    grid: 1,
    flex: 1
}, Hr = function i(e, t, n, r) {
    var s = parseFloat(n) || 0, o = (n + "").trim().substr((s + "").length) || "px", a = ps.style, l = p0.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), f = 100, h = r === "px", d = r === "%", _, g, m, p;
    if (r === o || !s || Zh[r] || Zh[o])
        return s;
    if (o !== "px" && !h && (s = i(e, t, n, "px")),
    p = e.getCTM && Lm(e),
    (d || o === "%") && (gr[t] || ~t.indexOf("adius")))
        return _ = p ? e.getBBox()[l ? "width" : "height"] : e[u],
        Gt(d ? s / _ * f : s / 100 * _);
    if (a[l ? "width" : "height"] = f + (h ? o : r),
    g = r !== "rem" && ~t.indexOf("adius") || r === "em" && e.appendChild && !c ? e : e.parentNode,
    p && (g = (e.ownerSVGElement || {}).parentNode),
    (!g || g === Dr || !g.appendChild) && (g = Dr.body),
    m = g._gsap,
    m && d && m.width && l && m.time === ri.time && !m.uncache)
        return Gt(s / m.width * f);
    if (d && (t === "height" || t === "width")) {
        var E = e.style[t];
        e.style[t] = f + r,
        _ = e[u],
        E ? e.style[t] = E : kr(e, t)
    } else
        (d || o === "%") && !R0[ai(g, "display")] && (a.position = ai(e, "position")),
        g === e && (a.position = "static"),
        g.appendChild(ps),
        _ = ps[u],
        g.removeChild(ps),
        a.position = "absolute";
    return l && d && (m = ys(g),
    m.time = ri.time,
    m.width = g[u]),
    Gt(h ? _ * s / f : _ && s ? f / _ * s : 0)
}, ar = function(e, t, n, r) {
    var s;
    return eh || Ou(),
    t in Yi && t !== "transform" && (t = Yi[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    gr[t] && t !== "transform" ? (s = ba(e, r),
    s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : Yl(ai(e, $n)) + " " + s.zOrigin + "px") : (s = e.style[t],
    (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = ql[t] && ql[t](e, t, n) || ai(e, t) || $p(e, t) || (t === "opacity" ? 1 : 0))),
    n && !~(s + "").trim().indexOf(" ") ? Hr(e, t, s, n) + n : s
}, C0 = function(e, t, n, r) {
    if (!n || n === "none") {
        var s = Mo(t, e, 1)
          , o = s && ai(e, s, 1);
        o && o !== n ? (t = s,
        n = o) : t === "borderColor" && (n = ai(e, "borderTopColor"))
    }
    var a = new Yn(this._pt,e.style,t,0,1,Mm), l = 0, c = 0, u, f, h, d, _, g, m, p, E, S, v, b;
    if (a.b = n,
    a.e = r,
    n += "",
    r += "",
    r.substring(0, 6) === "var(--" && (r = ai(e, r.substring(4, r.indexOf(")")))),
    r === "auto" && (g = e.style[t],
    e.style[t] = r,
    r = ai(e, t) || r,
    g ? e.style[t] = g : kr(e, t)),
    u = [n, r],
    dm(u),
    n = u[0],
    r = u[1],
    h = n.match(io) || [],
    b = r.match(io) || [],
    b.length) {
        for (; f = io.exec(r); )
            m = f[0],
            E = r.substring(l, f.index),
            _ ? _ = (_ + 1) % 5 : (E.substr(-5) === "rgba(" || E.substr(-5) === "hsla(") && (_ = 1),
            m !== (g = h[c++] || "") && (d = parseFloat(g) || 0,
            v = g.substr((d + "").length),
            m.charAt(1) === "=" && (m = lo(d, m) + v),
            p = parseFloat(m),
            S = m.substr((p + "").length),
            l = io.lastIndex - S.length,
            S || (S = S || li.units[t] || v,
            l === r.length && (r += S,
            a.e += S)),
            v !== S && (d = Hr(e, t, g, S) || 0),
            a._pt = {
                _next: a._pt,
                p: E || c === 1 ? E : ",",
                s: d,
                c: p - d,
                m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = l < r.length ? r.substring(l, r.length) : ""
    } else
        a.r = t === "display" && r === "none" ? Am : wm;
    return Gp.test(r) && (a.e = 0),
    this._pt = a,
    a
}, Jh = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, P0 = function(e) {
    var t = e.split(" ")
      , n = t[0]
      , r = t[1] || "50%";
    return (n === "top" || n === "bottom" || r === "left" || r === "right") && (e = n,
    n = r,
    r = e),
    t[0] = Jh[n] || n,
    t[1] = Jh[r] || r,
    t.join(" ")
}, D0 = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var n = t.t, r = n.style, s = t.u, o = n._gsap, a, l, c;
        if (s === "all" || s === !0)
            r.cssText = "",
            l = 1;
        else
            for (s = s.split(","),
            c = s.length; --c > -1; )
                a = s[c],
                gr[a] && (l = 1,
                a = a === "transformOrigin" ? $n : Bt),
                kr(n, a);
        l && (kr(n, Bt),
        o && (o.svg && n.removeAttribute("transform"),
        r.scale = r.rotate = r.translate = "none",
        ba(n, 1),
        o.uncache = 1,
        Rm(r)))
    }
}, ql = {
    clearProps: function(e, t, n, r, s) {
        if (s.data !== "isFromStart") {
            var o = e._pt = new Yn(e._pt,t,n,0,0,D0);
            return o.u = r,
            o.pr = -10,
            o.tween = s,
            e._props.push(n),
            1
        }
    }
}, Ta = [1, 0, 0, 1, 0, 0], Im = {}, Um = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, Qh = function(e) {
    var t = ai(e, Bt);
    return Um(t) ? Ta : t.substr(7).match(Vp).map(Gt)
}, ih = function(e, t) {
    var n = e._gsap || ys(e), r = e.style, s = Qh(e), o, a, l, c;
    return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix,
    s = [l.a, l.b, l.c, l.d, l.e, l.f],
    s.join(",") === "1,0,0,1,0,0" ? Ta : s) : (s === Ta && !e.offsetParent && e !== co && !n.svg && (l = r.display,
    r.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (c = 1,
    a = e.nextElementSibling,
    co.appendChild(e)),
    s = Qh(e),
    l ? r.display = l : kr(e, "display"),
    c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : co.removeChild(e))),
    t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
}, Fu = function(e, t, n, r, s, o) {
    var a = e._gsap, l = s || ih(e, !0), c = a.xOrigin || 0, u = a.yOrigin || 0, f = a.xOffset || 0, h = a.yOffset || 0, d = l[0], _ = l[1], g = l[2], m = l[3], p = l[4], E = l[5], S = t.split(" "), v = parseFloat(S[0]) || 0, b = parseFloat(S[1]) || 0, A, T, R, y;
    n ? l !== Ta && (T = d * m - _ * g) && (R = v * (m / T) + b * (-g / T) + (g * E - m * p) / T,
    y = v * (-_ / T) + b * (d / T) - (d * E - _ * p) / T,
    v = R,
    b = y) : (A = Dm(e),
    v = A.x + (~S[0].indexOf("%") ? v / 100 * A.width : v),
    b = A.y + (~(S[1] || S[0]).indexOf("%") ? b / 100 * A.height : b)),
    r || r !== !1 && a.smooth ? (p = v - c,
    E = b - u,
    a.xOffset = f + (p * d + E * g) - p,
    a.yOffset = h + (p * _ + E * m) - E) : a.xOffset = a.yOffset = 0,
    a.xOrigin = v,
    a.yOrigin = b,
    a.smooth = !!r,
    a.origin = t,
    a.originIsAbsolute = !!n,
    e.style[$n] = "0px 0px",
    o && (Lr(o, a, "xOrigin", c, v),
    Lr(o, a, "yOrigin", u, b),
    Lr(o, a, "xOffset", f, a.xOffset),
    Lr(o, a, "yOffset", h, a.yOffset)),
    e.setAttribute("data-svg-origin", v + " " + b)
}, ba = function(e, t) {
    var n = e._gsap || new _m(e);
    if ("x"in n && !t && !n.uncache)
        return n;
    var r = e.style, s = n.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = ai(e, $n) || "0", u, f, h, d, _, g, m, p, E, S, v, b, A, T, R, y, x, P, U, O, B, X, H, Y, N, k, C, re, ue, we, q, te;
    return u = f = h = g = m = p = E = S = v = 0,
    d = _ = 1,
    n.svg = !!(e.getCTM && Lm(e)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[Bt] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Bt] !== "none" ? l[Bt] : "")),
    r.scale = r.rotate = r.translate = "none"),
    T = ih(e, n.svg),
    n.svg && (n.uncache ? (N = e.getBBox(),
    c = n.xOrigin - N.x + "px " + (n.yOrigin - N.y) + "px",
    Y = "") : Y = !t && e.getAttribute("data-svg-origin"),
    Fu(e, Y || c, !!Y || n.originIsAbsolute, n.smooth !== !1, T)),
    b = n.xOrigin || 0,
    A = n.yOrigin || 0,
    T !== Ta && (P = T[0],
    U = T[1],
    O = T[2],
    B = T[3],
    u = X = T[4],
    f = H = T[5],
    T.length === 6 ? (d = Math.sqrt(P * P + U * U),
    _ = Math.sqrt(B * B + O * O),
    g = P || U ? Ns(U, P) * ss : 0,
    E = O || B ? Ns(O, B) * ss + g : 0,
    E && (_ *= Math.abs(Math.cos(E * uo))),
    n.svg && (u -= b - (b * P + A * O),
    f -= A - (b * U + A * B))) : (te = T[6],
    we = T[7],
    C = T[8],
    re = T[9],
    ue = T[10],
    q = T[11],
    u = T[12],
    f = T[13],
    h = T[14],
    R = Ns(te, ue),
    m = R * ss,
    R && (y = Math.cos(-R),
    x = Math.sin(-R),
    Y = X * y + C * x,
    N = H * y + re * x,
    k = te * y + ue * x,
    C = X * -x + C * y,
    re = H * -x + re * y,
    ue = te * -x + ue * y,
    q = we * -x + q * y,
    X = Y,
    H = N,
    te = k),
    R = Ns(-O, ue),
    p = R * ss,
    R && (y = Math.cos(-R),
    x = Math.sin(-R),
    Y = P * y - C * x,
    N = U * y - re * x,
    k = O * y - ue * x,
    q = B * x + q * y,
    P = Y,
    U = N,
    O = k),
    R = Ns(U, P),
    g = R * ss,
    R && (y = Math.cos(R),
    x = Math.sin(R),
    Y = P * y + U * x,
    N = X * y + H * x,
    U = U * y - P * x,
    H = H * y - X * x,
    P = Y,
    X = N),
    m && Math.abs(m) + Math.abs(g) > 359.9 && (m = g = 0,
    p = 180 - p),
    d = Gt(Math.sqrt(P * P + U * U + O * O)),
    _ = Gt(Math.sqrt(H * H + te * te)),
    R = Ns(X, H),
    E = Math.abs(R) > 2e-4 ? R * ss : 0,
    v = q ? 1 / (q < 0 ? -q : q) : 0),
    n.svg && (Y = e.getAttribute("transform"),
    n.forceCSS = e.setAttribute("transform", "") || !Um(ai(e, Bt)),
    Y && e.setAttribute("transform", Y))),
    Math.abs(E) > 90 && Math.abs(E) < 270 && (s ? (d *= -1,
    E += g <= 0 ? 180 : -180,
    g += g <= 0 ? 180 : -180) : (_ *= -1,
    E += E <= 0 ? 180 : -180)),
    t = t || n.uncache,
    n.x = u - ((n.xPercent = u && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o,
    n.y = f - ((n.yPercent = f && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o,
    n.z = h + o,
    n.scaleX = Gt(d),
    n.scaleY = Gt(_),
    n.rotation = Gt(g) + a,
    n.rotationX = Gt(m) + a,
    n.rotationY = Gt(p) + a,
    n.skewX = E + a,
    n.skewY = S + a,
    n.transformPerspective = v + o,
    (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (r[$n] = Yl(c)),
    n.xOffset = n.yOffset = 0,
    n.force3D = li.force3D,
    n.renderTransform = n.svg ? I0 : Pm ? Nm : L0,
    n.uncache = 0,
    n
}, Yl = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, bc = function(e, t, n) {
    var r = En(t);
    return Gt(parseFloat(t) + parseFloat(Hr(e, "x", n + "px", r))) + r
}, L0 = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    Nm(e, t)
}, Zr = "0deg", Bo = "0px", Jr = ") ", Nm = function(e, t) {
    var n = t || this
      , r = n.xPercent
      , s = n.yPercent
      , o = n.x
      , a = n.y
      , l = n.z
      , c = n.rotation
      , u = n.rotationY
      , f = n.rotationX
      , h = n.skewX
      , d = n.skewY
      , _ = n.scaleX
      , g = n.scaleY
      , m = n.transformPerspective
      , p = n.force3D
      , E = n.target
      , S = n.zOrigin
      , v = ""
      , b = p === "auto" && e && e !== 1 || p === !0;
    if (S && (f !== Zr || u !== Zr)) {
        var A = parseFloat(u) * uo, T = Math.sin(A), R = Math.cos(A), y;
        A = parseFloat(f) * uo,
        y = Math.cos(A),
        o = bc(E, o, T * y * -S),
        a = bc(E, a, -Math.sin(A) * -S),
        l = bc(E, l, R * y * -S + S)
    }
    m !== Bo && (v += "perspective(" + m + Jr),
    (r || s) && (v += "translate(" + r + "%, " + s + "%) "),
    (b || o !== Bo || a !== Bo || l !== Bo) && (v += l !== Bo || b ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + Jr),
    c !== Zr && (v += "rotate(" + c + Jr),
    u !== Zr && (v += "rotateY(" + u + Jr),
    f !== Zr && (v += "rotateX(" + f + Jr),
    (h !== Zr || d !== Zr) && (v += "skew(" + h + ", " + d + Jr),
    (_ !== 1 || g !== 1) && (v += "scale(" + _ + ", " + g + Jr),
    E.style[Bt] = v || "translate(0, 0)"
}, I0 = function(e, t) {
    var n = t || this, r = n.xPercent, s = n.yPercent, o = n.x, a = n.y, l = n.rotation, c = n.skewX, u = n.skewY, f = n.scaleX, h = n.scaleY, d = n.target, _ = n.xOrigin, g = n.yOrigin, m = n.xOffset, p = n.yOffset, E = n.forceCSS, S = parseFloat(o), v = parseFloat(a), b, A, T, R, y;
    l = parseFloat(l),
    c = parseFloat(c),
    u = parseFloat(u),
    u && (u = parseFloat(u),
    c += u,
    l += u),
    l || c ? (l *= uo,
    c *= uo,
    b = Math.cos(l) * f,
    A = Math.sin(l) * f,
    T = Math.sin(l - c) * -h,
    R = Math.cos(l - c) * h,
    c && (u *= uo,
    y = Math.tan(c - u),
    y = Math.sqrt(1 + y * y),
    T *= y,
    R *= y,
    u && (y = Math.tan(u),
    y = Math.sqrt(1 + y * y),
    b *= y,
    A *= y)),
    b = Gt(b),
    A = Gt(A),
    T = Gt(T),
    R = Gt(R)) : (b = f,
    R = h,
    A = T = 0),
    (S && !~(o + "").indexOf("px") || v && !~(a + "").indexOf("px")) && (S = Hr(d, "x", o, "px"),
    v = Hr(d, "y", a, "px")),
    (_ || g || m || p) && (S = Gt(S + _ - (_ * b + g * T) + m),
    v = Gt(v + g - (_ * A + g * R) + p)),
    (r || s) && (y = d.getBBox(),
    S = Gt(S + r / 100 * y.width),
    v = Gt(v + s / 100 * y.height)),
    y = "matrix(" + b + "," + A + "," + T + "," + R + "," + S + "," + v + ")",
    d.setAttribute("transform", y),
    E && (d.style[Bt] = y)
}, U0 = function(e, t, n, r, s) {
    var o = 360, a = un(s), l = parseFloat(s) * (a && ~s.indexOf("rad") ? ss : 1), c = l - r, u = r + c + "deg", f, h;
    return a && (f = s.split("_")[1],
    f === "short" && (c %= o,
    c !== c % (o / 2) && (c += c < 0 ? o : -o)),
    f === "cw" && c < 0 ? c = (c + o * Yh) % o - ~~(c / o) * o : f === "ccw" && c > 0 && (c = (c - o * Yh) % o - ~~(c / o) * o)),
    e._pt = h = new Yn(e._pt,t,n,r,c,g0),
    h.e = u,
    h.u = "deg",
    e._props.push(n),
    h
}, ed = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, N0 = function(e, t, n) {
    var r = ed({}, n._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, l, c, u, f, h, d, _;
    r.svg ? (c = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    o[Bt] = t,
    a = ba(n, 1),
    kr(n, Bt),
    n.setAttribute("transform", c)) : (c = getComputedStyle(n)[Bt],
    o[Bt] = t,
    a = ba(n, 1),
    o[Bt] = c);
    for (l in gr)
        c = r[l],
        u = a[l],
        c !== u && s.indexOf(l) < 0 && (d = En(c),
        _ = En(u),
        f = d !== _ ? Hr(n, l, c, _) : parseFloat(c),
        h = parseFloat(u),
        e._pt = new Yn(e._pt,a,l,f,h - f,Uu),
        e._pt.u = _ || 0,
        e._props.push(l));
    ed(a, r)
};
qn("padding,margin,Width,Radius", function(i, e) {
    var t = "Top"
      , n = "Right"
      , r = "Bottom"
      , s = "Left"
      , o = (e < 3 ? [t, n, r, s] : [t + s, t + n, r + n, r + s]).map(function(a) {
        return e < 2 ? i + a : "border" + a + i
    });
    ql[e > 1 ? "border" + i : i] = function(a, l, c, u, f) {
        var h, d;
        if (arguments.length < 4)
            return h = o.map(function(_) {
                return ar(a, _, c)
            }),
            d = h.join(" "),
            d.split(h[0]).length === 5 ? h[0] : d;
        h = (u + "").split(" "),
        d = {},
        o.forEach(function(_, g) {
            return d[_] = h[g] = h[g] || h[(g - 1) / 2 | 0]
        }),
        a.init(l, d, f)
    }
});
var Om = {
    name: "css",
    register: Ou,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, r, s) {
        var o = this._props, a = e.style, l = n.vars.startAt, c, u, f, h, d, _, g, m, p, E, S, v, b, A, T, R, y;
        eh || Ou(),
        this.styles = this.styles || Cm(e),
        R = this.styles.props,
        this.tween = n;
        for (g in t)
            if (g !== "autoRound" && (u = t[g],
            !(ni[g] && vm(g, t, n, r, e, s)))) {
                if (d = typeof u,
                _ = ql[g],
                d === "function" && (u = u.call(n, r, e, s),
                d = typeof u),
                d === "string" && ~u.indexOf("random(") && (u = Sa(u)),
                _)
                    _(this, e, g, u, n) && (T = 1);
                else if (g.substr(0, 2) === "--")
                    c = (getComputedStyle(e).getPropertyValue(g) + "").trim(),
                    u += "",
                    Or.lastIndex = 0,
                    Or.test(c) || (m = En(c),
                    p = En(u),
                    p ? m !== p && (c = Hr(e, g, c, p) + p) : m && (u += m)),
                    this.add(a, "setProperty", c, u, r, s, 0, 0, g),
                    o.push(g),
                    R.push(g, 0, a[g]);
                else if (d !== "undefined") {
                    if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(n, r, e, s) : l[g],
                    un(c) && ~c.indexOf("random(") && (c = Sa(c)),
                    En(c + "") || c === "auto" || (c += li.units[g] || En(ar(e, g)) || ""),
                    (c + "").charAt(1) === "=" && (c = ar(e, g))) : c = ar(e, g),
                    h = parseFloat(c),
                    E = d === "string" && u.charAt(1) === "=" && u.substr(0, 2),
                    E && (u = u.substr(2)),
                    f = parseFloat(u),
                    g in Yi && (g === "autoAlpha" && (h === 1 && ar(e, "visibility") === "hidden" && f && (h = 0),
                    R.push("visibility", 0, a.visibility),
                    Lr(this, a, "visibility", h ? "inherit" : "hidden", f ? "inherit" : "hidden", !f)),
                    g !== "scale" && g !== "transform" && (g = Yi[g],
                    ~g.indexOf(",") && (g = g.split(",")[0]))),
                    S = g in gr,
                    S) {
                        if (this.styles.save(g),
                        y = u,
                        d === "string" && u.substring(0, 6) === "var(--") {
                            if (u = ai(e, u.substring(4, u.indexOf(")"))),
                            u.substring(0, 5) === "calc(") {
                                var x = e.style.perspective;
                                e.style.perspective = u,
                                u = ai(e, "perspective"),
                                x ? e.style.perspective = x : kr(e, "perspective")
                            }
                            f = parseFloat(u)
                        }
                        if (v || (b = e._gsap,
                        b.renderTransform && !t.parseTransform || ba(e, t.parseTransform),
                        A = t.smoothOrigin !== !1 && b.smooth,
                        v = this._pt = new Yn(this._pt,a,Bt,0,1,b.renderTransform,b,0,-1),
                        v.dep = 1),
                        g === "scale")
                            this._pt = new Yn(this._pt,b,"scaleY",b.scaleY,(E ? lo(b.scaleY, E + f) : f) - b.scaleY || 0,Uu),
                            this._pt.u = 0,
                            o.push("scaleY", g),
                            g += "X";
                        else if (g === "transformOrigin") {
                            R.push($n, 0, a[$n]),
                            u = P0(u),
                            b.svg ? Fu(e, u, 0, A, 0, this) : (p = parseFloat(u.split(" ")[2]) || 0,
                            p !== b.zOrigin && Lr(this, b, "zOrigin", b.zOrigin, p),
                            Lr(this, a, g, Yl(c), Yl(u)));
                            continue
                        } else if (g === "svgOrigin") {
                            Fu(e, u, 1, A, 0, this);
                            continue
                        } else if (g in Im) {
                            U0(this, b, g, h, E ? lo(h, E + u) : u);
                            continue
                        } else if (g === "smoothOrigin") {
                            Lr(this, b, "smooth", b.smooth, u);
                            continue
                        } else if (g === "force3D") {
                            b[g] = u;
                            continue
                        } else if (g === "transform") {
                            N0(this, u, e);
                            continue
                        }
                    } else
                        g in a || (g = Mo(g) || g);
                    if (S || (f || f === 0) && (h || h === 0) && !m0.test(u) && g in a)
                        m = (c + "").substr((h + "").length),
                        f || (f = 0),
                        p = En(u) || (g in li.units ? li.units[g] : m),
                        m !== p && (h = Hr(e, g, c, p)),
                        this._pt = new Yn(this._pt,S ? b : a,g,h,(E ? lo(h, E + f) : f) - h,!S && (p === "px" || g === "zIndex") && t.autoRound !== !1 ? x0 : Uu),
                        this._pt.u = p || 0,
                        S && y !== u ? (this._pt.b = c,
                        this._pt.e = y,
                        this._pt.r = v0) : m !== p && p !== "%" && (this._pt.b = c,
                        this._pt.r = _0);
                    else if (g in a)
                        C0.call(this, e, g, c, E ? E + u : u);
                    else if (g in e)
                        this.add(e, g, c || e[g], E ? E + u : u, r, s);
                    else if (g !== "parseTransform") {
                        Wf(g, u);
                        continue
                    }
                    S || (g in a ? R.push(g, 0, a[g]) : typeof e[g] == "function" ? R.push(g, 2, e[g]()) : R.push(g, 1, c || e[g])),
                    o.push(g)
                }
            }
        T && Tm(this)
    },
    render: function(e, t) {
        if (t.tween._time || !th())
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next;
        else
            t.styles.revert()
    },
    get: ar,
    aliases: Yi,
    getSetter: function(e, t, n) {
        var r = Yi[t];
        return r && r.indexOf(",") < 0 && (t = r),
        t in gr && t !== $n && (e._gsap.x || ar(e, "x")) ? n && qh === n ? t === "scale" ? M0 : E0 : (qh = n || {}) && (t === "scale" ? T0 : b0) : e.style && !Hf(e.style[t]) ? y0 : ~t.indexOf("-") ? S0 : Jf(e, t)
    },
    core: {
        _removeProperty: kr,
        _getMatrix: ih
    }
};
jn.utils.checkPrefix = Mo;
jn.core.getStyleSaver = Cm;
(function(i, e, t, n) {
    var r = qn(i + "," + e + "," + t, function(s) {
        gr[s] = 1
    });
    qn(e, function(s) {
        li.units[s] = "deg",
        Im[s] = 1
    }),
    Yi[r[13]] = i + "," + e,
    qn(n, function(s) {
        var o = s.split(":");
        Yi[o[1]] = r[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
qn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(i) {
    li.units[i] = "px"
});
jn.registerPlugin(Om);
var Dt = jn.registerPlugin(Om) || jn;
Dt.core.Tween;
function O0(i, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(i, n.key, n)
    }
}
function F0(i, e, t) {
    return e && O0(i.prototype, e),
    i
}
/*!
 * Observer 3.14.2
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var mn, wl, si, Ir, Ur, fo, Fm, os, aa, Bm, cr, Li, zm, km = function() {
    return mn || typeof window < "u" && (mn = window.gsap) && mn.registerPlugin && mn
}, Hm = 1, so = [], at = [], Ki = [], la = Date.now, Bu = function(e, t) {
    return t
}, B0 = function() {
    var e = aa.core
      , t = e.bridge || {}
      , n = e._scrollers
      , r = e._proxies;
    n.push.apply(n, at),
    r.push.apply(r, Ki),
    at = n,
    Ki = r,
    Bu = function(o, a) {
        return t[o](a)
    }
}, Fr = function(e, t) {
    return ~Ki.indexOf(e) && Ki[Ki.indexOf(e) + 1][t]
}, ca = function(e) {
    return !!~Bm.indexOf(e)
}, Cn = function(e, t, n, r, s) {
    return e.addEventListener(t, n, {
        passive: r !== !1,
        capture: !!s
    })
}, Rn = function(e, t, n, r) {
    return e.removeEventListener(t, n, !!r)
}, Va = "scrollLeft", Ga = "scrollTop", zu = function() {
    return cr && cr.isPressed || at.cache++
}, $l = function(e, t) {
    var n = function r(s) {
        if (s || s === 0) {
            Hm && (si.history.scrollRestoration = "manual");
            var o = cr && cr.isPressed;
            s = r.v = Math.round(s) || (cr && cr.iOS ? 1 : 0),
            e(s),
            r.cacheID = at.cache,
            o && Bu("ss", s)
        } else
            (t || at.cache !== r.cacheID || Bu("ref")) && (r.cacheID = at.cache,
            r.v = e());
        return r.v + r.offset
    };
    return n.offset = 0,
    e && n
}, Nn = {
    s: Va,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: $l(function(i) {
        return arguments.length ? si.scrollTo(i, en.sc()) : si.pageXOffset || Ir[Va] || Ur[Va] || fo[Va] || 0
    })
}, en = {
    s: Ga,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: Nn,
    sc: $l(function(i) {
        return arguments.length ? si.scrollTo(Nn.sc(), i) : si.pageYOffset || Ir[Ga] || Ur[Ga] || fo[Ga] || 0
    })
}, Vn = function(e, t) {
    return (t && t._ctx && t._ctx.selector || mn.utils.toArray)(e)[0] || (typeof e == "string" && mn.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, z0 = function(e, t) {
    for (var n = t.length; n--; )
        if (t[n] === e || t[n].contains(e))
            return !0;
    return !1
}, Vr = function(e, t) {
    var n = t.s
      , r = t.sc;
    ca(e) && (e = Ir.scrollingElement || Ur);
    var s = at.indexOf(e)
      , o = r === en.sc ? 1 : 2;
    !~s && (s = at.push(e) - 1),
    at[s + o] || Cn(e, "scroll", zu);
    var a = at[s + o]
      , l = a || (at[s + o] = $l(Fr(e, n), !0) || (ca(e) ? r : $l(function(c) {
        return arguments.length ? e[n] = c : e[n]
    })));
    return l.target = e,
    a || (l.smooth = mn.getProperty(e, "scrollBehavior") === "smooth"),
    l
}, ku = function(e, t, n) {
    var r = e
      , s = e
      , o = la()
      , a = o
      , l = t || 50
      , c = Math.max(500, l * 3)
      , u = function(_, g) {
        var m = la();
        g || m - o > l ? (s = r,
        r = _,
        a = o,
        o = m) : n ? r += _ : r = s + (_ - s) / (m - a) * (o - a)
    }
      , f = function() {
        s = r = n ? 0 : r,
        a = o = 0
    }
      , h = function(_) {
        var g = a
          , m = s
          , p = la();
        return (_ || _ === 0) && _ !== r && u(_),
        o === a || p - a > c ? 0 : (r + (n ? m : -m)) / ((n ? p : o) - g) * 1e3
    };
    return {
        update: u,
        reset: f,
        getVelocity: h
    }
}, zo = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, td = function(e) {
    var t = Math.max.apply(Math, e)
      , n = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(n) ? t : n
}, Vm = function() {
    aa = mn.core.globals().ScrollTrigger,
    aa && aa.core && B0()
}, Gm = function(e) {
    return mn = e || km(),
    !wl && mn && typeof document < "u" && document.body && (si = window,
    Ir = document,
    Ur = Ir.documentElement,
    fo = Ir.body,
    Bm = [si, Ir, Ur, fo],
    mn.utils.clamp,
    zm = mn.core.context || function() {}
    ,
    os = "onpointerenter"in fo ? "pointer" : "mouse",
    Fm = Xt.isTouch = si.matchMedia && si.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in si || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    Li = Xt.eventTypes = ("ontouchstart"in Ur ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Ur ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return Hm = 0
    }, 500),
    Vm(),
    wl = 1),
    wl
};
Nn.op = en;
at.cache = 0;
var Xt = (function() {
    function i(t) {
        this.init(t)
    }
    var e = i.prototype;
    return e.init = function(n) {
        wl || Gm(mn) || console.warn("Please gsap.registerPlugin(Observer)"),
        aa || Vm();
        var r = n.tolerance
          , s = n.dragMinimum
          , o = n.type
          , a = n.target
          , l = n.lineHeight
          , c = n.debounce
          , u = n.preventDefault
          , f = n.onStop
          , h = n.onStopDelay
          , d = n.ignore
          , _ = n.wheelSpeed
          , g = n.event
          , m = n.onDragStart
          , p = n.onDragEnd
          , E = n.onDrag
          , S = n.onPress
          , v = n.onRelease
          , b = n.onRight
          , A = n.onLeft
          , T = n.onUp
          , R = n.onDown
          , y = n.onChangeX
          , x = n.onChangeY
          , P = n.onChange
          , U = n.onToggleX
          , O = n.onToggleY
          , B = n.onHover
          , X = n.onHoverEnd
          , H = n.onMove
          , Y = n.ignoreCheck
          , N = n.isNormalizer
          , k = n.onGestureStart
          , C = n.onGestureEnd
          , re = n.onWheel
          , ue = n.onEnable
          , we = n.onDisable
          , q = n.onClick
          , te = n.scrollSpeed
          , fe = n.capture
          , oe = n.allowClicks
          , me = n.lockAxis
          , He = n.onLockAxis;
        this.target = a = Vn(a) || Ur,
        this.vars = n,
        d && (d = mn.utils.toArray(d)),
        r = r || 1e-9,
        s = s || 0,
        _ = _ || 1,
        te = te || 1,
        o = o || "wheel,touch,pointer",
        c = c !== !1,
        l || (l = parseFloat(si.getComputedStyle(fo).lineHeight) || 22);
        var ze, Qe, et, De, I, Je, Ge, G = this, Ee = 0, Ke = 0, Ue = n.passive || !u && n.passive !== !1, ge = Vr(a, Nn), ht = Vr(a, en), D = ge(), M = ht(), V = ~o.indexOf("touch") && !~o.indexOf("pointer") && Li[0] === "pointerdown", ne = ca(a), ee = a.ownerDocument || Ir, J = [0, 0, 0], Ae = [0, 0, 0], de = 0, Ce = function() {
            return de = la()
        }, $ = function(Oe, tt) {
            return (G.event = Oe) && d && z0(Oe.target, d) || tt && V && Oe.pointerType !== "touch" || Y && Y(Oe, tt)
        }, K = function() {
            G._vx.reset(),
            G._vy.reset(),
            Qe.pause(),
            f && f(G)
        }, ae = function() {
            var Oe = G.deltaX = td(J)
              , tt = G.deltaY = td(Ae)
              , _e = Math.abs(Oe) >= r
              , $e = Math.abs(tt) >= r;
            P && (_e || $e) && P(G, Oe, tt, J, Ae),
            _e && (b && G.deltaX > 0 && b(G),
            A && G.deltaX < 0 && A(G),
            y && y(G),
            U && G.deltaX < 0 != Ee < 0 && U(G),
            Ee = G.deltaX,
            J[0] = J[1] = J[2] = 0),
            $e && (R && G.deltaY > 0 && R(G),
            T && G.deltaY < 0 && T(G),
            x && x(G),
            O && G.deltaY < 0 != Ke < 0 && O(G),
            Ke = G.deltaY,
            Ae[0] = Ae[1] = Ae[2] = 0),
            (De || et) && (H && H(G),
            et && (m && et === 1 && m(G),
            E && E(G),
            et = 0),
            De = !1),
            Je && !(Je = !1) && He && He(G),
            I && (re(G),
            I = !1),
            ze = 0
        }, Me = function(Oe, tt, _e) {
            J[_e] += Oe,
            Ae[_e] += tt,
            G._vx.update(Oe),
            G._vy.update(tt),
            c ? ze || (ze = requestAnimationFrame(ae)) : ae()
        }, Te = function(Oe, tt) {
            me && !Ge && (G.axis = Ge = Math.abs(Oe) > Math.abs(tt) ? "x" : "y",
            Je = !0),
            Ge !== "y" && (J[2] += Oe,
            G._vx.update(Oe, !0)),
            Ge !== "x" && (Ae[2] += tt,
            G._vy.update(tt, !0)),
            c ? ze || (ze = requestAnimationFrame(ae)) : ae()
        }, ce = function(Oe) {
            if (!$(Oe, 1)) {
                Oe = zo(Oe, u);
                var tt = Oe.clientX
                  , _e = Oe.clientY
                  , $e = tt - G.x
                  , Fe = _e - G.y
                  , Ye = G.isDragging;
                G.x = tt,
                G.y = _e,
                (Ye || ($e || Fe) && (Math.abs(G.startX - tt) >= s || Math.abs(G.startY - _e) >= s)) && (et || (et = Ye ? 2 : 1),
                Ye || (G.isDragging = !0),
                Te($e, Fe))
            }
        }, Ne = G.onPress = function(be) {
            $(be, 1) || be && be.button || (G.axis = Ge = null,
            Qe.pause(),
            G.isPressed = !0,
            be = zo(be),
            Ee = Ke = 0,
            G.startX = G.x = be.clientX,
            G.startY = G.y = be.clientY,
            G._vx.reset(),
            G._vy.reset(),
            Cn(N ? a : ee, Li[1], ce, Ue, !0),
            G.deltaX = G.deltaY = 0,
            S && S(G))
        }
        , L = G.onRelease = function(be) {
            if (!$(be, 1)) {
                Rn(N ? a : ee, Li[1], ce, !0);
                var Oe = !isNaN(G.y - G.startY)
                  , tt = G.isDragging
                  , _e = tt && (Math.abs(G.x - G.startX) > 3 || Math.abs(G.y - G.startY) > 3)
                  , $e = zo(be);
                !_e && Oe && (G._vx.reset(),
                G._vy.reset(),
                u && oe && mn.delayedCall(.08, function() {
                    if (la() - de > 300 && !be.defaultPrevented) {
                        if (be.target.click)
                            be.target.click();
                        else if (ee.createEvent) {
                            var Fe = ee.createEvent("MouseEvents");
                            Fe.initMouseEvent("click", !0, !0, si, 1, $e.screenX, $e.screenY, $e.clientX, $e.clientY, !1, !1, !1, !1, 0, null),
                            be.target.dispatchEvent(Fe)
                        }
                    }
                })),
                G.isDragging = G.isGesturing = G.isPressed = !1,
                f && tt && !N && Qe.restart(!0),
                et && ae(),
                p && tt && p(G),
                v && v(G, _e)
            }
        }
        , he = function(Oe) {
            return Oe.touches && Oe.touches.length > 1 && (G.isGesturing = !0) && k(Oe, G.isDragging)
        }, ie = function() {
            return (G.isGesturing = !1) || C(G)
        }, pe = function(Oe) {
            if (!$(Oe)) {
                var tt = ge()
                  , _e = ht();
                Me((tt - D) * te, (_e - M) * te, 1),
                D = tt,
                M = _e,
                f && Qe.restart(!0)
            }
        }, se = function(Oe) {
            if (!$(Oe)) {
                Oe = zo(Oe, u),
                re && (I = !0);
                var tt = (Oe.deltaMode === 1 ? l : Oe.deltaMode === 2 ? si.innerHeight : 1) * _;
                Me(Oe.deltaX * tt, Oe.deltaY * tt, 0),
                f && !N && Qe.restart(!0)
            }
        }, Q = function(Oe) {
            if (!$(Oe)) {
                var tt = Oe.clientX
                  , _e = Oe.clientY
                  , $e = tt - G.x
                  , Fe = _e - G.y;
                G.x = tt,
                G.y = _e,
                De = !0,
                f && Qe.restart(!0),
                ($e || Fe) && Te($e, Fe)
            }
        }, Pe = function(Oe) {
            G.event = Oe,
            B(G)
        }, Ve = function(Oe) {
            G.event = Oe,
            X(G)
        }, gt = function(Oe) {
            return $(Oe) || zo(Oe, u) && q(G)
        };
        Qe = G._dc = mn.delayedCall(h || .25, K).pause(),
        G.deltaX = G.deltaY = 0,
        G._vx = ku(0, 50, !0),
        G._vy = ku(0, 50, !0),
        G.scrollX = ge,
        G.scrollY = ht,
        G.isDragging = G.isGesturing = G.isPressed = !1,
        zm(this),
        G.enable = function(be) {
            return G.isEnabled || (Cn(ne ? ee : a, "scroll", zu),
            o.indexOf("scroll") >= 0 && Cn(ne ? ee : a, "scroll", pe, Ue, fe),
            o.indexOf("wheel") >= 0 && Cn(a, "wheel", se, Ue, fe),
            (o.indexOf("touch") >= 0 && Fm || o.indexOf("pointer") >= 0) && (Cn(a, Li[0], Ne, Ue, fe),
            Cn(ee, Li[2], L),
            Cn(ee, Li[3], L),
            oe && Cn(a, "click", Ce, !0, !0),
            q && Cn(a, "click", gt),
            k && Cn(ee, "gesturestart", he),
            C && Cn(ee, "gestureend", ie),
            B && Cn(a, os + "enter", Pe),
            X && Cn(a, os + "leave", Ve),
            H && Cn(a, os + "move", Q)),
            G.isEnabled = !0,
            G.isDragging = G.isGesturing = G.isPressed = De = et = !1,
            G._vx.reset(),
            G._vy.reset(),
            D = ge(),
            M = ht(),
            be && be.type && Ne(be),
            ue && ue(G)),
            G
        }
        ,
        G.disable = function() {
            G.isEnabled && (so.filter(function(be) {
                return be !== G && ca(be.target)
            }).length || Rn(ne ? ee : a, "scroll", zu),
            G.isPressed && (G._vx.reset(),
            G._vy.reset(),
            Rn(N ? a : ee, Li[1], ce, !0)),
            Rn(ne ? ee : a, "scroll", pe, fe),
            Rn(a, "wheel", se, fe),
            Rn(a, Li[0], Ne, fe),
            Rn(ee, Li[2], L),
            Rn(ee, Li[3], L),
            Rn(a, "click", Ce, !0),
            Rn(a, "click", gt),
            Rn(ee, "gesturestart", he),
            Rn(ee, "gestureend", ie),
            Rn(a, os + "enter", Pe),
            Rn(a, os + "leave", Ve),
            Rn(a, os + "move", Q),
            G.isEnabled = G.isPressed = G.isDragging = !1,
            we && we(G))
        }
        ,
        G.kill = G.revert = function() {
            G.disable();
            var be = so.indexOf(G);
            be >= 0 && so.splice(be, 1),
            cr === G && (cr = 0)
        }
        ,
        so.push(G),
        N && ca(a) && (cr = G),
        G.enable(g)
    }
    ,
    F0(i, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    i
}
)();
Xt.version = "3.14.2";
Xt.create = function(i) {
    return new Xt(i)
}
;
Xt.register = Gm;
Xt.getAll = function() {
    return so.slice()
}
;
Xt.getById = function(i) {
    return so.filter(function(e) {
        return e.vars.id === i
    })[0]
}
;
km() && mn.registerPlugin(Xt);
/*!
 * ScrollTrigger 3.14.2
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var Le, Js, ot, Ct, ii, yt, rh, jl, wa, ua, jo, Wa, xn, cc, Hu, Ln, nd, id, Qs, Wm, wc, Xm, Dn, Vu, qm, Ym, wr, Gu, sh, ho, oh, fa, Wu, Ac, Xa = 1, Sn = Date.now, Rc = Sn(), wi = 0, Ko = 0, rd = function(e, t, n) {
    var r = ti(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return n["_" + t + "Clamp"] = r,
    r ? e.substr(6, e.length - 7) : e
}, sd = function(e, t) {
    return t && (!ti(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
}, k0 = function i() {
    return Ko && requestAnimationFrame(i)
}, od = function() {
    return cc = 1
}, ad = function() {
    return cc = 0
}, Hi = function(e) {
    return e
}, Zo = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, $m = function() {
    return typeof window < "u"
}, jm = function() {
    return Le || $m() && (Le = window.gsap) && Le.registerPlugin && Le
}, Cs = function(e) {
    return !!~rh.indexOf(e)
}, Km = function(e) {
    return (e === "Height" ? oh : ot["inner" + e]) || ii["client" + e] || yt["client" + e]
}, Zm = function(e) {
    return Fr(e, "getBoundingClientRect") || (Cs(e) ? function() {
        return Dl.width = ot.innerWidth,
        Dl.height = oh,
        Dl
    }
    : function() {
        return lr(e)
    }
    )
}, H0 = function(e, t, n) {
    var r = n.d
      , s = n.d2
      , o = n.a;
    return (o = Fr(e, "getBoundingClientRect")) ? function() {
        return o()[r]
    }
    : function() {
        return (t ? Km(s) : e["client" + s]) || 0
    }
}, V0 = function(e, t) {
    return !t || ~Ki.indexOf(e) ? Zm(e) : function() {
        return Dl
    }
}, $i = function(e, t) {
    var n = t.s
      , r = t.d2
      , s = t.d
      , o = t.a;
    return Math.max(0, (n = "scroll" + r) && (o = Fr(e, n)) ? o() - Zm(e)()[s] : Cs(e) ? (ii[n] || yt[n]) - Km(r) : e[n] - e["offset" + r])
}, qa = function(e, t) {
    for (var n = 0; n < Qs.length; n += 3)
        (!t || ~t.indexOf(Qs[n + 1])) && e(Qs[n], Qs[n + 1], Qs[n + 2])
}, ti = function(e) {
    return typeof e == "string"
}, Mn = function(e) {
    return typeof e == "function"
}, Jo = function(e) {
    return typeof e == "number"
}, as = function(e) {
    return typeof e == "object"
}, ko = function(e, t, n) {
    return e && e.progress(t ? 0 : 1) && n && e.pause()
}, Cc = function(e, t) {
    if (e.enabled) {
        var n = e._ctx ? e._ctx.add(function() {
            return t(e)
        }) : t(e);
        n && n.totalTime && (e.callbackAnimation = n)
    }
}, Os = Math.abs, Jm = "left", Qm = "top", ah = "right", lh = "bottom", Ts = "width", bs = "height", ha = "Right", da = "Left", pa = "Top", ma = "Bottom", Yt = "padding", Si = "margin", To = "Width", ch = "Height", Qt = "px", Ei = function(e) {
    return ot.getComputedStyle(e)
}, G0 = function(e) {
    var t = Ei(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, ld = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, lr = function(e, t) {
    var n = t && Ei(e)[Hu] !== "matrix(1, 0, 0, 1, 0, 0)" && Le.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , r = e.getBoundingClientRect();
    return n && n.progress(0).kill(),
    r
}, Kl = function(e, t) {
    var n = t.d2;
    return e["offset" + n] || e["client" + n] || 0
}, eg = function(e) {
    var t = [], n = e.labels, r = e.duration(), s;
    for (s in n)
        t.push(n[s] / r);
    return t
}, W0 = function(e) {
    return function(t) {
        return Le.utils.snap(eg(e), t)
    }
}, uh = function(e) {
    var t = Le.utils.snap(e)
      , n = Array.isArray(e) && e.slice(0).sort(function(r, s) {
        return r - s
    });
    return n ? function(r, s, o) {
        o === void 0 && (o = .001);
        var a;
        if (!s)
            return t(r);
        if (s > 0) {
            for (r -= o,
            a = 0; a < n.length; a++)
                if (n[a] >= r)
                    return n[a];
            return n[a - 1]
        } else
            for (a = n.length,
            r += o; a--; )
                if (n[a] <= r)
                    return n[a];
        return n[0]
    }
    : function(r, s, o) {
        o === void 0 && (o = .001);
        var a = t(r);
        return !s || Math.abs(a - r) < o || a - r < 0 == s < 0 ? a : t(s < 0 ? r - e : r + e)
    }
}, X0 = function(e) {
    return function(t, n) {
        return uh(eg(e))(t, n.direction)
    }
}, Ya = function(e, t, n, r) {
    return n.split(",").forEach(function(s) {
        return e(t, s, r)
    })
}, on = function(e, t, n, r, s) {
    return e.addEventListener(t, n, {
        passive: !r,
        capture: !!s
    })
}, sn = function(e, t, n, r) {
    return e.removeEventListener(t, n, !!r)
}, $a = function(e, t, n) {
    n = n && n.wheelHandler,
    n && (e(t, "wheel", n),
    e(t, "touchmove", n))
}, cd = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, ja = {
    toggleActions: "play",
    anticipatePin: 0
}, Zl = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, Al = function(e, t) {
    if (ti(e)) {
        var n = e.indexOf("=")
          , r = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
        ~n && (e.indexOf("%") > n && (r *= t / 100),
        e = e.substr(0, n - 1)),
        e = r + (e in Zl ? Zl[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, Ka = function(e, t, n, r, s, o, a, l) {
    var c = s.startColor
      , u = s.endColor
      , f = s.fontSize
      , h = s.indent
      , d = s.fontWeight
      , _ = Ct.createElement("div")
      , g = Cs(n) || Fr(n, "pinType") === "fixed"
      , m = e.indexOf("scroller") !== -1
      , p = g ? yt : n
      , E = e.indexOf("start") !== -1
      , S = E ? c : u
      , v = "border-color:" + S + ";font-size:" + f + ";color:" + S + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return v += "position:" + ((m || l) && g ? "fixed;" : "absolute;"),
    (m || l || !g) && (v += (r === en ? ah : lh) + ":" + (o + parseFloat(h)) + "px;"),
    a && (v += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    _._isStart = E,
    _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    _.style.cssText = v,
    _.innerText = t || t === 0 ? e + "-" + t : e,
    p.children[0] ? p.insertBefore(_, p.children[0]) : p.appendChild(_),
    _._offset = _["offset" + r.op.d2],
    Rl(_, 0, r, E),
    _
}, Rl = function(e, t, n, r) {
    var s = {
        display: "block"
    }
      , o = n[r ? "os2" : "p2"]
      , a = n[r ? "p2" : "os2"];
    e._isFlipped = r,
    s[n.a + "Percent"] = r ? -100 : 0,
    s[n.a] = r ? "1px" : 0,
    s["border" + o + To] = 1,
    s["border" + a + To] = 0,
    s[n.p] = t + "px",
    Le.set(e, s)
}, rt = [], Xu = {}, Aa, ud = function() {
    return Sn() - wi > 34 && (Aa || (Aa = requestAnimationFrame(hr)))
}, Fs = function() {
    (!Dn || !Dn.isPressed || Dn.startX > yt.clientWidth) && (at.cache++,
    Dn ? Aa || (Aa = requestAnimationFrame(hr)) : hr(),
    wi || Ds("scrollStart"),
    wi = Sn())
}, Pc = function() {
    Ym = ot.innerWidth,
    qm = ot.innerHeight
}, Qo = function(e) {
    at.cache++,
    (e === !0 || !xn && !Xm && !Ct.fullscreenElement && !Ct.webkitFullscreenElement && (!Vu || Ym !== ot.innerWidth || Math.abs(ot.innerHeight - qm) > ot.innerHeight * .25)) && jl.restart(!0)
}, Ps = {}, q0 = [], tg = function i() {
    return sn(je, "scrollEnd", i) || ms(!0)
}, Ds = function(e) {
    return Ps[e] && Ps[e].map(function(t) {
        return t()
    }) || q0
}, ei = [], ng = function(e) {
    for (var t = 0; t < ei.length; t += 5)
        (!e || ei[t + 4] && ei[t + 4].query === e) && (ei[t].style.cssText = ei[t + 1],
        ei[t].getBBox && ei[t].setAttribute("transform", ei[t + 2] || ""),
        ei[t + 3].uncache = 1)
}, ig = function() {
    return at.forEach(function(e) {
        return Mn(e) && ++e.cacheID && (e.rec = e())
    })
}, fh = function(e, t) {
    var n;
    for (Ln = 0; Ln < rt.length; Ln++)
        n = rt[Ln],
        n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
    fa = !0,
    t && ng(t),
    t || Ds("revert")
}, rg = function(e, t) {
    at.cache++,
    (t || !In) && at.forEach(function(n) {
        return Mn(n) && n.cacheID++ && (n.rec = 0)
    }),
    ti(e) && (ot.history.scrollRestoration = sh = e)
}, In, ws = 0, fd, Y0 = function() {
    if (fd !== ws) {
        var e = fd = ws;
        requestAnimationFrame(function() {
            return e === ws && ms(!0)
        })
    }
}, sg = function() {
    yt.appendChild(ho),
    oh = !Dn && ho.offsetHeight || ot.innerHeight,
    yt.removeChild(ho)
}, hd = function(e) {
    return wa(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
        return t.style.display = e ? "none" : "block"
    })
}, ms = function(e, t) {
    if (ii = Ct.documentElement,
    yt = Ct.body,
    rh = [ot, Ct, ii, yt],
    wi && !e && !fa) {
        on(je, "scrollEnd", tg);
        return
    }
    sg(),
    In = je.isRefreshing = !0,
    fa || ig();
    var n = Ds("refreshInit");
    Wm && je.sort(),
    t || fh(),
    at.forEach(function(r) {
        Mn(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"),
        r(0))
    }),
    rt.slice(0).forEach(function(r) {
        return r.refresh()
    }),
    fa = !1,
    rt.forEach(function(r) {
        if (r._subPinOffset && r.pin) {
            var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , o = r.pin[s];
            r.revert(!0, 1),
            r.adjustPinSpacing(r.pin[s] - o),
            r.refresh()
        }
    }),
    Wu = 1,
    hd(!0),
    rt.forEach(function(r) {
        var s = $i(r.scroller, r._dir)
          , o = r.vars.end === "max" || r._endClamp && r.end > s
          , a = r._startClamp && r.start >= s;
        (o || a) && r.setPositions(a ? s - 1 : r.start, o ? Math.max(a ? s : r.start + 1, s) : r.end, !0)
    }),
    hd(!1),
    Wu = 0,
    n.forEach(function(r) {
        return r && r.render && r.render(-1)
    }),
    at.forEach(function(r) {
        Mn(r) && (r.smooth && requestAnimationFrame(function() {
            return r.target.style.scrollBehavior = "smooth"
        }),
        r.rec && r(r.rec))
    }),
    rg(sh, 1),
    jl.pause(),
    ws++,
    In = 2,
    hr(2),
    rt.forEach(function(r) {
        return Mn(r.vars.onRefresh) && r.vars.onRefresh(r)
    }),
    In = je.isRefreshing = !1,
    Ds("refresh")
}, qu = 0, Cl = 1, ga, hr = function(e) {
    if (e === 2 || !In && !fa) {
        je.isUpdating = !0,
        ga && ga.update(0);
        var t = rt.length
          , n = Sn()
          , r = n - Rc >= 50
          , s = t && rt[0].scroll();
        if (Cl = qu > s ? -1 : 1,
        In || (qu = s),
        r && (wi && !cc && n - wi > 200 && (wi = 0,
        Ds("scrollEnd")),
        jo = Rc,
        Rc = n),
        Cl < 0) {
            for (Ln = t; Ln-- > 0; )
                rt[Ln] && rt[Ln].update(0, r);
            Cl = 1
        } else
            for (Ln = 0; Ln < t; Ln++)
                rt[Ln] && rt[Ln].update(0, r);
        je.isUpdating = !1
    }
    Aa = 0
}, Yu = [Jm, Qm, lh, ah, Si + ma, Si + ha, Si + pa, Si + da, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Pl = Yu.concat([Ts, bs, "boxSizing", "max" + To, "max" + ch, "position", Si, Yt, Yt + pa, Yt + ha, Yt + ma, Yt + da]), $0 = function(e, t, n) {
    po(n);
    var r = e._gsap;
    if (r.spacerIsNative)
        po(r.spacerState);
    else if (e._gsap.swappedIn) {
        var s = t.parentNode;
        s && (s.insertBefore(e, t),
        s.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, Dc = function(e, t, n, r) {
    if (!e._gsap.swappedIn) {
        for (var s = Yu.length, o = t.style, a = e.style, l; s--; )
            l = Yu[s],
            o[l] = n[l];
        o.position = n.position === "absolute" ? "absolute" : "relative",
        n.display === "inline" && (o.display = "inline-block"),
        a[lh] = a[ah] = "auto",
        o.flexBasis = n.flexBasis || "auto",
        o.overflow = "visible",
        o.boxSizing = "border-box",
        o[Ts] = Kl(e, Nn) + Qt,
        o[bs] = Kl(e, en) + Qt,
        o[Yt] = a[Si] = a[Qm] = a[Jm] = "0",
        po(r),
        a[Ts] = a["max" + To] = n[Ts],
        a[bs] = a["max" + ch] = n[bs],
        a[Yt] = n[Yt],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, j0 = /([A-Z])/g, po = function(e) {
    if (e) {
        var t = e.t.style, n = e.length, r = 0, s, o;
        for ((e.t._gsap || Le.core.getCache(e.t)).uncache = 1; r < n; r += 2)
            o = e[r + 1],
            s = e[r],
            o ? t[s] = o : t[s] && t.removeProperty(s.replace(j0, "-$1").toLowerCase())
    }
}, Za = function(e) {
    for (var t = Pl.length, n = e.style, r = [], s = 0; s < t; s++)
        r.push(Pl[s], n[Pl[s]]);
    return r.t = e,
    r
}, K0 = function(e, t, n) {
    for (var r = [], s = e.length, o = n ? 8 : 0, a; o < s; o += 2)
        a = e[o],
        r.push(a, a in t ? t[a] : e[o + 1]);
    return r.t = e.t,
    r
}, Dl = {
    left: 0,
    top: 0
}, dd = function(e, t, n, r, s, o, a, l, c, u, f, h, d, _) {
    Mn(e) && (e = e(l)),
    ti(e) && e.substr(0, 3) === "max" && (e = h + (e.charAt(4) === "=" ? Al("0" + e.substr(3), n) : 0));
    var g = d ? d.time() : 0, m, p, E;
    if (d && d.seek(0),
    isNaN(e) || (e = +e),
    Jo(e))
        d && (e = Le.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, e)),
        a && Rl(a, n, r, !0);
    else {
        Mn(t) && (t = t(l));
        var S = (e || "0").split(" "), v, b, A, T;
        E = Vn(t, l) || yt,
        v = lr(E) || {},
        (!v || !v.left && !v.top) && Ei(E).display === "none" && (T = E.style.display,
        E.style.display = "block",
        v = lr(E),
        T ? E.style.display = T : E.style.removeProperty("display")),
        b = Al(S[0], v[r.d]),
        A = Al(S[1] || "0", n),
        e = v[r.p] - c[r.p] - u + b + s - A,
        a && Rl(a, A, r, n - A < 20 || a._isStart && A > 20),
        n -= n - A
    }
    if (_ && (l[_] = e || -.001,
    e < 0 && (e = 0)),
    o) {
        var R = e + n
          , y = o._isStart;
        m = "scroll" + r.d2,
        Rl(o, R, r, y && R > 20 || !y && (f ? Math.max(yt[m], ii[m]) : o.parentNode[m]) <= R + 1),
        f && (c = lr(a),
        f && (o.style[r.op.p] = c[r.op.p] - r.op.m - o._offset + Qt))
    }
    return d && E && (m = lr(E),
    d.seek(h),
    p = lr(E),
    d._caScrollDist = m[r.p] - p[r.p],
    e = e / d._caScrollDist * h),
    d && d.seek(g),
    d ? e : Math.round(e)
}, Z0 = /(webkit|moz|length|cssText|inset)/i, pd = function(e, t, n, r) {
    if (e.parentNode !== t) {
        var s = e.style, o, a;
        if (t === yt) {
            e._stOrig = s.cssText,
            a = Ei(e);
            for (o in a)
                !+o && !Z0.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
            s.top = n,
            s.left = r
        } else
            s.cssText = e._stOrig;
        Le.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, og = function(e, t, n) {
    var r = t
      , s = r;
    return function(o) {
        var a = Math.round(e());
        return a !== r && a !== s && Math.abs(a - r) > 3 && Math.abs(a - s) > 3 && (o = a,
        n && n()),
        s = r,
        r = Math.round(o),
        r
    }
}, Ja = function(e, t, n) {
    var r = {};
    r[t.p] = "+=" + n,
    Le.set(e, r)
}, md = function(e, t) {
    var n = Vr(e, t)
      , r = "_scroll" + t.p2
      , s = function o(a, l, c, u, f) {
        var h = o.tween
          , d = l.onComplete
          , _ = {};
        c = c || n();
        var g = og(n, c, function() {
            h.kill(),
            o.tween = 0
        });
        return f = u && f || 0,
        u = u || a - c,
        h && h.kill(),
        l[r] = a,
        l.inherit = !1,
        l.modifiers = _,
        _[r] = function() {
            return g(c + u * h.ratio + f * h.ratio * h.ratio)
        }
        ,
        l.onUpdate = function() {
            at.cache++,
            o.tween && hr()
        }
        ,
        l.onComplete = function() {
            o.tween = 0,
            d && d.call(h)
        }
        ,
        h = o.tween = Le.to(e, l),
        h
    };
    return e[r] = n,
    n.wheelHandler = function() {
        return s.tween && s.tween.kill() && (s.tween = 0)
    }
    ,
    on(e, "wheel", n.wheelHandler),
    je.isTouch && on(e, "touchmove", n.wheelHandler),
    s
}, je = (function() {
    function i(t, n) {
        Js || i.register(Le) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        Gu(this),
        this.init(t, n)
    }
    var e = i.prototype;
    return e.init = function(n, r) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !Ko) {
            this.update = this.refresh = this.kill = Hi;
            return
        }
        n = ld(ti(n) || Jo(n) || n.nodeType ? {
            trigger: n
        } : n, ja);
        var s = n, o = s.onUpdate, a = s.toggleClass, l = s.id, c = s.onToggle, u = s.onRefresh, f = s.scrub, h = s.trigger, d = s.pin, _ = s.pinSpacing, g = s.invalidateOnRefresh, m = s.anticipatePin, p = s.onScrubComplete, E = s.onSnapComplete, S = s.once, v = s.snap, b = s.pinReparent, A = s.pinSpacer, T = s.containerAnimation, R = s.fastScrollEnd, y = s.preventOverlaps, x = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Nn : en, P = !f && f !== 0, U = Vn(n.scroller || ot), O = Le.core.getCache(U), B = Cs(U), X = ("pinType"in n ? n.pinType : Fr(U, "pinType") || B && "fixed") === "fixed", H = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], Y = P && n.toggleActions.split(" "), N = "markers"in n ? n.markers : ja.markers, k = B ? 0 : parseFloat(Ei(U)["border" + x.p2 + To]) || 0, C = this, re = n.onRefreshInit && function() {
            return n.onRefreshInit(C)
        }
        , ue = H0(U, B, x), we = V0(U, B), q = 0, te = 0, fe = 0, oe = Vr(U, x), me, He, ze, Qe, et, De, I, Je, Ge, G, Ee, Ke, Ue, ge, ht, D, M, V, ne, ee, J, Ae, de, Ce, $, K, ae, Me, Te, ce, Ne, L, he, ie, pe, se, Q, Pe, Ve;
        if (C._startClamp = C._endClamp = !1,
        C._dir = x,
        m *= 45,
        C.scroller = U,
        C.scroll = T ? T.time.bind(T) : oe,
        Qe = oe(),
        C.vars = n,
        r = r || n.animation,
        "refreshPriority"in n && (Wm = 1,
        n.refreshPriority === -9999 && (ga = C)),
        O.tweenScroll = O.tweenScroll || {
            top: md(U, en),
            left: md(U, Nn)
        },
        C.tweenTo = me = O.tweenScroll[x.p],
        C.scrubDuration = function(_e) {
            he = Jo(_e) && _e,
            he ? L ? L.duration(_e) : L = Le.to(r, {
                ease: "expo",
                totalProgress: "+=0",
                inherit: !1,
                duration: he,
                paused: !0,
                onComplete: function() {
                    return p && p(C)
                }
            }) : (L && L.progress(1).kill(),
            L = 0)
        }
        ,
        r && (r.vars.lazy = !1,
        r._initted && !C.isReverted || r.vars.immediateRender !== !1 && n.immediateRender !== !1 && r.duration() && r.render(0, !0, !0),
        C.animation = r.pause(),
        r.scrollTrigger = C,
        C.scrubDuration(f),
        ce = 0,
        l || (l = r.vars.id)),
        v && ((!as(v) || v.push) && (v = {
            snapTo: v
        }),
        "scrollBehavior"in yt.style && Le.set(B ? [yt, ii] : U, {
            scrollBehavior: "auto"
        }),
        at.forEach(function(_e) {
            return Mn(_e) && _e.target === (B ? Ct.scrollingElement || ii : U) && (_e.smooth = !1)
        }),
        ze = Mn(v.snapTo) ? v.snapTo : v.snapTo === "labels" ? W0(r) : v.snapTo === "labelsDirectional" ? X0(r) : v.directional !== !1 ? function(_e, $e) {
            return uh(v.snapTo)(_e, Sn() - te < 500 ? 0 : $e.direction)
        }
        : Le.utils.snap(v.snapTo),
        ie = v.duration || {
            min: .1,
            max: 2
        },
        ie = as(ie) ? ua(ie.min, ie.max) : ua(ie, ie),
        pe = Le.delayedCall(v.delay || he / 2 || .1, function() {
            var _e = oe()
              , $e = Sn() - te < 500
              , Fe = me.tween;
            if (($e || Math.abs(C.getVelocity()) < 10) && !Fe && !cc && q !== _e) {
                var Ye = (_e - De) / ge, Vt = r && !P ? r.totalProgress() : Ye, st = $e ? 0 : (Vt - Ne) / (Sn() - jo) * 1e3 || 0, Rt = Le.utils.clamp(-Ye, 1 - Ye, Os(st / 2) * st / .185), Kt = Ye + (v.inertia === !1 ? 0 : Rt), Tt, bt, vt = v, Kn = vt.onStart, Pt = vt.onInterrupt, bn = vt.onComplete;
                if (Tt = ze(Kt, C),
                Jo(Tt) || (Tt = Kt),
                bt = Math.max(0, Math.round(De + Tt * ge)),
                _e <= I && _e >= De && bt !== _e) {
                    if (Fe && !Fe._initted && Fe.data <= Os(bt - _e))
                        return;
                    v.inertia === !1 && (Rt = Tt - Ye),
                    me(bt, {
                        duration: ie(Os(Math.max(Os(Kt - Vt), Os(Tt - Vt)) * .185 / st / .05 || 0)),
                        ease: v.ease || "power3",
                        data: Os(bt - _e),
                        onInterrupt: function() {
                            return pe.restart(!0) && Pt && Pt(C)
                        },
                        onComplete: function() {
                            C.update(),
                            q = oe(),
                            r && !P && (L ? L.resetTo("totalProgress", Tt, r._tTime / r._tDur) : r.progress(Tt)),
                            ce = Ne = r && !P ? r.totalProgress() : C.progress,
                            E && E(C),
                            bn && bn(C)
                        }
                    }, _e, Rt * ge, bt - _e - Rt * ge),
                    Kn && Kn(C, me.tween)
                }
            } else
                C.isActive && q !== _e && pe.restart(!0)
        }).pause()),
        l && (Xu[l] = C),
        h = C.trigger = Vn(h || d !== !0 && d),
        Ve = h && h._gsap && h._gsap.stRevert,
        Ve && (Ve = Ve(C)),
        d = d === !0 ? h : Vn(d),
        ti(a) && (a = {
            targets: h,
            className: a
        }),
        d && (_ === !1 || _ === Si || (_ = !_ && d.parentNode && d.parentNode.style && Ei(d.parentNode).display === "flex" ? !1 : Yt),
        C.pin = d,
        He = Le.core.getCache(d),
        He.spacer ? ht = He.pinState : (A && (A = Vn(A),
        A && !A.nodeType && (A = A.current || A.nativeElement),
        He.spacerIsNative = !!A,
        A && (He.spacerState = Za(A))),
        He.spacer = V = A || Ct.createElement("div"),
        V.classList.add("pin-spacer"),
        l && V.classList.add("pin-spacer-" + l),
        He.pinState = ht = Za(d)),
        n.force3D !== !1 && Le.set(d, {
            force3D: !0
        }),
        C.spacer = V = He.spacer,
        Te = Ei(d),
        Ce = Te[_ + x.os2],
        ee = Le.getProperty(d),
        J = Le.quickSetter(d, x.a, Qt),
        Dc(d, V, Te),
        M = Za(d)),
        N) {
            Ke = as(N) ? ld(N, cd) : cd,
            G = Ka("scroller-start", l, U, x, Ke, 0),
            Ee = Ka("scroller-end", l, U, x, Ke, 0, G),
            ne = G["offset" + x.op.d2];
            var gt = Vn(Fr(U, "content") || U);
            Je = this.markerStart = Ka("start", l, gt, x, Ke, ne, 0, T),
            Ge = this.markerEnd = Ka("end", l, gt, x, Ke, ne, 0, T),
            T && (Pe = Le.quickSetter([Je, Ge], x.a, Qt)),
            !X && !(Ki.length && Fr(U, "fixedMarkers") === !0) && (G0(B ? yt : U),
            Le.set([G, Ee], {
                force3D: !0
            }),
            K = Le.quickSetter(G, x.a, Qt),
            Me = Le.quickSetter(Ee, x.a, Qt))
        }
        if (T) {
            var be = T.vars.onUpdate
              , Oe = T.vars.onUpdateParams;
            T.eventCallback("onUpdate", function() {
                C.update(0, 0, 1),
                be && be.apply(T, Oe || [])
            })
        }
        if (C.previous = function() {
            return rt[rt.indexOf(C) - 1]
        }
        ,
        C.next = function() {
            return rt[rt.indexOf(C) + 1]
        }
        ,
        C.revert = function(_e, $e) {
            if (!$e)
                return C.kill(!0);
            var Fe = _e !== !1 || !C.enabled
              , Ye = xn;
            Fe !== C.isReverted && (Fe && (se = Math.max(oe(), C.scroll.rec || 0),
            fe = C.progress,
            Q = r && r.progress()),
            Je && [Je, Ge, G, Ee].forEach(function(Vt) {
                return Vt.style.display = Fe ? "none" : "block"
            }),
            Fe && (xn = C,
            C.update(Fe)),
            d && (!b || !C.isActive) && (Fe ? $0(d, V, ht) : Dc(d, V, Ei(d), $)),
            Fe || C.update(Fe),
            xn = Ye,
            C.isReverted = Fe)
        }
        ,
        C.refresh = function(_e, $e, Fe, Ye) {
            if (!((xn || !C.enabled) && !$e)) {
                if (d && _e && wi) {
                    on(i, "scrollEnd", tg);
                    return
                }
                !In && re && re(C),
                xn = C,
                me.tween && !Fe && (me.tween.kill(),
                me.tween = 0),
                L && L.pause(),
                g && r && (r.revert({
                    kill: !1
                }).invalidate(),
                r.getChildren ? r.getChildren(!0, !0, !1).forEach(function(Ze) {
                    return Ze.vars.immediateRender && Ze.render(0, !0, !0)
                }) : r.vars.immediateRender && r.render(0, !0, !0)),
                C.isReverted || C.revert(!0, !0),
                C._subPinOffset = !1;
                var Vt = ue(), st = we(), Rt = T ? T.duration() : $i(U, x), Kt = ge <= .01 || !ge, Tt = 0, bt = Ye || 0, vt = as(Fe) ? Fe.end : n.end, Kn = n.endTrigger || h, Pt = as(Fe) ? Fe.start : n.start || (n.start === 0 || !h ? 0 : d ? "0 0" : "0 100%"), bn = C.pinnedContainer = n.pinnedContainer && Vn(n.pinnedContainer, C), di = h && Math.max(0, rt.indexOf(C)) || 0, Zt = di, Jt, w, z, j, W, F, le, ve, Ie, Re, ke, We, Be;
                for (N && as(Fe) && (We = Le.getProperty(G, x.p),
                Be = Le.getProperty(Ee, x.p)); Zt-- > 0; )
                    F = rt[Zt],
                    F.end || F.refresh(0, 1) || (xn = C),
                    le = F.pin,
                    le && (le === h || le === d || le === bn) && !F.isReverted && (Re || (Re = []),
                    Re.unshift(F),
                    F.revert(!0, !0)),
                    F !== rt[Zt] && (di--,
                    Zt--);
                for (Mn(Pt) && (Pt = Pt(C)),
                Pt = rd(Pt, "start", C),
                De = dd(Pt, h, Vt, x, oe(), Je, G, C, st, k, X, Rt, T, C._startClamp && "_startClamp") || (d ? -.001 : 0),
                Mn(vt) && (vt = vt(C)),
                ti(vt) && !vt.indexOf("+=") && (~vt.indexOf(" ") ? vt = (ti(Pt) ? Pt.split(" ")[0] : "") + vt : (Tt = Al(vt.substr(2), Vt),
                vt = ti(Pt) ? Pt : (T ? Le.utils.mapRange(0, T.duration(), T.scrollTrigger.start, T.scrollTrigger.end, De) : De) + Tt,
                Kn = h)),
                vt = rd(vt, "end", C),
                I = Math.max(De, dd(vt || (Kn ? "100% 0" : Rt), Kn, Vt, x, oe() + Tt, Ge, Ee, C, st, k, X, Rt, T, C._endClamp && "_endClamp")) || -.001,
                Tt = 0,
                Zt = di; Zt--; )
                    F = rt[Zt] || {},
                    le = F.pin,
                    le && F.start - F._pinPush <= De && !T && F.end > 0 && (Jt = F.end - (C._startClamp ? Math.max(0, F.start) : F.start),
                    (le === h && F.start - F._pinPush < De || le === bn) && isNaN(Pt) && (Tt += Jt * (1 - F.progress)),
                    le === d && (bt += Jt));
                if (De += Tt,
                I += Tt,
                C._startClamp && (C._startClamp += Tt),
                C._endClamp && !In && (C._endClamp = I || -.001,
                I = Math.min(I, $i(U, x))),
                ge = I - De || (De -= .01) && .001,
                Kt && (fe = Le.utils.clamp(0, 1, Le.utils.normalize(De, I, se))),
                C._pinPush = bt,
                Je && Tt && (Jt = {},
                Jt[x.a] = "+=" + Tt,
                bn && (Jt[x.p] = "-=" + oe()),
                Le.set([Je, Ge], Jt)),
                d && !(Wu && C.end >= $i(U, x)))
                    Jt = Ei(d),
                    j = x === en,
                    z = oe(),
                    Ae = parseFloat(ee(x.a)) + bt,
                    !Rt && I > 1 && (ke = (B ? Ct.scrollingElement || ii : U).style,
                    ke = {
                        style: ke,
                        value: ke["overflow" + x.a.toUpperCase()]
                    },
                    B && Ei(yt)["overflow" + x.a.toUpperCase()] !== "scroll" && (ke.style["overflow" + x.a.toUpperCase()] = "scroll")),
                    Dc(d, V, Jt),
                    M = Za(d),
                    w = lr(d, !0),
                    ve = X && Vr(U, j ? Nn : en)(),
                    _ ? ($ = [_ + x.os2, ge + bt + Qt],
                    $.t = V,
                    Zt = _ === Yt ? Kl(d, x) + ge + bt : 0,
                    Zt && ($.push(x.d, Zt + Qt),
                    V.style.flexBasis !== "auto" && (V.style.flexBasis = Zt + Qt)),
                    po($),
                    bn && rt.forEach(function(Ze) {
                        Ze.pin === bn && Ze.vars.pinSpacing !== !1 && (Ze._subPinOffset = !0)
                    }),
                    X && oe(se)) : (Zt = Kl(d, x),
                    Zt && V.style.flexBasis !== "auto" && (V.style.flexBasis = Zt + Qt)),
                    X && (W = {
                        top: w.top + (j ? z - De : ve) + Qt,
                        left: w.left + (j ? ve : z - De) + Qt,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    W[Ts] = W["max" + To] = Math.ceil(w.width) + Qt,
                    W[bs] = W["max" + ch] = Math.ceil(w.height) + Qt,
                    W[Si] = W[Si + pa] = W[Si + ha] = W[Si + ma] = W[Si + da] = "0",
                    W[Yt] = Jt[Yt],
                    W[Yt + pa] = Jt[Yt + pa],
                    W[Yt + ha] = Jt[Yt + ha],
                    W[Yt + ma] = Jt[Yt + ma],
                    W[Yt + da] = Jt[Yt + da],
                    D = K0(ht, W, b),
                    In && oe(0)),
                    r ? (Ie = r._initted,
                    wc(1),
                    r.render(r.duration(), !0, !0),
                    de = ee(x.a) - Ae + ge + bt,
                    ae = Math.abs(ge - de) > 1,
                    X && ae && D.splice(D.length - 2, 2),
                    r.render(0, !0, !0),
                    Ie || r.invalidate(!0),
                    r.parent || r.totalTime(r.totalTime()),
                    wc(0)) : de = ge,
                    ke && (ke.value ? ke.style["overflow" + x.a.toUpperCase()] = ke.value : ke.style.removeProperty("overflow-" + x.a));
                else if (h && oe() && !T)
                    for (w = h.parentNode; w && w !== yt; )
                        w._pinOffset && (De -= w._pinOffset,
                        I -= w._pinOffset),
                        w = w.parentNode;
                Re && Re.forEach(function(Ze) {
                    return Ze.revert(!1, !0)
                }),
                C.start = De,
                C.end = I,
                Qe = et = In ? se : oe(),
                !T && !In && (Qe < se && oe(se),
                C.scroll.rec = 0),
                C.revert(!1, !0),
                te = Sn(),
                pe && (q = -1,
                pe.restart(!0)),
                xn = 0,
                r && P && (r._initted || Q) && r.progress() !== Q && r.progress(Q || 0, !0).render(r.time(), !0, !0),
                (Kt || fe !== C.progress || T || g || r && !r._initted) && (r && !P && (r._initted || fe || r.vars.immediateRender !== !1) && r.totalProgress(T && De < -.001 && !fe ? Le.utils.normalize(De, I, 0) : fe, !0),
                C.progress = Kt || (Qe - De) / ge === fe ? 0 : fe),
                d && _ && (V._pinOffset = Math.round(C.progress * de)),
                L && L.invalidate(),
                isNaN(We) || (We -= Le.getProperty(G, x.p),
                Be -= Le.getProperty(Ee, x.p),
                Ja(G, x, We),
                Ja(Je, x, We - (Ye || 0)),
                Ja(Ee, x, Be),
                Ja(Ge, x, Be - (Ye || 0))),
                Kt && !In && C.update(),
                u && !In && !Ue && (Ue = !0,
                u(C),
                Ue = !1)
            }
        }
        ,
        C.getVelocity = function() {
            return (oe() - et) / (Sn() - jo) * 1e3 || 0
        }
        ,
        C.endAnimation = function() {
            ko(C.callbackAnimation),
            r && (L ? L.progress(1) : r.paused() ? P || ko(r, C.direction < 0, 1) : ko(r, r.reversed()))
        }
        ,
        C.labelToScroll = function(_e) {
            return r && r.labels && (De || C.refresh() || De) + r.labels[_e] / r.duration() * ge || 0
        }
        ,
        C.getTrailing = function(_e) {
            var $e = rt.indexOf(C)
              , Fe = C.direction > 0 ? rt.slice(0, $e).reverse() : rt.slice($e + 1);
            return (ti(_e) ? Fe.filter(function(Ye) {
                return Ye.vars.preventOverlaps === _e
            }) : Fe).filter(function(Ye) {
                return C.direction > 0 ? Ye.end <= De : Ye.start >= I
            })
        }
        ,
        C.update = function(_e, $e, Fe) {
            if (!(T && !Fe && !_e)) {
                var Ye = In === !0 ? se : C.scroll(), Vt = _e ? 0 : (Ye - De) / ge, st = Vt < 0 ? 0 : Vt > 1 ? 1 : Vt || 0, Rt = C.progress, Kt, Tt, bt, vt, Kn, Pt, bn, di;
                if ($e && (et = Qe,
                Qe = T ? oe() : Ye,
                v && (Ne = ce,
                ce = r && !P ? r.totalProgress() : st)),
                m && d && !xn && !Xa && wi && (!st && De < Ye + (Ye - et) / (Sn() - jo) * m ? st = 1e-4 : st === 1 && I > Ye + (Ye - et) / (Sn() - jo) * m && (st = .9999)),
                st !== Rt && C.enabled) {
                    if (Kt = C.isActive = !!st && st < 1,
                    Tt = !!Rt && Rt < 1,
                    Pt = Kt !== Tt,
                    Kn = Pt || !!st != !!Rt,
                    C.direction = st > Rt ? 1 : -1,
                    C.progress = st,
                    Kn && !xn && (bt = st && !Rt ? 0 : st === 1 ? 1 : Rt === 1 ? 2 : 3,
                    P && (vt = !Pt && Y[bt + 1] !== "none" && Y[bt + 1] || Y[bt],
                    di = r && (vt === "complete" || vt === "reset" || vt in r))),
                    y && (Pt || di) && (di || f || !r) && (Mn(y) ? y(C) : C.getTrailing(y).forEach(function(z) {
                        return z.endAnimation()
                    })),
                    P || (L && !xn && !Xa ? (L._dp._time - L._start !== L._time && L.render(L._dp._time - L._start),
                    L.resetTo ? L.resetTo("totalProgress", st, r._tTime / r._tDur) : (L.vars.totalProgress = st,
                    L.invalidate().restart())) : r && r.totalProgress(st, !!(xn && (te || _e)))),
                    d) {
                        if (_e && _ && (V.style[_ + x.os2] = Ce),
                        !X)
                            J(Zo(Ae + de * st));
                        else if (Kn) {
                            if (bn = !_e && st > Rt && I + 1 > Ye && Ye + 1 >= $i(U, x),
                            b)
                                if (!_e && (Kt || bn)) {
                                    var Zt = lr(d, !0)
                                      , Jt = Ye - De;
                                    pd(d, yt, Zt.top + (x === en ? Jt : 0) + Qt, Zt.left + (x === en ? 0 : Jt) + Qt)
                                } else
                                    pd(d, V);
                            po(Kt || bn ? D : M),
                            ae && st < 1 && Kt || J(Ae + (st === 1 && !bn ? de : 0))
                        }
                    }
                    v && !me.tween && !xn && !Xa && pe.restart(!0),
                    a && (Pt || S && st && (st < 1 || !Ac)) && wa(a.targets).forEach(function(z) {
                        return z.classList[Kt || S ? "add" : "remove"](a.className)
                    }),
                    o && !P && !_e && o(C),
                    Kn && !xn ? (P && (di && (vt === "complete" ? r.pause().totalProgress(1) : vt === "reset" ? r.restart(!0).pause() : vt === "restart" ? r.restart(!0) : r[vt]()),
                    o && o(C)),
                    (Pt || !Ac) && (c && Pt && Cc(C, c),
                    H[bt] && Cc(C, H[bt]),
                    S && (st === 1 ? C.kill(!1, 1) : H[bt] = 0),
                    Pt || (bt = st === 1 ? 1 : 3,
                    H[bt] && Cc(C, H[bt]))),
                    R && !Kt && Math.abs(C.getVelocity()) > (Jo(R) ? R : 2500) && (ko(C.callbackAnimation),
                    L ? L.progress(1) : ko(r, vt === "reverse" ? 1 : !st, 1))) : P && o && !xn && o(C)
                }
                if (Me) {
                    var w = T ? Ye / T.duration() * (T._caScrollDist || 0) : Ye;
                    K(w + (G._isFlipped ? 1 : 0)),
                    Me(w)
                }
                Pe && Pe(-Ye / T.duration() * (T._caScrollDist || 0))
            }
        }
        ,
        C.enable = function(_e, $e) {
            C.enabled || (C.enabled = !0,
            on(U, "resize", Qo),
            B || on(U, "scroll", Fs),
            re && on(i, "refreshInit", re),
            _e !== !1 && (C.progress = fe = 0,
            Qe = et = q = oe()),
            $e !== !1 && C.refresh())
        }
        ,
        C.getTween = function(_e) {
            return _e && me ? me.tween : L
        }
        ,
        C.setPositions = function(_e, $e, Fe, Ye) {
            if (T) {
                var Vt = T.scrollTrigger
                  , st = T.duration()
                  , Rt = Vt.end - Vt.start;
                _e = Vt.start + Rt * _e / st,
                $e = Vt.start + Rt * $e / st
            }
            C.refresh(!1, !1, {
                start: sd(_e, Fe && !!C._startClamp),
                end: sd($e, Fe && !!C._endClamp)
            }, Ye),
            C.update()
        }
        ,
        C.adjustPinSpacing = function(_e) {
            if ($ && _e) {
                var $e = $.indexOf(x.d) + 1;
                $[$e] = parseFloat($[$e]) + _e + Qt,
                $[1] = parseFloat($[1]) + _e + Qt,
                po($)
            }
        }
        ,
        C.disable = function(_e, $e) {
            if (_e !== !1 && C.revert(!0, !0),
            C.enabled && (C.enabled = C.isActive = !1,
            $e || L && L.pause(),
            se = 0,
            He && (He.uncache = 1),
            re && sn(i, "refreshInit", re),
            pe && (pe.pause(),
            me.tween && me.tween.kill() && (me.tween = 0)),
            !B)) {
                for (var Fe = rt.length; Fe--; )
                    if (rt[Fe].scroller === U && rt[Fe] !== C)
                        return;
                sn(U, "resize", Qo),
                B || sn(U, "scroll", Fs)
            }
        }
        ,
        C.kill = function(_e, $e) {
            C.disable(_e, $e),
            L && !$e && L.kill(),
            l && delete Xu[l];
            var Fe = rt.indexOf(C);
            Fe >= 0 && rt.splice(Fe, 1),
            Fe === Ln && Cl > 0 && Ln--,
            Fe = 0,
            rt.forEach(function(Ye) {
                return Ye.scroller === C.scroller && (Fe = 1)
            }),
            Fe || In || (C.scroll.rec = 0),
            r && (r.scrollTrigger = null,
            _e && r.revert({
                kill: !1
            }),
            $e || r.kill()),
            Je && [Je, Ge, G, Ee].forEach(function(Ye) {
                return Ye.parentNode && Ye.parentNode.removeChild(Ye)
            }),
            ga === C && (ga = 0),
            d && (He && (He.uncache = 1),
            Fe = 0,
            rt.forEach(function(Ye) {
                return Ye.pin === d && Fe++
            }),
            Fe || (He.spacer = 0)),
            n.onKill && n.onKill(C)
        }
        ,
        rt.push(C),
        C.enable(!1, !1),
        Ve && Ve(C),
        r && r.add && !ge) {
            var tt = C.update;
            C.update = function() {
                C.update = tt,
                at.cache++,
                De || I || C.refresh()
            }
            ,
            Le.delayedCall(.01, C.update),
            ge = .01,
            De = I = 0
        } else
            C.refresh();
        d && Y0()
    }
    ,
    i.register = function(n) {
        return Js || (Le = n || jm(),
        $m() && window.document && i.enable(),
        Js = Ko),
        Js
    }
    ,
    i.defaults = function(n) {
        if (n)
            for (var r in n)
                ja[r] = n[r];
        return ja
    }
    ,
    i.disable = function(n, r) {
        Ko = 0,
        rt.forEach(function(o) {
            return o[r ? "kill" : "disable"](n)
        }),
        sn(ot, "wheel", Fs),
        sn(Ct, "scroll", Fs),
        clearInterval(Wa),
        sn(Ct, "touchcancel", Hi),
        sn(yt, "touchstart", Hi),
        Ya(sn, Ct, "pointerdown,touchstart,mousedown", od),
        Ya(sn, Ct, "pointerup,touchend,mouseup", ad),
        jl.kill(),
        qa(sn);
        for (var s = 0; s < at.length; s += 3)
            $a(sn, at[s], at[s + 1]),
            $a(sn, at[s], at[s + 2])
    }
    ,
    i.enable = function() {
        if (ot = window,
        Ct = document,
        ii = Ct.documentElement,
        yt = Ct.body,
        Le && (wa = Le.utils.toArray,
        ua = Le.utils.clamp,
        Gu = Le.core.context || Hi,
        wc = Le.core.suppressOverwrites || Hi,
        sh = ot.history.scrollRestoration || "auto",
        qu = ot.pageYOffset || 0,
        Le.core.globals("ScrollTrigger", i),
        yt)) {
            Ko = 1,
            ho = document.createElement("div"),
            ho.style.height = "100vh",
            ho.style.position = "absolute",
            sg(),
            k0(),
            Xt.register(Le),
            i.isTouch = Xt.isTouch,
            wr = Xt.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            Vu = Xt.isTouch === 1,
            on(ot, "wheel", Fs),
            rh = [ot, Ct, ii, yt],
            Le.matchMedia ? (i.matchMedia = function(c) {
                var u = Le.matchMedia(), f;
                for (f in c)
                    u.add(f, c[f]);
                return u
            }
            ,
            Le.addEventListener("matchMediaInit", function() {
                ig(),
                fh()
            }),
            Le.addEventListener("matchMediaRevert", function() {
                return ng()
            }),
            Le.addEventListener("matchMedia", function() {
                ms(0, 1),
                Ds("matchMedia")
            }),
            Le.matchMedia().add("(orientation: portrait)", function() {
                return Pc(),
                Pc
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            Pc(),
            on(Ct, "scroll", Fs);
            var n = yt.hasAttribute("style"), r = yt.style, s = r.borderTopStyle, o = Le.core.Animation.prototype, a, l;
            for (o.revert || Object.defineProperty(o, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            r.borderTopStyle = "solid",
            a = lr(yt),
            en.m = Math.round(a.top + en.sc()) || 0,
            Nn.m = Math.round(a.left + Nn.sc()) || 0,
            s ? r.borderTopStyle = s : r.removeProperty("border-top-style"),
            n || (yt.setAttribute("style", ""),
            yt.removeAttribute("style")),
            Wa = setInterval(ud, 250),
            Le.delayedCall(.5, function() {
                return Xa = 0
            }),
            on(Ct, "touchcancel", Hi),
            on(yt, "touchstart", Hi),
            Ya(on, Ct, "pointerdown,touchstart,mousedown", od),
            Ya(on, Ct, "pointerup,touchend,mouseup", ad),
            Hu = Le.utils.checkPrefix("transform"),
            Pl.push(Hu),
            Js = Sn(),
            jl = Le.delayedCall(.2, ms).pause(),
            Qs = [Ct, "visibilitychange", function() {
                var c = ot.innerWidth
                  , u = ot.innerHeight;
                Ct.hidden ? (nd = c,
                id = u) : (nd !== c || id !== u) && Qo()
            }
            , Ct, "DOMContentLoaded", ms, ot, "load", ms, ot, "resize", Qo],
            qa(on),
            rt.forEach(function(c) {
                return c.enable(0, 1)
            }),
            l = 0; l < at.length; l += 3)
                $a(sn, at[l], at[l + 1]),
                $a(sn, at[l], at[l + 2])
        }
    }
    ,
    i.config = function(n) {
        "limitCallbacks"in n && (Ac = !!n.limitCallbacks);
        var r = n.syncInterval;
        r && clearInterval(Wa) || (Wa = r) && setInterval(ud, r),
        "ignoreMobileResize"in n && (Vu = i.isTouch === 1 && n.ignoreMobileResize),
        "autoRefreshEvents"in n && (qa(sn) || qa(on, n.autoRefreshEvents || "none"),
        Xm = (n.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    i.scrollerProxy = function(n, r) {
        var s = Vn(n)
          , o = at.indexOf(s)
          , a = Cs(s);
        ~o && at.splice(o, a ? 6 : 2),
        r && (a ? Ki.unshift(ot, r, yt, r, ii, r) : Ki.unshift(s, r))
    }
    ,
    i.clearMatchMedia = function(n) {
        rt.forEach(function(r) {
            return r._ctx && r._ctx.query === n && r._ctx.kill(!0, !0)
        })
    }
    ,
    i.isInViewport = function(n, r, s) {
        var o = (ti(n) ? Vn(n) : n).getBoundingClientRect()
          , a = o[s ? Ts : bs] * r || 0;
        return s ? o.right - a > 0 && o.left + a < ot.innerWidth : o.bottom - a > 0 && o.top + a < ot.innerHeight
    }
    ,
    i.positionInViewport = function(n, r, s) {
        ti(n) && (n = Vn(n));
        var o = n.getBoundingClientRect()
          , a = o[s ? Ts : bs]
          , l = r == null ? a / 2 : r in Zl ? Zl[r] * a : ~r.indexOf("%") ? parseFloat(r) * a / 100 : parseFloat(r) || 0;
        return s ? (o.left + l) / ot.innerWidth : (o.top + l) / ot.innerHeight
    }
    ,
    i.killAll = function(n) {
        if (rt.slice(0).forEach(function(s) {
            return s.vars.id !== "ScrollSmoother" && s.kill()
        }),
        n !== !0) {
            var r = Ps.killAll || [];
            Ps = {},
            r.forEach(function(s) {
                return s()
            })
        }
    }
    ,
    i
}
)();
je.version = "3.14.2";
je.saveStyles = function(i) {
    return i ? wa(i).forEach(function(e) {
        if (e && e.style) {
            var t = ei.indexOf(e);
            t >= 0 && ei.splice(t, 5),
            ei.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Le.core.getCache(e), Gu())
        }
    }) : ei
}
;
je.revert = function(i, e) {
    return fh(!i, e)
}
;
je.create = function(i, e) {
    return new je(i,e)
}
;
je.refresh = function(i) {
    return i ? Qo(!0) : (Js || je.register()) && ms(!0)
}
;
je.update = function(i) {
    return ++at.cache && hr(i === !0 ? 2 : 0)
}
;
je.clearScrollMemory = rg;
je.maxScroll = function(i, e) {
    return $i(i, e ? Nn : en)
}
;
je.getScrollFunc = function(i, e) {
    return Vr(Vn(i), e ? Nn : en)
}
;
je.getById = function(i) {
    return Xu[i]
}
;
je.getAll = function() {
    return rt.filter(function(i) {
        return i.vars.id !== "ScrollSmoother"
    })
}
;
je.isScrolling = function() {
    return !!wi
}
;
je.snapDirectional = uh;
je.addEventListener = function(i, e) {
    var t = Ps[i] || (Ps[i] = []);
    ~t.indexOf(e) || t.push(e)
}
;
je.removeEventListener = function(i, e) {
    var t = Ps[i]
      , n = t && t.indexOf(e);
    n >= 0 && t.splice(n, 1)
}
;
je.batch = function(i, e) {
    var t = [], n = {}, r = e.interval || .016, s = e.batchMax || 1e9, o = function(c, u) {
        var f = []
          , h = []
          , d = Le.delayedCall(r, function() {
            u(f, h),
            f = [],
            h = []
        }).pause();
        return function(_) {
            f.length || d.restart(!0),
            f.push(_.trigger),
            h.push(_),
            s <= f.length && d.progress(1)
        }
    }, a;
    for (a in e)
        n[a] = a.substr(0, 2) === "on" && Mn(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return Mn(s) && (s = s(),
    on(je, "refresh", function() {
        return s = e.batchMax()
    })),
    wa(i).forEach(function(l) {
        var c = {};
        for (a in n)
            c[a] = n[a];
        c.trigger = l,
        t.push(je.create(c))
    }),
    t
}
;
var gd = function(e, t, n, r) {
    return t > r ? e(r) : t < 0 && e(0),
    n > r ? (r - t) / (n - t) : n < 0 ? t / (t - n) : 1
}, Lc = function i(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Xt.isTouch ? " pinch-zoom" : "") : "none",
    e === ii && i(yt, t)
}, Qa = {
    auto: 1,
    scroll: 1
}, J0 = function(e) {
    var t = e.event, n = e.target, r = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, o = s._gsap || Le.core.getCache(s), a = Sn(), l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
        for (; s && s !== yt && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(Qa[(l = Ei(s)).overflowY] || Qa[l.overflowX])); )
            s = s.parentNode;
        o._isScroll = s && s !== n && !Cs(s) && (Qa[(l = Ei(s)).overflowY] || Qa[l.overflowX]),
        o._isScrollT = a
    }
    (o._isScroll || r === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, ag = function(e, t, n, r) {
    return Xt.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: r = r && J0,
        onPress: r,
        onDrag: r,
        onScroll: r,
        onEnable: function() {
            return n && on(Ct, Xt.eventTypes[0], vd, !1, !0)
        },
        onDisable: function() {
            return sn(Ct, Xt.eventTypes[0], vd, !0)
        }
    })
}, Q0 = /(input|label|select|textarea)/i, _d, vd = function(e) {
    var t = Q0.test(e.target.tagName);
    (t || _d) && (e._gsapAllow = !0,
    _d = t)
}, ex = function(e) {
    as(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, n = t.normalizeScrollX, r = t.momentum, s = t.allowNestedScroll, o = t.onRelease, a, l, c = Vn(e.target) || ii, u = Le.core.globals().ScrollSmoother, f = u && u.get(), h = wr && (e.content && Vn(e.content) || f && e.content !== !1 && !f.smooth() && f.content()), d = Vr(c, en), _ = Vr(c, Nn), g = 1, m = (Xt.isTouch && ot.visualViewport ? ot.visualViewport.scale * ot.visualViewport.width : ot.outerWidth) / ot.innerWidth, p = 0, E = Mn(r) ? function() {
        return r(a)
    }
    : function() {
        return r || 2.8
    }
    , S, v, b = ag(c, e.type, !0, s), A = function() {
        return v = !1
    }, T = Hi, R = Hi, y = function() {
        l = $i(c, en),
        R = ua(wr ? 1 : 0, l),
        n && (T = ua(0, $i(c, Nn))),
        S = ws
    }, x = function() {
        h._gsap.y = Zo(parseFloat(h._gsap.y) + d.offset) + "px",
        h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(h._gsap.y) + ", 0, 1)",
        d.offset = d.cacheID = 0
    }, P = function() {
        if (v) {
            requestAnimationFrame(A);
            var N = Zo(a.deltaY / 2)
              , k = R(d.v - N);
            if (h && k !== d.v + d.offset) {
                d.offset = k - d.v;
                var C = Zo((parseFloat(h && h._gsap.y) || 0) - d.offset);
                h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + C + ", 0, 1)",
                h._gsap.y = C + "px",
                d.cacheID = at.cache,
                hr()
            }
            return !0
        }
        d.offset && x(),
        v = !0
    }, U, O, B, X, H = function() {
        y(),
        U.isActive() && U.vars.scrollY > l && (d() > l ? U.progress(1) && d(l) : U.resetTo("scrollY", l))
    };
    return h && Le.set(h, {
        y: "+=0"
    }),
    e.ignoreCheck = function(Y) {
        return wr && Y.type === "touchmove" && P() || g > 1.05 && Y.type !== "touchstart" || a.isGesturing || Y.touches && Y.touches.length > 1
    }
    ,
    e.onPress = function() {
        v = !1;
        var Y = g;
        g = Zo((ot.visualViewport && ot.visualViewport.scale || 1) / m),
        U.pause(),
        Y !== g && Lc(c, g > 1.01 ? !0 : n ? !1 : "x"),
        O = _(),
        B = d(),
        y(),
        S = ws
    }
    ,
    e.onRelease = e.onGestureStart = function(Y, N) {
        if (d.offset && x(),
        !N)
            X.restart(!0);
        else {
            at.cache++;
            var k = E(), C, re;
            n && (C = _(),
            re = C + k * .05 * -Y.velocityX / .227,
            k *= gd(_, C, re, $i(c, Nn)),
            U.vars.scrollX = T(re)),
            C = d(),
            re = C + k * .05 * -Y.velocityY / .227,
            k *= gd(d, C, re, $i(c, en)),
            U.vars.scrollY = R(re),
            U.invalidate().duration(k).play(.01),
            (wr && U.vars.scrollY >= l || C >= l - 1) && Le.to({}, {
                onUpdate: H,
                duration: k
            })
        }
        o && o(Y)
    }
    ,
    e.onWheel = function() {
        U._ts && U.pause(),
        Sn() - p > 1e3 && (S = 0,
        p = Sn())
    }
    ,
    e.onChange = function(Y, N, k, C, re) {
        if (ws !== S && y(),
        N && n && _(T(C[2] === N ? O + (Y.startX - Y.x) : _() + N - C[1])),
        k) {
            d.offset && x();
            var ue = re[2] === k
              , we = ue ? B + Y.startY - Y.y : d() + k - re[1]
              , q = R(we);
            ue && we !== q && (B += q - we),
            d(q)
        }
        (k || N) && hr()
    }
    ,
    e.onEnable = function() {
        Lc(c, n ? !1 : "x"),
        je.addEventListener("refresh", H),
        on(ot, "resize", H),
        d.smooth && (d.target.style.scrollBehavior = "auto",
        d.smooth = _.smooth = !1),
        b.enable()
    }
    ,
    e.onDisable = function() {
        Lc(c, !0),
        sn(ot, "resize", H),
        je.removeEventListener("refresh", H),
        b.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    a = new Xt(e),
    a.iOS = wr,
    wr && !d() && d(1),
    wr && Le.ticker.add(Hi),
    X = a._dc,
    U = Le.to(a, {
        ease: "power4",
        paused: !0,
        inherit: !1,
        scrollX: n ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
            scrollY: og(d, d(), function() {
                return U.pause()
            })
        },
        onUpdate: hr,
        onComplete: X.vars.onComplete
    }),
    a
};
je.sort = function(i) {
    if (Mn(i))
        return rt.sort(i);
    var e = ot.pageYOffset || 0;
    return je.getAll().forEach(function(t) {
        return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + ot.innerHeight
    }),
    rt.sort(i || function(t, n) {
        return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((n.vars.containerAnimation ? 1e6 : n._sortY) + (n.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
je.observe = function(i) {
    return new Xt(i)
}
;
je.normalizeScroll = function(i) {
    if (typeof i > "u")
        return Dn;
    if (i === !0 && Dn)
        return Dn.enable();
    if (i === !1) {
        Dn && Dn.kill(),
        Dn = i;
        return
    }
    var e = i instanceof Xt ? i : ex(i);
    return Dn && Dn.target === e.target && Dn.kill(),
    Cs(e.target) && (Dn = e),
    e
}
;
je.core = {
    _getVelocityProp: ku,
    _inputObserver: ag,
    _scrollers: at,
    _proxies: Ki,
    bridge: {
        ss: function() {
            wi || Ds("scrollStart"),
            wi = Sn()
        },
        ref: function() {
            return xn
        }
    }
};
jm() && Le.registerPlugin(je);
var Ll = {
    exports: {}
};
/*!
 * headroom.js v0.12.0 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2020 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */
var tx = Ll.exports, xd;
function nx() {
    return xd || (xd = 1,
    (function(i, e) {
        (function(t, n) {
            i.exports = n()
        }
        )(tx, function() {
            function t() {
                return typeof window < "u"
            }
            function n() {
                var d = !1;
                try {
                    var _ = {
                        get passive() {
                            d = !0
                        }
                    };
                    window.addEventListener("test", _, _),
                    window.removeEventListener("test", _, _)
                } catch (g) {
                    d = !1
                }
                return d
            }
            function r() {
                return !!(t() && (function() {}
                ).bind && "classList"in document.documentElement && Object.assign && Object.keys && requestAnimationFrame)
            }
            function s(d) {
                return d.nodeType === 9
            }
            function o(d) {
                return d && d.document && s(d.document)
            }
            function a(d) {
                var _ = d.document
                  , g = _.body
                  , m = _.documentElement;
                return {
                    scrollHeight: function() {
                        return Math.max(g.scrollHeight, m.scrollHeight, g.offsetHeight, m.offsetHeight, g.clientHeight, m.clientHeight)
                    },
                    height: function() {
                        return d.innerHeight || m.clientHeight || g.clientHeight
                    },
                    scrollY: function() {
                        return d.pageYOffset !== void 0 ? d.pageYOffset : (m || g.parentNode || g).scrollTop
                    }
                }
            }
            function l(d) {
                return {
                    scrollHeight: function() {
                        return Math.max(d.scrollHeight, d.offsetHeight, d.clientHeight)
                    },
                    height: function() {
                        return Math.max(d.offsetHeight, d.clientHeight)
                    },
                    scrollY: function() {
                        return d.scrollTop
                    }
                }
            }
            function c(d) {
                return o(d) ? a(d) : l(d)
            }
            function u(d, _, g) {
                var m = n(), p, E = !1, S = c(d), v = S.scrollY(), b = {};
                function A() {
                    var y = Math.round(S.scrollY())
                      , x = S.height()
                      , P = S.scrollHeight();
                    b.scrollY = y,
                    b.lastScrollY = v,
                    b.direction = y > v ? "down" : "up",
                    b.distance = Math.abs(y - v),
                    b.isOutOfBounds = y < 0 || y + x > P,
                    b.top = y <= _.offset[b.direction],
                    b.bottom = y + x >= P,
                    b.toleranceExceeded = b.distance > _.tolerance[b.direction],
                    g(b),
                    v = y,
                    E = !1
                }
                function T() {
                    E || (E = !0,
                    p = requestAnimationFrame(A))
                }
                var R = m ? {
                    passive: !0,
                    capture: !1
                } : !1;
                return d.addEventListener("scroll", T, R),
                A(),
                {
                    destroy: function() {
                        cancelAnimationFrame(p),
                        d.removeEventListener("scroll", T, R)
                    }
                }
            }
            function f(d) {
                return d === Object(d) ? d : {
                    down: d,
                    up: d
                }
            }
            function h(d, _) {
                _ = _ || {},
                Object.assign(this, h.options, _),
                this.classes = Object.assign({}, h.options.classes, _.classes),
                this.elem = d,
                this.tolerance = f(this.tolerance),
                this.offset = f(this.offset),
                this.initialised = !1,
                this.frozen = !1
            }
            return h.prototype = {
                constructor: h,
                init: function() {
                    return h.cutsTheMustard && !this.initialised && (this.addClass("initial"),
                    this.initialised = !0,
                    setTimeout(function(d) {
                        d.scrollTracker = u(d.scroller, {
                            offset: d.offset,
                            tolerance: d.tolerance
                        }, d.update.bind(d))
                    }, 100, this)),
                    this
                },
                destroy: function() {
                    this.initialised = !1,
                    Object.keys(this.classes).forEach(this.removeClass, this),
                    this.scrollTracker.destroy()
                },
                unpin: function() {
                    (this.hasClass("pinned") || !this.hasClass("unpinned")) && (this.addClass("unpinned"),
                    this.removeClass("pinned"),
                    this.onUnpin && this.onUnpin.call(this))
                },
                pin: function() {
                    this.hasClass("unpinned") && (this.addClass("pinned"),
                    this.removeClass("unpinned"),
                    this.onPin && this.onPin.call(this))
                },
                freeze: function() {
                    this.frozen = !0,
                    this.addClass("frozen")
                },
                unfreeze: function() {
                    this.frozen = !1,
                    this.removeClass("frozen")
                },
                top: function() {
                    this.hasClass("top") || (this.addClass("top"),
                    this.removeClass("notTop"),
                    this.onTop && this.onTop.call(this))
                },
                notTop: function() {
                    this.hasClass("notTop") || (this.addClass("notTop"),
                    this.removeClass("top"),
                    this.onNotTop && this.onNotTop.call(this))
                },
                bottom: function() {
                    this.hasClass("bottom") || (this.addClass("bottom"),
                    this.removeClass("notBottom"),
                    this.onBottom && this.onBottom.call(this))
                },
                notBottom: function() {
                    this.hasClass("notBottom") || (this.addClass("notBottom"),
                    this.removeClass("bottom"),
                    this.onNotBottom && this.onNotBottom.call(this))
                },
                shouldUnpin: function(d) {
                    var _ = d.direction === "down";
                    return _ && !d.top && d.toleranceExceeded
                },
                shouldPin: function(d) {
                    var _ = d.direction === "up";
                    return _ && d.toleranceExceeded || d.top
                },
                addClass: function(d) {
                    this.elem.classList.add.apply(this.elem.classList, this.classes[d].split(" "))
                },
                removeClass: function(d) {
                    this.elem.classList.remove.apply(this.elem.classList, this.classes[d].split(" "))
                },
                hasClass: function(d) {
                    return this.classes[d].split(" ").every(function(_) {
                        return this.classList.contains(_)
                    }, this.elem)
                },
                update: function(d) {
                    d.isOutOfBounds || this.frozen !== !0 && (d.top ? this.top() : this.notTop(),
                    d.bottom ? this.bottom() : this.notBottom(),
                    this.shouldUnpin(d) ? this.unpin() : this.shouldPin(d) && this.pin())
                }
            },
            h.options = {
                tolerance: {
                    up: 0,
                    down: 0
                },
                offset: 0,
                scroller: t() ? window : null,
                classes: {
                    frozen: "headroom--frozen",
                    pinned: "headroom--pinned",
                    unpinned: "headroom--unpinned",
                    top: "headroom--top",
                    notTop: "headroom--not-top",
                    bottom: "headroom--bottom",
                    notBottom: "headroom--not-bottom",
                    initial: "headroom"
                }
            },
            h.cutsTheMustard = r(),
            h
        })
    }
    )(Ll)),
    Ll.exports
}
var ix = nx();
const rx = rc(ix)
  , el = {
    init: ({target: i, button: e, id: t}) => {
        i.setAttribute("tabindex", "-1"),
        i.setAttribute("aria-hidden", "true"),
        i.setAttribute("role", "dialog"),
        e.setAttribute("aria-controls", t),
        e.setAttribute("aria-expanded", "false")
    }
    ,
    open: ({button: i, target: e}) => {
        i.setAttribute("aria-expanded", "true"),
        e.setAttribute("aria-hidden", "false")
    }
    ,
    close: ({button: i, target: e}) => {
        i.setAttribute("aria-expanded", "false"),
        e.setAttribute("aria-hidden", "true")
    }
    ,
    reset: ({button: i, target: e}) => {
        e.removeAttribute("tabindex"),
        e.removeAttribute("aria-hidden"),
        e.removeAttribute("role"),
        e.removeAttribute("style"),
        i.removeAttribute("aria-controls"),
        i.removeAttribute("aria-expanded")
    }
};
function sx({button: i, name: e="draw", activeClass: t="is-active", closeOnBlur: n=!1}) {
    let r = !1;
    const s = i.dataset.target
      , o = document.getElementById(s);
    function a() {
        r = !0,
        i.classList.add(t),
        i.title = "Close primary menu",
        el.open({
            button: i,
            target: o
        }),
        o.focus(),
        It.emit("open:".concat(e), {
            button: i,
            target: o
        })
    }
    function l() {
        r = !1,
        i.classList.remove(t),
        i.title = "Open primary menu",
        el.close({
            button: i,
            target: o
        }),
        It.emit("close:".concat(e), {
            button: i,
            target: o
        })
    }
    function c(d) {
        d.preventDefault(),
        i.classList.contains(t) ? l() : a()
    }
    function u() {
        setTimeout( () => {
            !o.contains(document.activeElement) && document.activeElement !== i && l()
        }
        )
    }
    function f() {
        el.init({
            button: i,
            target: o,
            id: s
        }),
        i.addEventListener("click", c),
        n && o.addEventListener("blur", u, !0)
    }
    function h() {
        i.removeEventListener("click", c),
        i.classList.remove(t),
        n && o.removeEventListener("blur", u, !0),
        el.reset({
            button: i,
            target: o
        }),
        It.off("open:".concat(e)),
        It.off("close:".concat(e)),
        r = !1
    }
    return {
        button: i,
        open: a,
        close: l,
        init: f,
        destroy: h,
        ...It,
        get isOpen() {
            return r
        },
        set isOpen(d) {
            r = d
        },
        get name() {
            return e
        }
    }
}
function ox({node: i, name: e, plugins: {addEvents: t}}) {
    const n = sx({
        button: i.querySelector(".o-burger"),
        name: e,
        activeClass: "is-active"
    });
    n.init(),
    n.on("open:".concat(e), ({target: l}) => {
        i.classList.add("is-open"),
        l.classList.add("is-open"),
        It.emit("menu:open"),
        It.emit("scroll:pause")
    }
    ),
    n.on("close:".concat(e), ({target: l}) => {
        i.classList.remove("is-open"),
        l.classList.remove("is-open"),
        It.emit("menu:close"),
        It.emit("scroll:play")
    }
    ),
    It.on("barba:enter", n.close);
    const r = {
        offset: 120,
        tolerance: {
            up: 5,
            down: 0
        }
    }
      , s = new rx(i,r);
    s.init(),
    It.on("menu:open", () => s.freeze()),
    It.on("menu:close", () => s.unfreeze());
    function o() {
        n.open()
    }
    function a(l) {
        const {keyCode: c} = l;
        n.isOpen && c === 27 && n.close()
    }
    t(document.body, {
        "click [data-menu-opener-hero]": o,
        click: ({target: l}) => {
            l.id === "header" || l.closest("#header")
        }
        ,
        keydown: a
    })
}
const ax = Da(Dp)(ox);
function lx() {
    window.Formie && window.Formie.$forms && window.Formie.$forms.forEach(i => {
        i.reset(),
        i.querySelector("[data-field-error-messages]") && i.querySelector("[data-field-error-messages]").remove(),
        i.querySelectorAll(".fui-error").forEach(t => {
            t.classList.remove("fui-error"),
            t.removeAttribute("data-field-has-error")
        }
        )
    }
    )
}
function cx({node: i, plugins: {inview: e}}) {
    var n;
    if (!i)
        return () => {}
        ;
    const t = (n = document.querySelectorAll("footer video, footer media-player")) != null ? n : null;
    return t ? (e.settings = {
        rootMargin: "25% 0px",
        threshold: 0
    },
    e.observe(i, {
        enter: () => {
            t.forEach(r => {
                r.checkVisibility() && r.play()
            }
            )
        }
        ,
        exit: () => {
            t.forEach(r => r.pause())
        }
    }),
    It.emit("ExperienceController:update", [...i.querySelectorAll("[data-scene]")]),
    () => {
        e && typeof e.disconnect == "function" && e.disconnect(),
        lx()
    }
    ) : () => {}
}
const lg = Da(Lp)(cx);
function ux({plugins: {device: i}}) {
    let e = window.innerHeight * .01;
    document.documentElement.style.setProperty("--vh", "".concat(e, "px"));
    function t() {
        e = window.innerHeight * .01,
        document.documentElement.style.setProperty("--vh", "".concat(e, "px"))
    }
    t(),
    i.resize( () => t())
}
const fx = Da(z_)(ux);
var hx = "1.3.17";
function cg(i, e, t) {
    return Math.max(i, Math.min(e, t))
}
function dx(i, e, t) {
    return (1 - t) * i + t * e
}
function px(i, e, t, n) {
    return dx(i, e, 1 - Math.exp(-t * n))
}
function mx(i, e) {
    return (i % e + e) % e
}
var gx = class {
    constructor() {
        xe(this, "isRunning", !1);
        xe(this, "value", 0);
        xe(this, "from", 0);
        xe(this, "to", 0);
        xe(this, "currentTime", 0);
        xe(this, "lerp");
        xe(this, "duration");
        xe(this, "easing");
        xe(this, "onUpdate")
    }
    advance(i) {
        var t;
        if (!this.isRunning)
            return;
        let e = !1;
        if (this.duration && this.easing) {
            this.currentTime += i;
            const n = cg(0, this.currentTime / this.duration, 1);
            e = n >= 1;
            const r = e ? 1 : this.easing(n);
            this.value = this.from + (this.to - this.from) * r
        } else
            this.lerp ? (this.value = px(this.value, this.to, this.lerp * 60, i),
            Math.round(this.value) === this.to && (this.value = this.to,
            e = !0)) : (this.value = this.to,
            e = !0);
        e && this.stop(),
        (t = this.onUpdate) == null || t.call(this, this.value, e)
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(i, e, {lerp: t, duration: n, easing: r, onStart: s, onUpdate: o}) {
        this.from = this.value = i,
        this.to = e,
        this.lerp = t,
        this.duration = n,
        this.easing = r,
        this.currentTime = 0,
        this.isRunning = !0,
        s == null || s(),
        this.onUpdate = o
    }
}
;
function _x(i, e) {
    let t;
    return function(...n) {
        let r = this;
        clearTimeout(t),
        t = setTimeout( () => {
            t = void 0,
            i.apply(r, n)
        }
        , e)
    }
}
var vx = class {
    constructor(i, e, {autoResize: t=!0, debounce: n=250}={}) {
        xe(this, "width", 0);
        xe(this, "height", 0);
        xe(this, "scrollHeight", 0);
        xe(this, "scrollWidth", 0);
        xe(this, "debouncedResize");
        xe(this, "wrapperResizeObserver");
        xe(this, "contentResizeObserver");
        xe(this, "resize", () => {
            this.onWrapperResize(),
            this.onContentResize()
        }
        );
        xe(this, "onWrapperResize", () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth,
            this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
            this.height = this.wrapper.clientHeight)
        }
        );
        xe(this, "onContentResize", () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight,
            this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
            this.scrollWidth = this.wrapper.scrollWidth)
        }
        );
        this.wrapper = i,
        this.content = e,
        t && (this.debouncedResize = _x(this.resize, n),
        this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
        this.wrapperResizeObserver.observe(this.wrapper)),
        this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
        this.contentResizeObserver.observe(this.content)),
        this.resize()
    }
    destroy() {
        var i, e;
        (i = this.wrapperResizeObserver) == null || i.disconnect(),
        (e = this.contentResizeObserver) == null || e.disconnect(),
        this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
  , ug = class {
    constructor() {
        xe(this, "events", {})
    }
    emit(i, ...e) {
        var n;
        let t = this.events[i] || [];
        for (let r = 0, s = t.length; r < s; r++)
            (n = t[r]) == null || n.call(t, ...e)
    }
    on(i, e) {
        var t;
        return (t = this.events[i]) != null && t.push(e) || (this.events[i] = [e]),
        () => {
            var n;
            this.events[i] = (n = this.events[i]) == null ? void 0 : n.filter(r => e !== r)
        }
    }
    off(i, e) {
        var t;
        this.events[i] = (t = this.events[i]) == null ? void 0 : t.filter(n => e !== n)
    }
    destroy() {
        this.events = {}
    }
}
  , yd = 100 / 6
  , xr = {
    passive: !1
}
  , xx = class {
    constructor(i, e={
        wheelMultiplier: 1,
        touchMultiplier: 1
    }) {
        xe(this, "touchStart", {
            x: 0,
            y: 0
        });
        xe(this, "lastDelta", {
            x: 0,
            y: 0
        });
        xe(this, "window", {
            width: 0,
            height: 0
        });
        xe(this, "emitter", new ug);
        xe(this, "onTouchStart", i => {
            const {clientX: e, clientY: t} = i.targetTouches ? i.targetTouches[0] : i;
            this.touchStart.x = e,
            this.touchStart.y = t,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: i
            })
        }
        );
        xe(this, "onTouchMove", i => {
            const {clientX: e, clientY: t} = i.targetTouches ? i.targetTouches[0] : i
              , n = -(e - this.touchStart.x) * this.options.touchMultiplier
              , r = -(t - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = e,
            this.touchStart.y = t,
            this.lastDelta = {
                x: n,
                y: r
            },
            this.emitter.emit("scroll", {
                deltaX: n,
                deltaY: r,
                event: i
            })
        }
        );
        xe(this, "onTouchEnd", i => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: i
            })
        }
        );
        xe(this, "onWheel", i => {
            let {deltaX: e, deltaY: t, deltaMode: n} = i;
            const r = n === 1 ? yd : n === 2 ? this.window.width : 1
              , s = n === 1 ? yd : n === 2 ? this.window.height : 1;
            e *= r,
            t *= s,
            e *= this.options.wheelMultiplier,
            t *= this.options.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: e,
                deltaY: t,
                event: i
            })
        }
        );
        xe(this, "onWindowResize", () => {
            this.window = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }
        );
        this.element = i,
        this.options = e,
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, xr),
        this.element.addEventListener("touchstart", this.onTouchStart, xr),
        this.element.addEventListener("touchmove", this.onTouchMove, xr),
        this.element.addEventListener("touchend", this.onTouchEnd, xr)
    }
    on(i, e) {
        return this.emitter.on(i, e)
    }
    destroy() {
        this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, xr),
        this.element.removeEventListener("touchstart", this.onTouchStart, xr),
        this.element.removeEventListener("touchmove", this.onTouchMove, xr),
        this.element.removeEventListener("touchend", this.onTouchEnd, xr)
    }
}
  , Sd = i => Math.min(1, 1.001 - Math.pow(2, -10 * i))
  , yx = class {
    constructor({wrapper: i=window, content: e=document.documentElement, eventsTarget: t=i, smoothWheel: n=!0, syncTouch: r=!1, syncTouchLerp: s=.075, touchInertiaExponent: o=1.7, duration: a, easing: l, lerp: c=.1, infinite: u=!1, orientation: f="vertical", gestureOrientation: h=f === "horizontal" ? "both" : "vertical", touchMultiplier: d=1, wheelMultiplier: _=1, autoResize: g=!0, prevent: m, virtualScroll: p, overscroll: E=!0, autoRaf: S=!1, anchors: v=!1, autoToggle: b=!1, allowNestedScroll: A=!1, __experimental__naiveDimensions: T=!1, naiveDimensions: R=T, stopInertiaOnNavigate: y=!1}={}) {
        xe(this, "_isScrolling", !1);
        xe(this, "_isStopped", !1);
        xe(this, "_isLocked", !1);
        xe(this, "_preventNextNativeScrollEvent", !1);
        xe(this, "_resetVelocityTimeout", null);
        xe(this, "_rafId", null);
        xe(this, "isTouching");
        xe(this, "time", 0);
        xe(this, "userData", {});
        xe(this, "lastVelocity", 0);
        xe(this, "velocity", 0);
        xe(this, "direction", 0);
        xe(this, "options");
        xe(this, "targetScroll");
        xe(this, "animatedScroll");
        xe(this, "animate", new gx);
        xe(this, "emitter", new ug);
        xe(this, "dimensions");
        xe(this, "virtualScroll");
        xe(this, "onScrollEnd", i => {
            i instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && i.stopPropagation()
        }
        );
        xe(this, "dispatchScrollendEvent", () => {
            this.options.wrapper.dispatchEvent(new CustomEvent("scrollend",{
                bubbles: this.options.wrapper === window,
                detail: {
                    lenisScrollEnd: !0
                }
            }))
        }
        );
        xe(this, "onTransitionEnd", i => {
            i.propertyName.includes("overflow") && this.checkOverflow()
        }
        );
        xe(this, "onClick", i => {
            const t = i.composedPath().filter(n => n instanceof HTMLAnchorElement && n.getAttribute("href"));
            if (this.options.anchors) {
                const n = t.find(r => {
                    var s;
                    return (s = r.getAttribute("href")) == null ? void 0 : s.includes("#")
                }
                );
                if (n) {
                    const r = n.getAttribute("href");
                    if (r) {
                        const s = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0
                          , o = "#".concat(r.split("#")[1]);
                        this.scrollTo(o, s)
                    }
                }
            }
            this.options.stopInertiaOnNavigate && t.find(r => r.host === window.location.host) && this.reset()
        }
        );
        xe(this, "onPointerDown", i => {
            i.button === 1 && this.reset()
        }
        );
        xe(this, "onVirtualScroll", i => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(i) === !1)
                return;
            const {deltaX: e, deltaY: t, event: n} = i;
            if (this.emitter.emit("virtual-scroll", {
                deltaX: e,
                deltaY: t,
                event: n
            }),
            n.ctrlKey || n.lenisStopPropagation)
                return;
            const r = n.type.includes("touch")
              , s = n.type.includes("wheel");
            this.isTouching = n.type === "touchstart" || n.type === "touchmove";
            const o = e === 0 && t === 0;
            if (this.options.syncTouch && r && n.type === "touchstart" && o && !this.isStopped && !this.isLocked) {
                this.reset();
                return
            }
            const l = this.options.gestureOrientation === "vertical" && t === 0 || this.options.gestureOrientation === "horizontal" && e === 0;
            if (o || l)
                return;
            let c = n.composedPath();
            c = c.slice(0, c.indexOf(this.rootElement));
            const u = this.options.prevent;
            if (c.find(m => {
                var p, E, S;
                return m instanceof HTMLElement && (typeof u == "function" && (u == null ? void 0 : u(m)) || ((p = m.hasAttribute) == null ? void 0 : p.call(m, "data-lenis-prevent")) || r && ((E = m.hasAttribute) == null ? void 0 : E.call(m, "data-lenis-prevent-touch")) || s && ((S = m.hasAttribute) == null ? void 0 : S.call(m, "data-lenis-prevent-wheel")) || this.options.allowNestedScroll && this.checkNestedScroll(m, {
                    deltaX: e,
                    deltaY: t
                }))
            }
            ))
                return;
            if (this.isStopped || this.isLocked) {
                n.cancelable && n.preventDefault();
                return
            }
            if (!(this.options.syncTouch && r || this.options.smoothWheel && s)) {
                this.isScrolling = "native",
                this.animate.stop(),
                n.lenisStopPropagation = !0;
                return
            }
            let h = t;
            this.options.gestureOrientation === "both" ? h = Math.abs(t) > Math.abs(e) ? t : e : this.options.gestureOrientation === "horizontal" && (h = e),
            (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && t > 0 || this.animatedScroll === this.limit && t < 0)) && (n.lenisStopPropagation = !0),
            n.cancelable && n.preventDefault();
            const d = r && this.options.syncTouch
              , g = r && n.type === "touchend";
            g && (h = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)),
            this.scrollTo(this.targetScroll + h, {
                programmatic: !1,
                ...d ? {
                    lerp: g ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }
            })
        }
        );
        xe(this, "onNativeScroll", () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout),
            this._resetVelocityTimeout = null),
            this._preventNextNativeScrollEvent) {
                this._preventNextNativeScrollEvent = !1;
                return
            }
            if (this.isScrolling === !1 || this.isScrolling === "native") {
                const i = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.lastVelocity = this.velocity,
                this.velocity = this.animatedScroll - i,
                this.direction = Math.sign(this.animatedScroll - i),
                this.isStopped || (this.isScrolling = "native"),
                this.emit(),
                this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout( () => {
                    this.lastVelocity = this.velocity,
                    this.velocity = 0,
                    this.isScrolling = !1,
                    this.emit()
                }
                , 400))
            }
        }
        );
        xe(this, "raf", i => {
            const e = i - (this.time || i);
            this.time = i,
            this.animate.advance(e * .001),
            this.options.autoRaf && (this._rafId = requestAnimationFrame(this.raf))
        }
        );
        window.lenisVersion = hx,
        (!i || i === document.documentElement) && (i = window),
        typeof a == "number" && typeof l != "function" ? l = Sd : typeof l == "function" && typeof a != "number" && (a = 1),
        this.options = {
            wrapper: i,
            content: e,
            eventsTarget: t,
            smoothWheel: n,
            syncTouch: r,
            syncTouchLerp: s,
            touchInertiaExponent: o,
            duration: a,
            easing: l,
            lerp: c,
            infinite: u,
            gestureOrientation: h,
            orientation: f,
            touchMultiplier: d,
            wheelMultiplier: _,
            autoResize: g,
            prevent: m,
            virtualScroll: p,
            overscroll: E,
            autoRaf: S,
            anchors: v,
            autoToggle: b,
            allowNestedScroll: A,
            naiveDimensions: R,
            stopInertiaOnNavigate: y
        },
        this.dimensions = new vx(i,e,{
            autoResize: g
        }),
        this.updateClassName(),
        this.targetScroll = this.animatedScroll = this.actualScroll,
        this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        (this.options.anchors || this.options.stopInertiaOnNavigate) && this.options.wrapper.addEventListener("click", this.onClick, !1),
        this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
        this.virtualScroll = new xx(t,{
            touchMultiplier: d,
            wheelMultiplier: _
        }),
        this.virtualScroll.on("scroll", this.onVirtualScroll),
        this.options.autoToggle && (this.checkOverflow(),
        this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
            passive: !0
        })),
        this.options.autoRaf && (this._rafId = requestAnimationFrame(this.raf))
    }
    destroy() {
        this.emitter.destroy(),
        this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
        (this.options.anchors || this.options.stopInertiaOnNavigate) && this.options.wrapper.removeEventListener("click", this.onClick, !1),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.cleanUpClassName(),
        this._rafId && cancelAnimationFrame(this._rafId)
    }
    on(i, e) {
        return this.emitter.on(i, e)
    }
    off(i, e) {
        return this.emitter.off(i, e)
    }
    get overflow() {
        const i = this.isHorizontal ? "overflow-x" : "overflow-y";
        return getComputedStyle(this.rootElement)[i]
    }
    checkOverflow() {
        ["hidden", "clip"].includes(this.overflow) ? this.internalStop() : this.internalStart()
    }
    setScroll(i) {
        this.isHorizontal ? this.options.wrapper.scrollTo({
            left: i,
            behavior: "instant"
        }) : this.options.wrapper.scrollTo({
            top: i,
            behavior: "instant"
        })
    }
    resize() {
        this.dimensions.resize(),
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.emit()
    }
    emit() {
        this.emitter.emit("scroll", this)
    }
    reset() {
        this.isLocked = !1,
        this.isScrolling = !1,
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.lastVelocity = this.velocity = 0,
        this.animate.stop()
    }
    start() {
        if (this.isStopped) {
            if (this.options.autoToggle) {
                this.rootElement.style.removeProperty("overflow");
                return
            }
            this.internalStart()
        }
    }
    internalStart() {
        this.isStopped && (this.reset(),
        this.isStopped = !1,
        this.emit())
    }
    stop() {
        if (!this.isStopped) {
            if (this.options.autoToggle) {
                this.rootElement.style.setProperty("overflow", "clip");
                return
            }
            this.internalStop()
        }
    }
    internalStop() {
        this.isStopped || (this.reset(),
        this.isStopped = !0,
        this.emit())
    }
    scrollTo(i, {offset: e=0, immediate: t=!1, lock: n=!1, programmatic: r=!0, lerp: s=r ? this.options.lerp : void 0, duration: o=r ? this.options.duration : void 0, easing: a=r ? this.options.easing : void 0, onStart: l, onComplete: c, force: u=!1, userData: f}={}) {
        if (!((this.isStopped || this.isLocked) && !u)) {
            if (typeof i == "string" && ["top", "left", "start", "#"].includes(i))
                i = 0;
            else if (typeof i == "string" && ["bottom", "right", "end"].includes(i))
                i = this.limit;
            else {
                let h;
                if (typeof i == "string" ? (h = document.querySelector(i),
                h || (i === "#top" ? i = 0 : console.warn("Lenis: Target not found", i))) : i instanceof HTMLElement && (i != null && i.nodeType) && (h = i),
                h) {
                    if (this.options.wrapper !== window) {
                        const _ = this.rootElement.getBoundingClientRect();
                        e -= this.isHorizontal ? _.left : _.top
                    }
                    const d = h.getBoundingClientRect();
                    i = (this.isHorizontal ? d.left : d.top) + this.animatedScroll
                }
            }
            if (typeof i == "number") {
                if (i += e,
                i = Math.round(i),
                this.options.infinite) {
                    if (r) {
                        this.targetScroll = this.animatedScroll = this.scroll;
                        const h = i - this.animatedScroll;
                        h > this.limit / 2 ? i = i - this.limit : h < -this.limit / 2 && (i = i + this.limit)
                    }
                } else
                    i = cg(0, i, this.limit);
                if (i === this.targetScroll) {
                    l == null || l(this),
                    c == null || c(this);
                    return
                }
                if (this.userData = f != null ? f : {},
                t) {
                    this.animatedScroll = this.targetScroll = i,
                    this.setScroll(this.scroll),
                    this.reset(),
                    this.preventNextNativeScrollEvent(),
                    this.emit(),
                    c == null || c(this),
                    this.userData = {},
                    requestAnimationFrame( () => {
                        this.dispatchScrollendEvent()
                    }
                    );
                    return
                }
                r || (this.targetScroll = i),
                typeof o == "number" && typeof a != "function" ? a = Sd : typeof a == "function" && typeof o != "number" && (o = 1),
                this.animate.fromTo(this.animatedScroll, i, {
                    duration: o,
                    easing: a,
                    lerp: s,
                    onStart: () => {
                        n && (this.isLocked = !0),
                        this.isScrolling = "smooth",
                        l == null || l(this)
                    }
                    ,
                    onUpdate: (h, d) => {
                        this.isScrolling = "smooth",
                        this.lastVelocity = this.velocity,
                        this.velocity = h - this.animatedScroll,
                        this.direction = Math.sign(this.velocity),
                        this.animatedScroll = h,
                        this.setScroll(this.scroll),
                        r && (this.targetScroll = h),
                        d || this.emit(),
                        d && (this.reset(),
                        this.emit(),
                        c == null || c(this),
                        this.userData = {},
                        requestAnimationFrame( () => {
                            this.dispatchScrollendEvent()
                        }
                        ),
                        this.preventNextNativeScrollEvent())
                    }
                })
            }
        }
    }
    preventNextNativeScrollEvent() {
        this._preventNextNativeScrollEvent = !0,
        requestAnimationFrame( () => {
            this._preventNextNativeScrollEvent = !1
        }
        )
    }
    checkNestedScroll(i, {deltaX: e, deltaY: t}) {
        var b, A;
        const n = Date.now()
          , r = (b = i._lenis) != null ? b : i._lenis = {};
        let s, o, a, l, c, u, f, h;
        const d = this.options.gestureOrientation;
        if (n - ((A = r.time) != null ? A : 0) > 2e3) {
            r.time = Date.now();
            const T = window.getComputedStyle(i);
            r.computedStyle = T;
            const R = T.overflowX
              , y = T.overflowY;
            if (s = ["auto", "overlay", "scroll"].includes(R),
            o = ["auto", "overlay", "scroll"].includes(y),
            r.hasOverflowX = s,
            r.hasOverflowY = o,
            !s && !o || d === "vertical" && !o || d === "horizontal" && !s)
                return !1;
            c = i.scrollWidth,
            u = i.scrollHeight,
            f = i.clientWidth,
            h = i.clientHeight,
            a = c > f,
            l = u > h,
            r.isScrollableX = a,
            r.isScrollableY = l,
            r.scrollWidth = c,
            r.scrollHeight = u,
            r.clientWidth = f,
            r.clientHeight = h
        } else
            a = r.isScrollableX,
            l = r.isScrollableY,
            s = r.hasOverflowX,
            o = r.hasOverflowY,
            c = r.scrollWidth,
            u = r.scrollHeight,
            f = r.clientWidth,
            h = r.clientHeight;
        if (!s && !o || !a && !l || d === "vertical" && (!o || !l) || d === "horizontal" && (!s || !a))
            return !1;
        let _;
        if (d === "horizontal")
            _ = "x";
        else if (d === "vertical")
            _ = "y";
        else {
            const T = e !== 0
              , R = t !== 0;
            T && s && a && (_ = "x"),
            R && o && l && (_ = "y")
        }
        if (!_)
            return !1;
        let g, m, p, E, S;
        if (_ === "x")
            g = i.scrollLeft,
            m = c - f,
            p = e,
            E = s,
            S = a;
        else if (_ === "y")
            g = i.scrollTop,
            m = u - h,
            p = t,
            E = o,
            S = l;
        else
            return !1;
        return (p > 0 ? g < m : g > 0) && E && S
    }
    get rootElement() {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit() {
        return this.options.naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal() {
        return this.options.orientation === "horizontal"
    }
    get actualScroll() {
        var e, t;
        const i = this.options.wrapper;
        return this.isHorizontal ? (e = i.scrollX) != null ? e : i.scrollLeft : (t = i.scrollY) != null ? t : i.scrollTop
    }
    get scroll() {
        return this.options.infinite ? mx(this.animatedScroll, this.limit) : this.animatedScroll
    }
    get progress() {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isScrolling() {
        return this._isScrolling
    }
    set isScrolling(i) {
        this._isScrolling !== i && (this._isScrolling = i,
        this.updateClassName())
    }
    get isStopped() {
        return this._isStopped
    }
    set isStopped(i) {
        this._isStopped !== i && (this._isStopped = i,
        this.updateClassName())
    }
    get isLocked() {
        return this._isLocked
    }
    set isLocked(i) {
        this._isLocked !== i && (this._isLocked = i,
        this.updateClassName())
    }
    get isSmooth() {
        return this.isScrolling === "smooth"
    }
    get className() {
        let i = "lenis";
        return this.options.autoToggle && (i += " lenis-autoToggle"),
        this.isStopped && (i += " lenis-stopped"),
        this.isLocked && (i += " lenis-locked"),
        this.isScrolling && (i += " lenis-scrolling"),
        this.isScrolling === "smooth" && (i += " lenis-smooth"),
        i
    }
    updateClassName() {
        this.cleanUpClassName(),
        this.rootElement.className = "".concat(this.rootElement.className, " ").concat(this.className).trim()
    }
    cleanUpClassName() {
        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
    }
}
  , Sx = class {
    constructor() {
        xe(this, "_elapsed", 0);
        xe(this, "_currentTime", 0);
        xe(this, "_startTime");
        xe(this, "_lastTime");
        xe(this, "_isPlaying", !1);
        xe(this, "_deltaTime", 0)
    }
    play() {
        this._isPlaying || (this._currentTime = 0,
        this._startTime = void 0,
        this._isPlaying = !0)
    }
    pause() {
        this._isPlaying && (this._deltaTime = 0,
        this._isPlaying = !1)
    }
    reset() {
        this._elapsed = 0,
        this._deltaTime = 0,
        this._currentTime = 0,
        this._lastTime = void 0,
        this._isPlaying = !1
    }
    update(i) {
        this._isPlaying && (this._startTime || (this._startTime = i),
        this._lastTime === void 0 ? (this._lastTime = this._startTime,
        this._currentTime = 0,
        this._deltaTime = 0) : (this._lastTime = this._currentTime,
        this._currentTime = i - this._startTime,
        this._deltaTime = this._currentTime - this._lastTime,
        this._elapsed += this._deltaTime))
    }
    get time() {
        return this._elapsed
    }
    get isPlaying() {
        return this._isPlaying
    }
    get deltaTime() {
        return this._deltaTime
    }
}
  , Ex = 0;
function Mx() {
    return Ex++
}
var Tx = "1.0.0-dev.17"
  , Vi = typeof window < "u"
  , Ed = Vi && window.requestAnimationFrame
  , Md = Vi && window.cancelAnimationFrame;
Vi && (window.tempusVersion = Tx);
function fg(i) {
    const e = performance.now();
    return i(),
    performance.now() - e
}
var bx = class {
    constructor(i=Number.POSITIVE_INFINITY) {
        xe(this, "callbacks", []);
        xe(this, "fps");
        xe(this, "time", 0);
        xe(this, "lastTickDate", performance.now());
        xe(this, "framesCount", 0);
        this.fps = i
    }
    get isRelativeFps() {
        return typeof this.fps == "string" && this.fps.endsWith("%")
    }
    get maxFramesCount() {
        return this.isRelativeFps ? Math.max(1, Math.round(100 / Number(this.fps.replace("%", "")))) : 1
    }
    get executionTime() {
        return this.isRelativeFps ? 0 : 1e3 / this.fps
    }
    dispatch(i, e, t) {
        var n, r;
        for (let s = 0; s < this.callbacks.length; s++) {
            const o = fg( () => {
                var a, l, c;
                ((l = (a = this.callbacks[s]) == null ? void 0 : a.idle) != null ? l : Number.POSITIVE_INFINITY) > Jl.usage && ((c = this.callbacks[s]) == null || c.callback(i, e, t))
            }
            );
            (n = this.callbacks[s].samples) == null || n.push(o),
            this.callbacks[s].samples = (r = this.callbacks[s].samples) == null ? void 0 : r.slice(-9)
        }
    }
    raf(i, e, t) {
        if (this.time += e,
        this.isRelativeFps)
            this.framesCount === 0 && this.dispatch(i, e, t),
            this.framesCount++,
            this.framesCount %= this.maxFramesCount;
        else if (this.fps === Number.POSITIVE_INFINITY)
            this.dispatch(i, e, t);
        else if (this.time >= this.executionTime) {
            this.time = this.time % this.executionTime;
            const n = i - this.lastTickDate;
            this.lastTickDate = i,
            this.dispatch(i, n, t)
        }
    }
    add({callback: i, priority: e, label: t, idle: n}) {
        if (typeof i != "function") {
            console.warn("Tempus.add: callback is not a function");
            return
        }
        const r = Mx();
        return this.callbacks.push({
            callback: i,
            priority: e,
            uid: r,
            label: t,
            samples: [],
            idle: n
        }),
        this.callbacks.sort( (s, o) => s.priority - o.priority),
        () => this.remove(r)
    }
    remove(i) {
        this.callbacks = this.callbacks.filter( ({uid: e}) => i !== e)
    }
}
  , wx = class {
    constructor() {
        xe(this, "framerates", {});
        xe(this, "clock", new Sx);
        xe(this, "fps");
        xe(this, "usage", 0);
        xe(this, "rafId");
        xe(this, "frameCount", 0);
        xe(this, "raf", i => {
            if (!Vi)
                return;
            this.clock.update(i);
            const e = this.clock.time
              , t = this.clock.deltaTime;
            this.fps = 1e3 / t;
            const n = fg( () => {
                for (const r of Object.values(this.framerates))
                    r.raf(e, t, this.frameCount)
            }
            );
            t && (this.usage = n / t),
            this.frameCount++,
            this.rafId = requestAnimationFrame(this.raf)
        }
        );
        Vi && this.play()
    }
    restart() {
        this.rafId && cancelAnimationFrame(this.rafId),
        this.frameCount = 0;
        for (const i of Object.values(this.framerates))
            i.framesCount = 0,
            i.time = 0,
            i.lastTickDate = performance.now();
        this.clock.reset(),
        this.play()
    }
    play() {
        !Vi || this.clock.isPlaying || (this.clock.play(),
        this.rafId = requestAnimationFrame(this.raf))
    }
    pause() {
        !Vi || !this.rafId || !this.clock.isPlaying || (cancelAnimationFrame(this.rafId),
        this.rafId = void 0,
        this.clock.pause())
    }
    get isPlaying() {
        return this.clock.isPlaying
    }
    add(i, {priority: e=0, fps: t=Number.POSITIVE_INFINITY, label: n="", idle: r=Number.POSITIVE_INFINITY}={}) {
        if (Vi) {
            if (typeof t == "number" || typeof t == "string" && t.endsWith("%"))
                return this.framerates[t] || (this.framerates[t] = new bx(t)),
                this.framerates[t].add({
                    callback: i,
                    priority: e,
                    label: n,
                    idle: r
                });
            console.warn('Tempus.add: fps is not a number or a string ending with "%"')
        }
    }
    patch() {
        Vi && (window.requestAnimationFrame = (i, {priority: e=0, fps: t=Number.POSITIVE_INFINITY}={}) => {
            const n = i.toString();
            return (n.includes("requestAnimationFrame(".concat(i.name, ")")) || n.includes("requestAnimationFrame(this.".concat(i.name, ")"))) && i !== this.raf ? (i.__tempusPatched || (i.__tempusPatched = !0,
            i.__tempusUnsubscribe = this.add(i, {
                priority: e,
                fps: t,
                label: i.name
            })),
            i.__tempusUnsubscribe) : Ed(i)
        }
        ,
        window.cancelAnimationFrame = i => {
            if (typeof i == "function") {
                i == null || i();
                return
            }
            return Md(i)
        }
        )
    }
    unpatch() {
        Vi && (window.requestAnimationFrame = Ed,
        window.cancelAnimationFrame = Md)
    }
}
  , Jl = new wx;
Dt.registerPlugin(je);
function Ax() {
    let e = {
        ...{
            syncTouch: !1,
            smoothWheel: !0,
            prevent: ({el: n}) => {
                if (!n)
                    return !1;
                if (n.closest(".yii-debug-toolbar"))
                    return !0
            }
        }
    };
    const t = new yx(e);
    window.lenis = t,
    window.lenis.on("scroll", n => {
        It.emit("scroll:update", n),
        je.update()
    }
    ),
    Jl.add(window.lenis.raf, {
        priority: -1,
        fps: 60
    }),
    Dt.ticker.remove(Dt.updateRoot),
    Jl.add(n => {
        Dt.updateRoot(n / 1e3)
    }
    , {
        fps: 60
    }),
    Dt.ticker.lagSmoothing(0),
    It.on("scroll:top", () => {
        setTimeout( () => {
            window.lenis.scrollTo(0, {
                force: !0,
                immediate: !0,
                lock: !0
            })
        }
        , 100)
    }
    ),
    It.on("scroll:pause", (n=!1) => {
        n && window.lenis.scrollTo(0, {
            force: !0,
            immediate: !0,
            lock: !1
        }),
        window.lenis.stop()
    }
    ),
    It.on("scroll:play", () => {
        window.lenis.start()
    }
    ),
    It.on("scroll:toElement", n => {
        window.lenis.scrollTo(n.offsetTop - 100)
    }
    ),
    It.on("scroll:to", ({scrollY: n, immediate: r=!1, force: s=!1}) => {
        window.lenis.scrollTo(n, {
            immediate: r,
            force: s
        })
    }
    )
}
function Rx({node: i, plugins: {inview: e}}) {
    function t(n) {
        e.settings = {
            rootMargin: "40px 0px 0px 0px",
            threshold: 0
        },
        e.observe(n, {
            enter: r => {
                r.target.classList.add("opacity-100")
            }
            ,
            exit: r => {
                r.target.classList.remove("opacity-100")
            }
        })
    }
    return t(i.querySelectorAll("[data-reveal]")),
    window.addEventListener("htmx:afterSettle", n => {
        e.disconnect(),
        t(i.querySelectorAll("[data-reveal]")),
        window.removeEventListener("htmx:afterSettle", n)
    }
    ),
    () => {
        e && typeof e.disconnect == "function" && e.disconnect()
    }
}
const hh = Da(Lp)(Rx);
Dt.registerPlugin(je);
function dh({node: i}) {
    var o;
    const e = document.getElementById("barba-container")
      , t = i.querySelectorAll("[data-colors]");
    if (!e.dataset.theme)
        return () => {}
        ;
    let n = (o = JSON.parse(e.dataset.theme)) != null ? o : {
        bg: "#ffffff",
        text: "#181F1F",
        bgClass: "bg-white",
        textClass: "text-ink"
    };
    function r({bg: a, text: l, bgClass: c, textClass: u}, f=!1) {
        console.log("updateColors", {
            bg: a,
            text: l,
            bgClass: c,
            textClass: u
        }, performance.now()),
        document.body.dataset.textColor = u,
        document.body.dataset.background = c,
        f ? (document.body.style.backgroundColor = "".concat(a),
        document.body.style.color = l === "text-white" || l === "#ffffff" ? "#ffffff" : "#181F1F",
        f = !1) : (console.log("document body ", {
            bg: a,
            text: l,
            bgClass: c,
            textClass: u
        }),
        Dt.to(document.body, {
            backgroundColor: a,
            color: l === "text-white" || l === "#ffffff" ? "#ffffff" : "#181F1F",
            duration: .3,
            overwrite: !0,
            ease: "linear"
        })),
        n = {
            bg: a,
            text: l,
            bgClass: c,
            textClass: u
        }
    }
    if (t.length === 1)
        return r(n);
    function s(a) {
        a.forEach(l => {
            je.create({
                trigger: l,
                onEnter: () => {
                    console.log("onEnter", performance.now());
                    try {
                        const c = JSON.parse(l.dataset.colors || l.dataset.colorsDynamic || "{}");
                        r(c)
                    } catch (c) {
                        console.warn("Invalid data-colors JSON:", l.dataset.colors)
                    }
                }
                ,
                onEnterBack: () => {
                    console.log("onEnterBack", performance.now());
                    try {
                        const c = JSON.parse(l.dataset.colors || l.dataset.colorsDynamic || "{}");
                        r(c)
                    } catch (c) {
                        console.warn("Invalid data-colors JSON:", l.dataset.colors)
                    }
                }
                ,
                start: "top center",
                end: "bottom center",
                once: !1
            })
        }
        )
    }
    return s(i.querySelectorAll("[data-colors]")),
    je.refresh(),
    () => {
        je.getAll().forEach(a => a.kill()),
        je.refresh()
    }
}
var Ic, Td;
function Cx() {
    if (Td)
        return Ic;
    Td = 1;
    const i = {
        legend: [1, "<fieldset>", "</fieldset>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        _default: [0, "", ""]
    };
    i.td = i.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    i.option = i.optgroup = [1, '<select multiple="multiple">', "</select>"],
    i.thead = i.tbody = i.colgroup = i.caption = i.tfoot = [1, "<table>", "</table>"],
    i.polyline = i.ellipse = i.polygon = i.circle = i.text = i.line = i.path = i.rect = i.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
    function e(t, n=globalThis.document) {
        var f;
        if (typeof t != "string")
            throw new TypeError("String expected");
        const r = new RegExp("^<!--(.*?)-->$","s").exec(t);
        if (r)
            return n.createComment(r[1]);
        const s = (f = /<([\w:]+)/.exec(t)) == null ? void 0 : f[1];
        if (!s)
            return n.createTextNode(t);
        if (t = t.trim(),
        s === "body") {
            const h = n.createElement("html");
            h.innerHTML = t;
            const {lastChild: d} = h;
            return d.remove(),
            d
        }
        let[o,a,l] = Object.hasOwn(i, s) ? i[s] : i._default
          , c = n.createElement("div");
        for (c.innerHTML = a + t + l; o--; )
            c = c.lastChild;
        if (c.firstChild === c.lastChild) {
            const {firstChild: h} = c;
            return h.remove(),
            h
        }
        const u = n.createDocumentFragment();
        return u.append(...c.childNodes),
        u
    }
    return Ic = e,
    Ic
}
var Px = Cx();
const Dx = rc(Px);
function Lx({node: i, plugins: {addEvents: e, removeEvents: t}}) {
    var d, _;
    let n = !1
      , r = null;
    const s = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
        scrollY: (_ = (d = window.lenis) == null ? void 0 : d.scroll) != null ? _ : 0,
        size: {
            w: 0,
            h: 0
        }
    }
      , o = Dx('<span class="fixed z-[48] top-0 left-0 inline-block pointer-events-none" data-readmore></span>');
    document.body.appendChild(o),
    It.on("scroll:update", g => {
        s.scrollY = g.scroll
    }
    );
    const a = Dt.quickTo(o, "x", {
        duration: .2,
        ease: "power2.out"
    })
      , l = Dt.quickTo(o, "y", {
        duration: .2,
        ease: "power2.out"
    });
    function c() {
        const g = s.x - s.size.w / 2
          , m = s.y - s.size.h / 2;
        if (a(g),
        l(m),
        r && n) {
            const p = r.getBoundingClientRect();
            s.x >= p.left && s.x <= p.right && s.y >= p.top && s.y <= p.bottom || f()
        }
    }
    function u(g, m) {
        const p = m.dataset.cardSize || "";
        r = m;
        const E = m.dataset.cardHover || "Read the article";
        o.innerHTML = '<span class="o-btn o-btn--sm o-btn--read-more '.concat(p, '">').concat(E, "</span>"),
        s.size.w = o.clientWidth,
        s.size.h = o.clientHeight,
        o.classList.add("show"),
        n = !0,
        Dt.ticker.add(c)
    }
    function f() {
        n = !1,
        r = null,
        o.classList.remove("show"),
        Dt.ticker.remove(c)
    }
    function h({clientX: g, clientY: m}) {
        s.x = g,
        s.y = m
    }
    return window.matchMedia("(pointer: fine)").matches && e(document.body, {
        mousemove: h,
        "mouseover [data-card-hover]": u,
        "mouseout [data-card-hover]": f
    }),
    () => {
        t(document.body, {
            mousemove: h,
            "mouseover [data-card-hover]": u,
            "mouseout [data-card-hover]": f
        }),
        document.querySelectorAll("[data-readmore]").forEach(g => {
            g.remove()
        }
        )
    }
}
const hg = Da(Dp)(Lx);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const uc = "177"
  , Ix = 0
  , bd = 1
  , Ux = 2
  , dg = 1
  , Nx = 2
  , rr = 3
  , _r = 0
  , an = 1
  , pn = 2
  , Zi = 0
  , mo = 1
  , wd = 2
  , Ad = 3
  , Rd = 4
  , Ox = 5
  , us = 100
  , Fx = 101
  , Bx = 102
  , zx = 103
  , kx = 104
  , Hx = 200
  , Vx = 201
  , Gx = 202
  , Wx = 203
  , $u = 204
  , ju = 205
  , Xx = 206
  , qx = 207
  , Yx = 208
  , $x = 209
  , jx = 210
  , Kx = 211
  , Zx = 212
  , Jx = 213
  , Qx = 214
  , Ku = 0
  , Ql = 1
  , Zu = 2
  , bo = 3
  , Ju = 4
  , Qu = 5
  , ef = 6
  , tf = 7
  , pg = 0
  , ey = 1
  , ty = 2
  , Br = 0
  , ny = 1
  , iy = 2
  , ry = 3
  , sy = 4
  , oy = 5
  , ay = 6
  , ly = 7
  , mg = 300
  , wo = 301
  , Ao = 302
  , nf = 303
  , rf = 304
  , fc = 306
  , ec = 1e3
  , gs = 1001
  , sf = 1002
  , Fi = 1003
  , cy = 1004
  , tl = 1005
  , ln = 1006
  , Uc = 1007
  , _s = 1008
  , hi = 1009
  , gg = 1010
  , _g = 1011
  , Ra = 1012
  , ph = 1013
  , Gr = 1014
  , ur = 1015
  , Ia = 1016
  , mh = 1017
  , gh = 1018
  , Ro = 1020
  , vg = 35902
  , xg = 1021
  , yg = 1022
  , Oi = 1023
  , Ca = 1026
  , Co = 1027
  , Sg = 1028
  , _h = 1029
  , Eg = 1030
  , vh = 1031
  , xh = 1033
  , Il = 33776
  , Ul = 33777
  , Nl = 33778
  , Ol = 33779
  , of = 35840
  , af = 35841
  , lf = 35842
  , cf = 35843
  , uf = 36196
  , ff = 37492
  , hf = 37496
  , df = 37808
  , pf = 37809
  , mf = 37810
  , gf = 37811
  , _f = 37812
  , vf = 37813
  , xf = 37814
  , yf = 37815
  , Sf = 37816
  , Ef = 37817
  , Mf = 37818
  , Tf = 37819
  , bf = 37820
  , wf = 37821
  , Fl = 36492
  , Af = 36494
  , Rf = 36495
  , Mg = 36283
  , Cf = 36284
  , Pf = 36285
  , Df = 36286
  , Ua = 3200
  , uy = 3201
  , fy = 0
  , hy = 1
  , Xi = ""
  , kt = "srgb"
  , Wr = "srgb-linear"
  , tc = "linear"
  , Mt = "srgb"
  , Bs = 7680
  , Cd = 519
  , dy = 512
  , py = 513
  , my = 514
  , Tg = 515
  , gy = 516
  , _y = 517
  , vy = 518
  , xy = 519
  , Pd = 35044
  , Dd = "300 es"
  , fr = 2e3
  , nc = 2001;
class Yr {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        const n = this._listeners;
        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        const n = this._listeners;
        if (n === void 0)
            return;
        const r = n[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        const t = this._listeners;
        if (t === void 0)
            return;
        const n = t[e.type];
        if (n !== void 0) {
            e.target = this;
            const r = n.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const _n = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , Nc = Math.PI / 180
  , Lf = 180 / Math.PI;
function Na() {
    const i = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (_n[i & 255] + _n[i >> 8 & 255] + _n[i >> 16 & 255] + _n[i >> 24 & 255] + "-" + _n[e & 255] + _n[e >> 8 & 255] + "-" + _n[e >> 16 & 15 | 64] + _n[e >> 24 & 255] + "-" + _n[t & 63 | 128] + _n[t >> 8 & 255] + "-" + _n[t >> 16 & 255] + _n[t >> 24 & 255] + _n[n & 255] + _n[n >> 8 & 255] + _n[n >> 16 & 255] + _n[n >> 24 & 255]).toLowerCase()
}
function ut(i, e, t) {
    return Math.max(e, Math.min(t, i))
}
function yy(i, e) {
    return (i % e + e) % e
}
function Oc(i, e, t) {
    return (1 - t) * i + t * e
}
function Ho(i, e) {
    switch (e.constructor) {
    case Float32Array:
        return i;
    case Uint32Array:
        return i / 4294967295;
    case Uint16Array:
        return i / 65535;
    case Uint8Array:
        return i / 255;
    case Int32Array:
        return Math.max(i / 2147483647, -1);
    case Int16Array:
        return Math.max(i / 32767, -1);
    case Int8Array:
        return Math.max(i / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function zn(i, e) {
    switch (e.constructor) {
    case Float32Array:
        return i;
    case Uint32Array:
        return Math.round(i * 4294967295);
    case Uint16Array:
        return Math.round(i * 65535);
    case Uint8Array:
        return Math.round(i * 255);
    case Int32Array:
        return Math.round(i * 2147483647);
    case Int16Array:
        return Math.round(i * 32767);
    case Int8Array:
        return Math.round(i * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class lt {
    constructor(e=0, t=0) {
        lt.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6],
        this.y = r[1] * t + r[4] * n + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = ut(this.x, e.x, t.x),
        this.y = ut(this.y, e.y, t.y),
        this
    }
    clampScalar(e, t) {
        return this.x = ut(this.x, e, t),
        this.y = ut(this.y, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(ut(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(ut(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * n - o * r + e.x,
        this.y = s * r + o * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Oa {
    constructor(e=0, t=0, n=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = r
    }
    static slerpFlat(e, t, n, r, s, o, a) {
        let l = n[r + 0]
          , c = n[r + 1]
          , u = n[r + 2]
          , f = n[r + 3];
        const h = s[o + 0]
          , d = s[o + 1]
          , _ = s[o + 2]
          , g = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = u,
            e[t + 3] = f;
            return
        }
        if (a === 1) {
            e[t + 0] = h,
            e[t + 1] = d,
            e[t + 2] = _,
            e[t + 3] = g;
            return
        }
        if (f !== g || l !== h || c !== d || u !== _) {
            let m = 1 - a;
            const p = l * h + c * d + u * _ + f * g
              , E = p >= 0 ? 1 : -1
              , S = 1 - p * p;
            if (S > Number.EPSILON) {
                const b = Math.sqrt(S)
                  , A = Math.atan2(b, p * E);
                m = Math.sin(m * A) / b,
                a = Math.sin(a * A) / b
            }
            const v = a * E;
            if (l = l * m + h * v,
            c = c * m + d * v,
            u = u * m + _ * v,
            f = f * m + g * v,
            m === 1 - a) {
                const b = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
                l *= b,
                c *= b,
                u *= b,
                f *= b
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = u,
        e[t + 3] = f
    }
    static multiplyQuaternionsFlat(e, t, n, r, s, o) {
        const a = n[r]
          , l = n[r + 1]
          , c = n[r + 2]
          , u = n[r + 3]
          , f = s[o]
          , h = s[o + 1]
          , d = s[o + 2]
          , _ = s[o + 3];
        return e[t] = a * _ + u * f + l * d - c * h,
        e[t + 1] = l * _ + u * h + c * f - a * d,
        e[t + 2] = c * _ + u * d + a * h - l * f,
        e[t + 3] = u * _ - a * f - l * h - c * d,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, r) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const n = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(n / 2)
          , u = a(r / 2)
          , f = a(s / 2)
          , h = l(n / 2)
          , d = l(r / 2)
          , _ = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = h * u * f + c * d * _,
            this._y = c * d * f - h * u * _,
            this._z = c * u * _ + h * d * f,
            this._w = c * u * f - h * d * _;
            break;
        case "YXZ":
            this._x = h * u * f + c * d * _,
            this._y = c * d * f - h * u * _,
            this._z = c * u * _ - h * d * f,
            this._w = c * u * f + h * d * _;
            break;
        case "ZXY":
            this._x = h * u * f - c * d * _,
            this._y = c * d * f + h * u * _,
            this._z = c * u * _ + h * d * f,
            this._w = c * u * f - h * d * _;
            break;
        case "ZYX":
            this._x = h * u * f - c * d * _,
            this._y = c * d * f + h * u * _,
            this._z = c * u * _ - h * d * f,
            this._w = c * u * f + h * d * _;
            break;
        case "YZX":
            this._x = h * u * f + c * d * _,
            this._y = c * d * f + h * u * _,
            this._z = c * u * _ - h * d * f,
            this._w = c * u * f - h * d * _;
            break;
        case "XZY":
            this._x = h * u * f - c * d * _,
            this._y = c * d * f - h * u * _,
            this._z = c * u * _ + h * d * f,
            this._w = c * u * f + h * d * _;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , r = Math.sin(n);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , u = t[6]
          , f = t[10]
          , h = n + a + f;
        if (h > 0) {
            const d = .5 / Math.sqrt(h + 1);
            this._w = .25 / d,
            this._x = (u - l) * d,
            this._y = (s - c) * d,
            this._z = (o - r) * d
        } else if (n > a && n > f) {
            const d = 2 * Math.sqrt(1 + n - a - f);
            this._w = (u - l) / d,
            this._x = .25 * d,
            this._y = (r + o) / d,
            this._z = (s + c) / d
        } else if (a > f) {
            const d = 2 * Math.sqrt(1 + a - n - f);
            this._w = (s - c) / d,
            this._x = (r + o) / d,
            this._y = .25 * d,
            this._z = (l + u) / d
        } else {
            const d = 2 * Math.sqrt(1 + f - n - a);
            this._w = (o - r) / d,
            this._x = (s + c) / d,
            this._y = (l + u) / d,
            this._z = .25 * d
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(ut(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const r = Math.min(1, t / n);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , u = t._w;
        return this._x = n * u + o * a + r * c - s * l,
        this._y = r * u + o * l + s * a - n * c,
        this._z = s * u + o * c + n * l - r * a,
        this._w = o * u - n * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + n * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = n,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const d = 1 - t;
            return this._w = d * o + t * this._w,
            this._x = d * n + t * this._x,
            this._y = d * r + t * this._y,
            this._z = d * s + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , u = Math.atan2(c, a)
          , f = Math.sin((1 - t) * u) / c
          , h = Math.sin(t * u) / c;
        return this._w = o * f + this._w * h,
        this._x = n * f + this._x * h,
        this._y = r * f + this._y * h,
        this._z = s * f + this._z * h,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , n = Math.random()
          , r = Math.sqrt(1 - n)
          , s = Math.sqrt(n);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class Z {
    constructor(e=0, t=0, n=0) {
        Z.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(Ld.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(Ld.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * n + s[6] * r,
        this.y = s[1] * t + s[4] * n + s[7] * r,
        this.z = s[2] * t + s[5] * n + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * r - a * n)
          , u = 2 * (a * t - s * r)
          , f = 2 * (s * n - o * t);
        return this.x = t + l * c + o * f - a * u,
        this.y = n + l * u + a * c - s * f,
        this.z = r + l * f + s * u - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * r,
        this.y = s[1] * t + s[5] * n + s[9] * r,
        this.z = s[2] * t + s[6] * n + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = ut(this.x, e.x, t.x),
        this.y = ut(this.y, e.y, t.y),
        this.z = ut(this.z, e.z, t.z),
        this
    }
    clampScalar(e, t) {
        return this.x = ut(this.x, e, t),
        this.y = ut(this.y, e, t),
        this.z = ut(this.z, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(ut(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - n * l,
        this.z = n * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return Fc.copy(this).projectOnVector(e),
        this.sub(Fc)
    }
    reflect(e) {
        return this.sub(Fc.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(ut(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , r = this.z - e.z;
        return t * t + n * n + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e),
        this.y = t,
        this.z = n * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Fc = new Z
  , Ld = new Oa;
class nt {
    constructor(e, t, n, r, s, o, a, l, c) {
        nt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, r, s, o, a, l, c)
    }
    set(e, t, n, r, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e,
        u[1] = r,
        u[2] = a,
        u[3] = t,
        u[4] = s,
        u[5] = l,
        u[6] = n,
        u[7] = o,
        u[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , r = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[3]
          , l = n[6]
          , c = n[1]
          , u = n[4]
          , f = n[7]
          , h = n[2]
          , d = n[5]
          , _ = n[8]
          , g = r[0]
          , m = r[3]
          , p = r[6]
          , E = r[1]
          , S = r[4]
          , v = r[7]
          , b = r[2]
          , A = r[5]
          , T = r[8];
        return s[0] = o * g + a * E + l * b,
        s[3] = o * m + a * S + l * A,
        s[6] = o * p + a * v + l * T,
        s[1] = c * g + u * E + f * b,
        s[4] = c * m + u * S + f * A,
        s[7] = c * p + u * v + f * T,
        s[2] = h * g + d * E + _ * b,
        s[5] = h * m + d * S + _ * A,
        s[8] = h * p + d * v + _ * T,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8];
        return t * o * u - t * a * c - n * s * u + n * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , f = u * o - a * c
          , h = a * l - u * s
          , d = c * s - o * l
          , _ = t * f + n * h + r * d;
        if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const g = 1 / _;
        return e[0] = f * g,
        e[1] = (r * c - u * n) * g,
        e[2] = (a * n - r * o) * g,
        e[3] = h * g,
        e[4] = (u * t - r * l) * g,
        e[5] = (r * s - a * t) * g,
        e[6] = d * g,
        e[7] = (n * l - c * t) * g,
        e[8] = (o * t - n * s) * g,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Bc.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Bc.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Bc.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== n[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Bc = new nt;
function bg(i) {
    for (let e = i.length - 1; e >= 0; --e)
        if (i[e] >= 65535)
            return !0;
    return !1
}
function Pa(i) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", i)
}
function Sy() {
    const i = Pa("canvas");
    return i.style.display = "block",
    i
}
const Id = {};
function go(i) {
    i in Id || (Id[i] = !0,
    console.warn(i))
}
function Ey(i, e, t) {
    return new Promise(function(n, r) {
        function s() {
            switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case i.WAIT_FAILED:
                r();
                break;
            case i.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
            default:
                n()
            }
        }
        setTimeout(s, t)
    }
    )
}
function My(i) {
    const e = i.elements;
    e[2] = .5 * e[2] + .5 * e[3],
    e[6] = .5 * e[6] + .5 * e[7],
    e[10] = .5 * e[10] + .5 * e[11],
    e[14] = .5 * e[14] + .5 * e[15]
}
function Ty(i) {
    const e = i.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1,
    e[14] = -e[14]) : (e[10] = -e[10],
    e[14] = -e[14] + 1)
}
const Ud = new nt().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , Nd = new nt().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function by() {
    const i = {
        enabled: !0,
        workingColorSpace: Wr,
        spaces: {},
        convert: function(r, s, o) {
            return this.enabled === !1 || s === o || !s || !o || (this.spaces[s].transfer === Mt && (r.r = dr(r.r),
            r.g = dr(r.g),
            r.b = dr(r.b)),
            this.spaces[s].primaries !== this.spaces[o].primaries && (r.applyMatrix3(this.spaces[s].toXYZ),
            r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === Mt && (r.r = _o(r.r),
            r.g = _o(r.g),
            r.b = _o(r.b))),
            r
        },
        workingToColorSpace: function(r, s) {
            return this.convert(r, this.workingColorSpace, s)
        },
        colorSpaceToWorking: function(r, s) {
            return this.convert(r, s, this.workingColorSpace)
        },
        getPrimaries: function(r) {
            return this.spaces[r].primaries
        },
        getTransfer: function(r) {
            return r === Xi ? tc : this.spaces[r].transfer
        },
        getLuminanceCoefficients: function(r, s=this.workingColorSpace) {
            return r.fromArray(this.spaces[s].luminanceCoefficients)
        },
        define: function(r) {
            Object.assign(this.spaces, r)
        },
        _getMatrix: function(r, s, o) {
            return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(r) {
            return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(r=this.workingColorSpace) {
            return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
        },
        fromWorkingColorSpace: function(r, s) {
            return go("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
            i.workingToColorSpace(r, s)
        },
        toWorkingColorSpace: function(r, s) {
            return go("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
            i.colorSpaceToWorking(r, s)
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , t = [.2126, .7152, .0722]
      , n = [.3127, .329];
    return i.define({
        [Wr]: {
            primaries: e,
            whitePoint: n,
            transfer: tc,
            toXYZ: Ud,
            fromXYZ: Nd,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
                unpackColorSpace: kt
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: kt
            }
        },
        [kt]: {
            primaries: e,
            whitePoint: n,
            transfer: Mt,
            toXYZ: Ud,
            fromXYZ: Nd,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: kt
            }
        }
    }),
    i
}
const pt = by();
function dr(i) {
    return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4)
}
function _o(i) {
    return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055
}
let zs;
class wy {
    static getDataURL(e, t="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let n;
        if (e instanceof HTMLCanvasElement)
            n = e;
        else {
            zs === void 0 && (zs = Pa("canvas")),
            zs.width = e.width,
            zs.height = e.height;
            const r = zs.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
            n = zs
        }
        return n.toDataURL(t)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Pa("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const r = n.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = dr(s[o] / 255) * 255;
            return n.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(dr(t[n] / 255) * 255) : t[n] = dr(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let Ay = 0;
class yh {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: Ay++
        }),
        this.uuid = Na(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e) {
        const t = this.data;
        return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
        e
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(zc(r[o].image)) : s.push(zc(r[o]))
            } else
                s = zc(r);
            n.url = s
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function zc(i) {
    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? wy.getDataURL(i) : i.data ? {
        data: Array.from(i.data),
        width: i.width,
        height: i.height,
        type: i.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Ry = 0;
const kc = new Z;
class cn extends Yr {
    constructor(e=cn.DEFAULT_IMAGE, t=cn.DEFAULT_MAPPING, n=gs, r=gs, s=ln, o=_s, a=Oi, l=hi, c=cn.DEFAULT_ANISOTROPY, u=Xi) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Ry++
        }),
        this.uuid = Na(),
        this.name = "",
        this.source = new yh(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new lt(0,0),
        this.repeat = new lt(1,1),
        this.center = new lt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new nt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
        this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(kc).x
    }
    get height() {
        return this.source.getSize(kc).y
    }
    get depth() {
        return this.source.getSize(kc).z
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.isArrayTexture = e.isArrayTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    setValues(e) {
        for (const t in e) {
            const n = e[t];
            if (n === void 0) {
                console.warn("THREE.Texture.setValues(): parameter '".concat(t, "' has value of undefined."));
                continue
            }
            const r = this[t];
            if (r === void 0) {
                console.warn("THREE.Texture.setValues(): property '".concat(t, "' does not exist."));
                continue
            }
            r && n && r.isVector2 && n.isVector2 || r && n && r.isVector3 && n.isVector3 || r && n && r.isMatrix3 && n.isMatrix3 ? r.copy(n) : this[t] = n
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== mg)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case ec:
                e.x = e.x - Math.floor(e.x);
                break;
            case gs:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case sf:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case ec:
                e.y = e.y - Math.floor(e.y);
                break;
            case gs:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case sf:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
cn.DEFAULT_IMAGE = null;
cn.DEFAULT_MAPPING = mg;
cn.DEFAULT_ANISOTROPY = 1;
class Wt {
    constructor(e=0, t=0, n=0, r=1) {
        Wt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, r) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * s,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, r, s;
        const l = e.elements
          , c = l[0]
          , u = l[4]
          , f = l[8]
          , h = l[1]
          , d = l[5]
          , _ = l[9]
          , g = l[2]
          , m = l[6]
          , p = l[10];
        if (Math.abs(u - h) < .01 && Math.abs(f - g) < .01 && Math.abs(_ - m) < .01) {
            if (Math.abs(u + h) < .1 && Math.abs(f + g) < .1 && Math.abs(_ + m) < .1 && Math.abs(c + d + p - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const S = (c + 1) / 2
              , v = (d + 1) / 2
              , b = (p + 1) / 2
              , A = (u + h) / 4
              , T = (f + g) / 4
              , R = (_ + m) / 4;
            return S > v && S > b ? S < .01 ? (n = 0,
            r = .707106781,
            s = .707106781) : (n = Math.sqrt(S),
            r = A / n,
            s = T / n) : v > b ? v < .01 ? (n = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(v),
            n = A / r,
            s = R / r) : b < .01 ? (n = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(b),
            n = T / s,
            r = R / s),
            this.set(n, r, s, t),
            this
        }
        let E = Math.sqrt((m - _) * (m - _) + (f - g) * (f - g) + (h - u) * (h - u));
        return Math.abs(E) < .001 && (E = 1),
        this.x = (m - _) / E,
        this.y = (f - g) / E,
        this.z = (h - u) / E,
        this.w = Math.acos((c + d + p - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = ut(this.x, e.x, t.x),
        this.y = ut(this.y, e.y, t.y),
        this.z = ut(this.z, e.z, t.z),
        this.w = ut(this.w, e.w, t.w),
        this
    }
    clampScalar(e, t) {
        return this.x = ut(this.x, e, t),
        this.y = ut(this.y, e, t),
        this.z = ut(this.z, e, t),
        this.w = ut(this.w, e, t),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(ut(n, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Cy extends Yr {
    constructor(e=1, t=1, n={}) {
        super(),
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: ln,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, n),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = n.depth,
        this.scissor = new Wt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Wt(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: n.depth
        }
          , s = new cn(r);
        this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0,
            this.textures[a].renderTarget = this;
        this._setTextureOptions(n),
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples,
        this.multiview = n.multiview
    }
    _setTextureOptions(e={}) {
        const t = {
            minFilter: ln,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        e.mapping !== void 0 && (t.mapping = e.mapping),
        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
        e.format !== void 0 && (t.format = e.format),
        e.type !== void 0 && (t.type = e.type),
        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
        e.flipY !== void 0 && (t.flipY = e.flipY),
        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
        for (let n = 0; n < this.textures.length; n++)
            this.textures[n].setValues(t)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, t, n=1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let r = 0, s = this.textures.length; r < s; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = t,
                this.textures[r].image.depth = n,
                this.textures[r].isArrayTexture = this.textures[r].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let t = 0, n = e.textures.length; t < n; t++) {
            this.textures[t] = e.textures[t].clone(),
            this.textures[t].isRenderTargetTexture = !0,
            this.textures[t].renderTarget = this;
            const r = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new yh(r)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Bi extends Cy {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class wg extends cn {
    constructor(e=null, t=1, n=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        },
        this.magFilter = Fi,
        this.minFilter = Fi,
        this.wrapR = gs,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class Py extends cn {
    constructor(e=null, t=1, n=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        },
        this.magFilter = Fi,
        this.minFilter = Fi,
        this.wrapR = gs,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Fa {
    constructor(e=new Z(1 / 0,1 / 0,1 / 0), t=new Z(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(Ci.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(Ci.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = Ci.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const s = n.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Ci) : Ci.fromBufferAttribute(s, o),
                    Ci.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Ci);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                nl.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                nl.copy(n.boundingBox)),
                nl.applyMatrix4(e.matrixWorld),
                this.union(nl)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Ci),
        Ci.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Vo),
        il.subVectors(this.max, Vo),
        ks.subVectors(e.a, Vo),
        Hs.subVectors(e.b, Vo),
        Vs.subVectors(e.c, Vo),
        yr.subVectors(Hs, ks),
        Sr.subVectors(Vs, Hs),
        Qr.subVectors(ks, Vs);
        let t = [0, -yr.z, yr.y, 0, -Sr.z, Sr.y, 0, -Qr.z, Qr.y, yr.z, 0, -yr.x, Sr.z, 0, -Sr.x, Qr.z, 0, -Qr.x, -yr.y, yr.x, 0, -Sr.y, Sr.x, 0, -Qr.y, Qr.x, 0];
        return !Hc(t, ks, Hs, Vs, il) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Hc(t, ks, Hs, Vs, il)) ? !1 : (rl.crossVectors(yr, Sr),
        t = [rl.x, rl.y, rl.z],
        Hc(t, ks, Hs, Vs, il))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Ci).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Ci).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Qi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Qi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Qi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Qi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Qi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Qi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Qi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Qi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Qi),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e) {
        return this.min.fromArray(e.min),
        this.max.fromArray(e.max),
        this
    }
}
const Qi = [new Z, new Z, new Z, new Z, new Z, new Z, new Z, new Z]
  , Ci = new Z
  , nl = new Fa
  , ks = new Z
  , Hs = new Z
  , Vs = new Z
  , yr = new Z
  , Sr = new Z
  , Qr = new Z
  , Vo = new Z
  , il = new Z
  , rl = new Z
  , es = new Z;
function Hc(i, e, t, n, r) {
    for (let s = 0, o = i.length - 3; s <= o; s += 3) {
        es.fromArray(i, s);
        const a = r.x * Math.abs(es.x) + r.y * Math.abs(es.y) + r.z * Math.abs(es.z)
          , l = e.dot(es)
          , c = t.dot(es)
          , u = n.dot(es);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
            return !1
    }
    return !0
}
const Dy = new Fa
  , Go = new Z
  , Vc = new Z;
class Sh {
    constructor(e=new Z, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : Dy.setFromPoints(e).getCenter(n);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, n.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Go.subVectors(e, this.center);
        const t = Go.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , r = (n - this.radius) * .5;
            this.center.addScaledVector(Go, r / n),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Vc.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Go.copy(e.center).add(Vc)),
        this.expandByPoint(Go.copy(e.center).sub(Vc))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e) {
        return this.radius = e.radius,
        this.center.fromArray(e.center),
        this
    }
}
const er = new Z
  , Gc = new Z
  , sl = new Z
  , Er = new Z
  , Wc = new Z
  , ol = new Z
  , Xc = new Z;
class Ly {
    constructor(e=new Z, t=new Z(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, er)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = er.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (er.copy(this.origin).addScaledVector(this.direction, t),
        er.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, r) {
        Gc.copy(e).add(t).multiplyScalar(.5),
        sl.copy(t).sub(e).normalize(),
        Er.copy(this.origin).sub(Gc);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(sl)
          , a = Er.dot(this.direction)
          , l = -Er.dot(sl)
          , c = Er.lengthSq()
          , u = Math.abs(1 - o * o);
        let f, h, d, _;
        if (u > 0)
            if (f = o * l - a,
            h = o * a - l,
            _ = s * u,
            f >= 0)
                if (h >= -_)
                    if (h <= _) {
                        const g = 1 / u;
                        f *= g,
                        h *= g,
                        d = f * (f + o * h + 2 * a) + h * (o * f + h + 2 * l) + c
                    } else
                        h = s,
                        f = Math.max(0, -(o * h + a)),
                        d = -f * f + h * (h + 2 * l) + c;
                else
                    h = -s,
                    f = Math.max(0, -(o * h + a)),
                    d = -f * f + h * (h + 2 * l) + c;
            else
                h <= -_ ? (f = Math.max(0, -(-o * s + a)),
                h = f > 0 ? -s : Math.min(Math.max(-s, -l), s),
                d = -f * f + h * (h + 2 * l) + c) : h <= _ ? (f = 0,
                h = Math.min(Math.max(-s, -l), s),
                d = h * (h + 2 * l) + c) : (f = Math.max(0, -(o * s + a)),
                h = f > 0 ? s : Math.min(Math.max(-s, -l), s),
                d = -f * f + h * (h + 2 * l) + c);
        else
            h = o > 0 ? -s : s,
            f = Math.max(0, -(o * h + a)),
            d = -f * f + h * (h + 2 * l) + c;
        return n && n.copy(this.origin).addScaledVector(this.direction, f),
        r && r.copy(Gc).addScaledVector(sl, h),
        d
    }
    intersectSphere(e, t) {
        er.subVectors(e.center, this.origin);
        const n = er.dot(this.direction)
          , r = er.dot(er) - n * n
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = n - o
          , l = n + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, r, s, o, a, l;
        const c = 1 / this.direction.x
          , u = 1 / this.direction.y
          , f = 1 / this.direction.z
          , h = this.origin;
        return c >= 0 ? (n = (e.min.x - h.x) * c,
        r = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c,
        r = (e.min.x - h.x) * c),
        u >= 0 ? (s = (e.min.y - h.y) * u,
        o = (e.max.y - h.y) * u) : (s = (e.max.y - h.y) * u,
        o = (e.min.y - h.y) * u),
        n > o || s > r || ((s > n || isNaN(n)) && (n = s),
        (o < r || isNaN(r)) && (r = o),
        f >= 0 ? (a = (e.min.z - h.z) * f,
        l = (e.max.z - h.z) * f) : (a = (e.max.z - h.z) * f,
        l = (e.min.z - h.z) * f),
        n > l || a > r) || ((a > n || n !== n) && (n = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(n >= 0 ? n : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, er) !== null
    }
    intersectTriangle(e, t, n, r, s) {
        Wc.subVectors(t, e),
        ol.subVectors(n, e),
        Xc.crossVectors(Wc, ol);
        let o = this.direction.dot(Xc), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Er.subVectors(this.origin, e);
        const l = a * this.direction.dot(ol.crossVectors(Er, ol));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(Wc.cross(Er));
        if (c < 0 || l + c > o)
            return null;
        const u = -a * Er.dot(Xc);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class jt {
    constructor(e, t, n, r, s, o, a, l, c, u, f, h, d, _, g, m) {
        jt.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, r, s, o, a, l, c, u, f, h, d, _, g, m)
    }
    set(e, t, n, r, s, o, a, l, c, u, f, h, d, _, g, m) {
        const p = this.elements;
        return p[0] = e,
        p[4] = t,
        p[8] = n,
        p[12] = r,
        p[1] = s,
        p[5] = o,
        p[9] = a,
        p[13] = l,
        p[2] = c,
        p[6] = u,
        p[10] = f,
        p[14] = h,
        p[3] = d,
        p[7] = _,
        p[11] = g,
        p[15] = m,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new jt().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , r = 1 / Gs.setFromMatrixColumn(e, 0).length()
          , s = 1 / Gs.setFromMatrixColumn(e, 1).length()
          , o = 1 / Gs.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * r,
        t[1] = n[1] * r,
        t[2] = n[2] * r,
        t[3] = 0,
        t[4] = n[4] * s,
        t[5] = n[5] * s,
        t[6] = n[6] * s,
        t[7] = 0,
        t[8] = n[8] * o,
        t[9] = n[9] * o,
        t[10] = n[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(n)
          , a = Math.sin(n)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , u = Math.cos(s)
          , f = Math.sin(s);
        if (e.order === "XYZ") {
            const h = o * u
              , d = o * f
              , _ = a * u
              , g = a * f;
            t[0] = l * u,
            t[4] = -l * f,
            t[8] = c,
            t[1] = d + _ * c,
            t[5] = h - g * c,
            t[9] = -a * l,
            t[2] = g - h * c,
            t[6] = _ + d * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const h = l * u
              , d = l * f
              , _ = c * u
              , g = c * f;
            t[0] = h + g * a,
            t[4] = _ * a - d,
            t[8] = o * c,
            t[1] = o * f,
            t[5] = o * u,
            t[9] = -a,
            t[2] = d * a - _,
            t[6] = g + h * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const h = l * u
              , d = l * f
              , _ = c * u
              , g = c * f;
            t[0] = h - g * a,
            t[4] = -o * f,
            t[8] = _ + d * a,
            t[1] = d + _ * a,
            t[5] = o * u,
            t[9] = g - h * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const h = o * u
              , d = o * f
              , _ = a * u
              , g = a * f;
            t[0] = l * u,
            t[4] = _ * c - d,
            t[8] = h * c + g,
            t[1] = l * f,
            t[5] = g * c + h,
            t[9] = d * c - _,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const h = o * l
              , d = o * c
              , _ = a * l
              , g = a * c;
            t[0] = l * u,
            t[4] = g - h * f,
            t[8] = _ * f + d,
            t[1] = f,
            t[5] = o * u,
            t[9] = -a * u,
            t[2] = -c * u,
            t[6] = d * f + _,
            t[10] = h - g * f
        } else if (e.order === "XZY") {
            const h = o * l
              , d = o * c
              , _ = a * l
              , g = a * c;
            t[0] = l * u,
            t[4] = -f,
            t[8] = c * u,
            t[1] = h * f + g,
            t[5] = o * u,
            t[9] = d * f - _,
            t[2] = _ * f - d,
            t[6] = a * u,
            t[10] = g * f + h
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(Iy, e, Uy)
    }
    lookAt(e, t, n) {
        const r = this.elements;
        return Jn.subVectors(e, t),
        Jn.lengthSq() === 0 && (Jn.z = 1),
        Jn.normalize(),
        Mr.crossVectors(n, Jn),
        Mr.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Jn.x += 1e-4 : Jn.z += 1e-4,
        Jn.normalize(),
        Mr.crossVectors(n, Jn)),
        Mr.normalize(),
        al.crossVectors(Jn, Mr),
        r[0] = Mr.x,
        r[4] = al.x,
        r[8] = Jn.x,
        r[1] = Mr.y,
        r[5] = al.y,
        r[9] = Jn.y,
        r[2] = Mr.z,
        r[6] = al.z,
        r[10] = Jn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , r = t.elements
          , s = this.elements
          , o = n[0]
          , a = n[4]
          , l = n[8]
          , c = n[12]
          , u = n[1]
          , f = n[5]
          , h = n[9]
          , d = n[13]
          , _ = n[2]
          , g = n[6]
          , m = n[10]
          , p = n[14]
          , E = n[3]
          , S = n[7]
          , v = n[11]
          , b = n[15]
          , A = r[0]
          , T = r[4]
          , R = r[8]
          , y = r[12]
          , x = r[1]
          , P = r[5]
          , U = r[9]
          , O = r[13]
          , B = r[2]
          , X = r[6]
          , H = r[10]
          , Y = r[14]
          , N = r[3]
          , k = r[7]
          , C = r[11]
          , re = r[15];
        return s[0] = o * A + a * x + l * B + c * N,
        s[4] = o * T + a * P + l * X + c * k,
        s[8] = o * R + a * U + l * H + c * C,
        s[12] = o * y + a * O + l * Y + c * re,
        s[1] = u * A + f * x + h * B + d * N,
        s[5] = u * T + f * P + h * X + d * k,
        s[9] = u * R + f * U + h * H + d * C,
        s[13] = u * y + f * O + h * Y + d * re,
        s[2] = _ * A + g * x + m * B + p * N,
        s[6] = _ * T + g * P + m * X + p * k,
        s[10] = _ * R + g * U + m * H + p * C,
        s[14] = _ * y + g * O + m * Y + p * re,
        s[3] = E * A + S * x + v * B + b * N,
        s[7] = E * T + S * P + v * X + b * k,
        s[11] = E * R + S * U + v * H + b * C,
        s[15] = E * y + S * O + v * Y + b * re,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , u = e[2]
          , f = e[6]
          , h = e[10]
          , d = e[14]
          , _ = e[3]
          , g = e[7]
          , m = e[11]
          , p = e[15];
        return _ * (+s * l * f - r * c * f - s * a * h + n * c * h + r * a * d - n * l * d) + g * (+t * l * d - t * c * h + s * o * h - r * o * d + r * c * u - s * l * u) + m * (+t * c * f - t * a * d - s * o * f + n * o * d + s * a * u - n * c * u) + p * (-r * a * u - t * l * f + t * a * h + r * o * f - n * o * h + n * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , f = e[9]
          , h = e[10]
          , d = e[11]
          , _ = e[12]
          , g = e[13]
          , m = e[14]
          , p = e[15]
          , E = f * m * c - g * h * c + g * l * d - a * m * d - f * l * p + a * h * p
          , S = _ * h * c - u * m * c - _ * l * d + o * m * d + u * l * p - o * h * p
          , v = u * g * c - _ * f * c + _ * a * d - o * g * d - u * a * p + o * f * p
          , b = _ * f * l - u * g * l - _ * a * h + o * g * h + u * a * m - o * f * m
          , A = t * E + n * S + r * v + s * b;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / A;
        return e[0] = E * T,
        e[1] = (g * h * s - f * m * s - g * r * d + n * m * d + f * r * p - n * h * p) * T,
        e[2] = (a * m * s - g * l * s + g * r * c - n * m * c - a * r * p + n * l * p) * T,
        e[3] = (f * l * s - a * h * s - f * r * c + n * h * c + a * r * d - n * l * d) * T,
        e[4] = S * T,
        e[5] = (u * m * s - _ * h * s + _ * r * d - t * m * d - u * r * p + t * h * p) * T,
        e[6] = (_ * l * s - o * m * s - _ * r * c + t * m * c + o * r * p - t * l * p) * T,
        e[7] = (o * h * s - u * l * s + u * r * c - t * h * c - o * r * d + t * l * d) * T,
        e[8] = v * T,
        e[9] = (_ * f * s - u * g * s - _ * n * d + t * g * d + u * n * p - t * f * p) * T,
        e[10] = (o * g * s - _ * a * s + _ * n * c - t * g * c - o * n * p + t * a * p) * T,
        e[11] = (u * a * s - o * f * s - u * n * c + t * f * c + o * n * d - t * a * d) * T,
        e[12] = b * T,
        e[13] = (u * g * r - _ * f * r + _ * n * h - t * g * h - u * n * m + t * f * m) * T,
        e[14] = (_ * a * r - o * g * r - _ * n * l + t * g * l + o * n * m - t * a * m) * T,
        e[15] = (o * f * r - u * a * r + u * n * l - t * f * l - o * n * h + t * a * h) * T,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= n,
        t[4] *= r,
        t[8] *= s,
        t[1] *= n,
        t[5] *= r,
        t[9] *= s,
        t[2] *= n,
        t[6] *= r,
        t[10] *= s,
        t[3] *= n,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, r))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - n
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , u = s * a;
        return this.set(c * o + n, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + n, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, r, s, o) {
        return this.set(1, n, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , u = o + o
          , f = a + a
          , h = s * c
          , d = s * u
          , _ = s * f
          , g = o * u
          , m = o * f
          , p = a * f
          , E = l * c
          , S = l * u
          , v = l * f
          , b = n.x
          , A = n.y
          , T = n.z;
        return r[0] = (1 - (g + p)) * b,
        r[1] = (d + v) * b,
        r[2] = (_ - S) * b,
        r[3] = 0,
        r[4] = (d - v) * A,
        r[5] = (1 - (h + p)) * A,
        r[6] = (m + E) * A,
        r[7] = 0,
        r[8] = (_ + S) * T,
        r[9] = (m - E) * T,
        r[10] = (1 - (h + g)) * T,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, n) {
        const r = this.elements;
        let s = Gs.set(r[0], r[1], r[2]).length();
        const o = Gs.set(r[4], r[5], r[6]).length()
          , a = Gs.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        Pi.copy(this);
        const c = 1 / s
          , u = 1 / o
          , f = 1 / a;
        return Pi.elements[0] *= c,
        Pi.elements[1] *= c,
        Pi.elements[2] *= c,
        Pi.elements[4] *= u,
        Pi.elements[5] *= u,
        Pi.elements[6] *= u,
        Pi.elements[8] *= f,
        Pi.elements[9] *= f,
        Pi.elements[10] *= f,
        t.setFromRotationMatrix(Pi),
        n.x = s,
        n.y = o,
        n.z = a,
        this
    }
    makePerspective(e, t, n, r, s, o, a=fr) {
        const l = this.elements
          , c = 2 * s / (t - e)
          , u = 2 * s / (n - r)
          , f = (t + e) / (t - e)
          , h = (n + r) / (n - r);
        let d, _;
        if (a === fr)
            d = -(o + s) / (o - s),
            _ = -2 * o * s / (o - s);
        else if (a === nc)
            d = -o / (o - s),
            _ = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = f,
        l[12] = 0,
        l[1] = 0,
        l[5] = u,
        l[9] = h,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = d,
        l[14] = _,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, n, r, s, o, a=fr) {
        const l = this.elements
          , c = 1 / (t - e)
          , u = 1 / (n - r)
          , f = 1 / (o - s)
          , h = (t + e) * c
          , d = (n + r) * u;
        let _, g;
        if (a === fr)
            _ = (o + s) * f,
            g = -2 * f;
        else if (a === nc)
            _ = s * f,
            g = -1 * f;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -h,
        l[1] = 0,
        l[5] = 2 * u,
        l[9] = 0,
        l[13] = -d,
        l[2] = 0,
        l[6] = 0,
        l[10] = g,
        l[14] = -_,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== n[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const Gs = new Z
  , Pi = new jt
  , Iy = new Z(0,0,0)
  , Uy = new Z(1,1,1)
  , Mr = new Z
  , al = new Z
  , Jn = new Z
  , Od = new jt
  , Fd = new Oa;
class vr {
    constructor(e=0, t=0, n=0, r=vr.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , u = r[9]
          , f = r[2]
          , h = r[6]
          , d = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(ut(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, d),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(h, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-ut(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, d),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-f, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(ut(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(-f, d),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-ut(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._x = Math.atan2(h, d),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(ut(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
            this._y = Math.atan2(-f, s)) : (this._x = 0,
            this._y = Math.atan2(a, d));
            break;
        case "XZY":
            this._z = Math.asin(-ut(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, d),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return Od.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Od, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return Fd.setFromEuler(this),
        this.setFromQuaternion(Fd, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
vr.DEFAULT_ORDER = "XYZ";
class Ag {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let Ny = 0;
const Bd = new Z
  , Ws = new Oa
  , tr = new jt
  , ll = new Z
  , Wo = new Z
  , Oy = new Z
  , Fy = new Oa
  , zd = new Z(1,0,0)
  , kd = new Z(0,1,0)
  , Hd = new Z(0,0,1)
  , Vd = {
    type: "added"
}
  , By = {
    type: "removed"
}
  , Xs = {
    type: "childadded",
    child: null
}
  , qc = {
    type: "childremoved",
    child: null
};
class ci extends Yr {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: Ny++
        }),
        this.uuid = Na(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = ci.DEFAULT_UP.clone();
        const e = new Z
          , t = new vr
          , n = new Oa
          , r = new Z(1,1,1);
        function s() {
            n.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(s),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new jt
            },
            normalMatrix: {
                value: new nt
            }
        }),
        this.matrix = new jt,
        this.matrixWorld = new jt,
        this.matrixAutoUpdate = ci.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = ci.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Ag,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Ws.setFromAxisAngle(e, t),
        this.quaternion.multiply(Ws),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Ws.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Ws),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(zd, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(kd, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Hd, e)
    }
    translateOnAxis(e, t) {
        return Bd.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Bd.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(zd, e)
    }
    translateY(e) {
        return this.translateOnAxis(kd, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Hd, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(tr.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? ll.copy(e) : ll.set(e, t, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        Wo.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? tr.lookAt(Wo, ll, this.up) : tr.lookAt(ll, Wo, this.up),
        this.quaternion.setFromRotationMatrix(tr),
        r && (tr.extractRotation(r.matrixWorld),
        Ws.setFromRotationMatrix(tr),
        this.quaternion.premultiply(Ws.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Vd),
        Xs.child = e,
        this.dispatchEvent(Xs),
        Xs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(By),
        qc.child = e,
        this.dispatchEvent(qc),
        qc.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        tr.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        tr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(tr),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(Vd),
        Xs.child = e,
        this.dispatchEvent(Xs),
        Xs.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, r = this.children.length; n < r; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Wo, e, Oy),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Wo, Fy, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++)
                r[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.geometryInfo = this._geometryInfo.map(a => ({
            ...a,
            boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
            boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0
        })),
        r.instanceInfo = this._instanceInfo.map(a => ({
            ...a
        })),
        r.availableInstanceIds = this._availableInstanceIds.slice(),
        r.availableGeometryIds = this._availableGeometryIds.slice(),
        r.nextIndexStart = this._nextIndexStart,
        r.nextVertexStart = this._nextVertexStart,
        r.geometryCount = this._geometryCount,
        r.maxInstanceCount = this._maxInstanceCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        r.indirectTexture = this._indirectTexture.toJSON(e),
        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (r.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null && (r.boundingBox = this.boundingBox.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const f = l[c];
                        s(e.shapes, f)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , u = o(e.images)
              , f = o(e.shapes)
              , h = o(e.skeletons)
              , d = o(e.animations)
              , _ = o(e.nodes);
            a.length > 0 && (n.geometries = a),
            l.length > 0 && (n.materials = l),
            c.length > 0 && (n.textures = c),
            u.length > 0 && (n.images = u),
            f.length > 0 && (n.shapes = f),
            h.length > 0 && (n.skeletons = h),
            d.length > 0 && (n.animations = d),
            _.length > 0 && (n.nodes = _)
        }
        return n.object = r,
        n;
        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const r = e.children[n];
                this.add(r.clone())
            }
        return this
    }
}
ci.DEFAULT_UP = new Z(0,1,0);
ci.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ci.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Di = new Z
  , nr = new Z
  , Yc = new Z
  , ir = new Z
  , qs = new Z
  , Ys = new Z
  , Gd = new Z
  , $c = new Z
  , jc = new Z
  , Kc = new Z
  , Zc = new Wt
  , Jc = new Wt
  , Qc = new Wt;
class Ni {
    constructor(e=new Z, t=new Z, n=new Z) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, r) {
        r.subVectors(n, t),
        Di.subVectors(e, t),
        r.cross(Di);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, r, s) {
        Di.subVectors(r, t),
        nr.subVectors(n, t),
        Yc.subVectors(e, t);
        const o = Di.dot(Di)
          , a = Di.dot(nr)
          , l = Di.dot(Yc)
          , c = nr.dot(nr)
          , u = nr.dot(Yc)
          , f = o * c - a * a;
        if (f === 0)
            return s.set(0, 0, 0),
            null;
        const h = 1 / f
          , d = (c * l - a * u) * h
          , _ = (o * u - a * l) * h;
        return s.set(1 - d - _, _, d)
    }
    static containsPoint(e, t, n, r) {
        return this.getBarycoord(e, t, n, r, ir) === null ? !1 : ir.x >= 0 && ir.y >= 0 && ir.x + ir.y <= 1
    }
    static getInterpolation(e, t, n, r, s, o, a, l) {
        return this.getBarycoord(e, t, n, r, ir) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(s, ir.x),
        l.addScaledVector(o, ir.y),
        l.addScaledVector(a, ir.z),
        l)
    }
    static getInterpolatedAttribute(e, t, n, r, s, o) {
        return Zc.setScalar(0),
        Jc.setScalar(0),
        Qc.setScalar(0),
        Zc.fromBufferAttribute(e, t),
        Jc.fromBufferAttribute(e, n),
        Qc.fromBufferAttribute(e, r),
        o.setScalar(0),
        o.addScaledVector(Zc, s.x),
        o.addScaledVector(Jc, s.y),
        o.addScaledVector(Qc, s.z),
        o
    }
    static isFrontFacing(e, t, n, r) {
        return Di.subVectors(n, t),
        nr.subVectors(e, t),
        Di.cross(nr).dot(r) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, n, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Di.subVectors(this.c, this.b),
        nr.subVectors(this.a, this.b),
        Di.cross(nr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Ni.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Ni.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, r, s) {
        return Ni.getInterpolation(e, this.a, this.b, this.c, t, n, r, s)
    }
    containsPoint(e) {
        return Ni.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Ni.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        qs.subVectors(r, n),
        Ys.subVectors(s, n),
        $c.subVectors(e, n);
        const l = qs.dot($c)
          , c = Ys.dot($c);
        if (l <= 0 && c <= 0)
            return t.copy(n);
        jc.subVectors(e, r);
        const u = qs.dot(jc)
          , f = Ys.dot(jc);
        if (u >= 0 && f <= u)
            return t.copy(r);
        const h = l * f - u * c;
        if (h <= 0 && l >= 0 && u <= 0)
            return o = l / (l - u),
            t.copy(n).addScaledVector(qs, o);
        Kc.subVectors(e, s);
        const d = qs.dot(Kc)
          , _ = Ys.dot(Kc);
        if (_ >= 0 && d <= _)
            return t.copy(s);
        const g = d * c - l * _;
        if (g <= 0 && c >= 0 && _ <= 0)
            return a = c / (c - _),
            t.copy(n).addScaledVector(Ys, a);
        const m = u * _ - d * f;
        if (m <= 0 && f - u >= 0 && d - _ >= 0)
            return Gd.subVectors(s, r),
            a = (f - u) / (f - u + (d - _)),
            t.copy(r).addScaledVector(Gd, a);
        const p = 1 / (m + g + h);
        return o = g * p,
        a = h * p,
        t.copy(n).addScaledVector(qs, o).addScaledVector(Ys, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Rg = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Tr = {
    h: 0,
    s: 0,
    l: 0
}
  , cl = {
    h: 0,
    s: 0,
    l: 0
};
function eu(i, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i
}
class St {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=kt) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        pt.colorSpaceToWorking(this, t),
        this
    }
    setRGB(e, t, n, r=pt.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        pt.colorSpaceToWorking(this, r),
        this
    }
    setHSL(e, t, n, r=pt.workingColorSpace) {
        if (e = yy(e, 1),
        t = ut(t, 0, 1),
        n = ut(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + t) : n + t - n * t
              , o = 2 * n - s;
            this.r = eu(o, s, e + 1 / 3),
            this.g = eu(o, s, e),
            this.b = eu(o, s, e - 1 / 3)
        }
        return pt.colorSpaceToWorking(this, r),
        this
    }
    setStyle(e, t=kt) {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=kt) {
        const n = Rg[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = dr(e.r),
        this.g = dr(e.g),
        this.b = dr(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = _o(e.r),
        this.g = _o(e.g),
        this.b = _o(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=kt) {
        return pt.workingToColorSpace(vn.copy(this), e),
        Math.round(ut(vn.r * 255, 0, 255)) * 65536 + Math.round(ut(vn.g * 255, 0, 255)) * 256 + Math.round(ut(vn.b * 255, 0, 255))
    }
    getHexString(e=kt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=pt.workingColorSpace) {
        pt.workingToColorSpace(vn.copy(this), t);
        const n = vn.r
          , r = vn.g
          , s = vn.b
          , o = Math.max(n, r, s)
          , a = Math.min(n, r, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const f = o - a;
            switch (c = u <= .5 ? f / (o + a) : f / (2 - o - a),
            o) {
            case n:
                l = (r - s) / f + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - n) / f + 2;
                break;
            case s:
                l = (n - r) / f + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = u,
        e
    }
    getRGB(e, t=pt.workingColorSpace) {
        return pt.workingToColorSpace(vn.copy(this), t),
        e.r = vn.r,
        e.g = vn.g,
        e.b = vn.b,
        e
    }
    getStyle(e=kt) {
        pt.workingToColorSpace(vn.copy(this), e);
        const t = vn.r
          , n = vn.g
          , r = vn.b;
        return e !== kt ? "color(".concat(e, " ").concat(t.toFixed(3), " ").concat(n.toFixed(3), " ").concat(r.toFixed(3), ")") : "rgb(".concat(Math.round(t * 255), ",").concat(Math.round(n * 255), ",").concat(Math.round(r * 255), ")")
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Tr),
        this.setHSL(Tr.h + e, Tr.s + t, Tr.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Tr),
        e.getHSL(cl);
        const n = Oc(Tr.h, cl.h, t)
          , r = Oc(Tr.s, cl.s, t)
          , s = Oc(Tr.l, cl.l, t);
        return this.setHSL(n, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * n + s[6] * r,
        this.g = s[1] * t + s[4] * n + s[7] * r,
        this.b = s[2] * t + s[5] * n + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const vn = new St;
St.NAMES = Rg;
let zy = 0;
class Lo extends Yr {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: zy++
        }),
        this.uuid = Na(),
        this.name = "",
        this.type = "Material",
        this.blending = mo,
        this.side = _r,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = $u,
        this.blendDst = ju,
        this.blendEquation = us,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new St(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = bo,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Cd,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Bs,
        this.stencilZFail = Bs,
        this.stencilZPass = Bs,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn("THREE.Material: parameter '".concat(t, "' has value of undefined."));
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn("THREE.Material: '".concat(t, "' is not a property of THREE.").concat(this.type, "."));
                    continue
                }
                r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== mo && (n.blending = this.blending),
        this.side !== _r && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== $u && (n.blendSrc = this.blendSrc),
        this.blendDst !== ju && (n.blendDst = this.blendDst),
        this.blendEquation !== us && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== bo && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Cd && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Bs && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== Bs && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Bs && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (n.textures = s),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const r = t.length;
            n = new Array(r);
            for (let s = 0; s !== r; ++s)
                n[s] = t[s].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class oo extends Lo {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new St(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new vr,
        this.combine = pg,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const qt = new Z
  , ul = new lt;
let ky = 0;
class Ai {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: ky++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = Pd,
        this.updateRanges = [],
        this.gpuType = ur,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[n + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                ul.fromBufferAttribute(this, t),
                ul.applyMatrix3(e),
                this.setXY(t, ul.x, ul.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                qt.fromBufferAttribute(this, t),
                qt.applyMatrix3(e),
                this.setXYZ(t, qt.x, qt.y, qt.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            qt.fromBufferAttribute(this, t),
            qt.applyMatrix4(e),
            this.setXYZ(t, qt.x, qt.y, qt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            qt.fromBufferAttribute(this, t),
            qt.applyNormalMatrix(e),
            this.setXYZ(t, qt.x, qt.y, qt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            qt.fromBufferAttribute(this, t),
            qt.transformDirection(e),
            this.setXYZ(t, qt.x, qt.y, qt.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = Ho(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = zn(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Ho(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = zn(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Ho(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = zn(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Ho(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = zn(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Ho(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = zn(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = zn(t, this.array),
        n = zn(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, r) {
        return e *= this.itemSize,
        this.normalized && (t = zn(t, this.array),
        n = zn(n, this.array),
        r = zn(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, n, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = zn(t, this.array),
        n = zn(n, this.array),
        r = zn(r, this.array),
        s = zn(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Pd && (e.usage = this.usage),
        e
    }
}
class Cg extends Ai {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Pg extends Ai {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class As extends Ai {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let Hy = 0;
const gi = new jt
  , tu = new ci
  , $s = new Z
  , Qn = new Fa
  , Xo = new Fa
  , rn = new Z;
class $r extends Yr {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: Hy++
        }),
        this.uuid = Na(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (bg(e) ? Pg : Cg)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new nt().getNormalMatrix(e);
            n.applyNormalMatrix(s),
            n.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return gi.makeRotationFromQuaternion(e),
        this.applyMatrix4(gi),
        this
    }
    rotateX(e) {
        return gi.makeRotationX(e),
        this.applyMatrix4(gi),
        this
    }
    rotateY(e) {
        return gi.makeRotationY(e),
        this.applyMatrix4(gi),
        this
    }
    rotateZ(e) {
        return gi.makeRotationZ(e),
        this.applyMatrix4(gi),
        this
    }
    translate(e, t, n) {
        return gi.makeTranslation(e, t, n),
        this.applyMatrix4(gi),
        this
    }
    scale(e, t, n) {
        return gi.makeScale(e, t, n),
        this.applyMatrix4(gi),
        this
    }
    lookAt(e) {
        return tu.lookAt(e),
        tu.updateMatrix(),
        this.applyMatrix4(tu.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter($s).negate(),
        this.translate($s.x, $s.y, $s.z),
        this
    }
    setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
            const n = [];
            for (let r = 0, s = e.length; r < s; r++) {
                const o = e[r];
                n.push(o.x, o.y, o.z || 0)
            }
            this.setAttribute("position", new As(n,3))
        } else {
            const n = Math.min(e.length, t.count);
            for (let r = 0; r < n; r++) {
                const s = e[r];
                t.setXYZ(r, s.x, s.y, s.z || 0)
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Fa);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new Z(-1 / 0,-1 / 0,-1 / 0), new Z(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, r = t.length; n < r; n++) {
                    const s = t[n];
                    Qn.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (rn.addVectors(this.boundingBox.min, Qn.min),
                    this.boundingBox.expandByPoint(rn),
                    rn.addVectors(this.boundingBox.max, Qn.max),
                    this.boundingBox.expandByPoint(rn)) : (this.boundingBox.expandByPoint(Qn.min),
                    this.boundingBox.expandByPoint(Qn.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sh);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new Z, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (Qn.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Xo.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (rn.addVectors(Qn.min, Xo.min),
                    Qn.expandByPoint(rn),
                    rn.addVectors(Qn.max, Xo.max),
                    Qn.expandByPoint(rn)) : (Qn.expandByPoint(Xo.min),
                    Qn.expandByPoint(Xo.max))
                }
            Qn.getCenter(n);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                rn.fromBufferAttribute(e, s),
                r = Math.max(r, n.distanceToSquared(rn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++)
                        rn.fromBufferAttribute(a, c),
                        l && ($s.fromBufferAttribute(e, c),
                        rn.add($s)),
                        r = Math.max(r, n.distanceToSquared(rn))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position
          , r = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ai(new Float32Array(4 * n.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let R = 0; R < n.count; R++)
            a[R] = new Z,
            l[R] = new Z;
        const c = new Z
          , u = new Z
          , f = new Z
          , h = new lt
          , d = new lt
          , _ = new lt
          , g = new Z
          , m = new Z;
        function p(R, y, x) {
            c.fromBufferAttribute(n, R),
            u.fromBufferAttribute(n, y),
            f.fromBufferAttribute(n, x),
            h.fromBufferAttribute(s, R),
            d.fromBufferAttribute(s, y),
            _.fromBufferAttribute(s, x),
            u.sub(c),
            f.sub(c),
            d.sub(h),
            _.sub(h);
            const P = 1 / (d.x * _.y - _.x * d.y);
            isFinite(P) && (g.copy(u).multiplyScalar(_.y).addScaledVector(f, -d.y).multiplyScalar(P),
            m.copy(f).multiplyScalar(d.x).addScaledVector(u, -_.x).multiplyScalar(P),
            a[R].add(g),
            a[y].add(g),
            a[x].add(g),
            l[R].add(m),
            l[y].add(m),
            l[x].add(m))
        }
        let E = this.groups;
        E.length === 0 && (E = [{
            start: 0,
            count: e.count
        }]);
        for (let R = 0, y = E.length; R < y; ++R) {
            const x = E[R]
              , P = x.start
              , U = x.count;
            for (let O = P, B = P + U; O < B; O += 3)
                p(e.getX(O + 0), e.getX(O + 1), e.getX(O + 2))
        }
        const S = new Z
          , v = new Z
          , b = new Z
          , A = new Z;
        function T(R) {
            b.fromBufferAttribute(r, R),
            A.copy(b);
            const y = a[R];
            S.copy(y),
            S.sub(b.multiplyScalar(b.dot(y))).normalize(),
            v.crossVectors(A, y);
            const P = v.dot(l[R]) < 0 ? -1 : 1;
            o.setXYZW(R, S.x, S.y, S.z, P)
        }
        for (let R = 0, y = E.length; R < y; ++R) {
            const x = E[R]
              , P = x.start
              , U = x.count;
            for (let O = P, B = P + U; O < B; O += 3)
                T(e.getX(O + 0)),
                T(e.getX(O + 1)),
                T(e.getX(O + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new Ai(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let h = 0, d = n.count; h < d; h++)
                    n.setXYZ(h, 0, 0, 0);
            const r = new Z
              , s = new Z
              , o = new Z
              , a = new Z
              , l = new Z
              , c = new Z
              , u = new Z
              , f = new Z;
            if (e)
                for (let h = 0, d = e.count; h < d; h += 3) {
                    const _ = e.getX(h + 0)
                      , g = e.getX(h + 1)
                      , m = e.getX(h + 2);
                    r.fromBufferAttribute(t, _),
                    s.fromBufferAttribute(t, g),
                    o.fromBufferAttribute(t, m),
                    u.subVectors(o, s),
                    f.subVectors(r, s),
                    u.cross(f),
                    a.fromBufferAttribute(n, _),
                    l.fromBufferAttribute(n, g),
                    c.fromBufferAttribute(n, m),
                    a.add(u),
                    l.add(u),
                    c.add(u),
                    n.setXYZ(_, a.x, a.y, a.z),
                    n.setXYZ(g, l.x, l.y, l.z),
                    n.setXYZ(m, c.x, c.y, c.z)
                }
            else
                for (let h = 0, d = t.count; h < d; h += 3)
                    r.fromBufferAttribute(t, h + 0),
                    s.fromBufferAttribute(t, h + 1),
                    o.fromBufferAttribute(t, h + 2),
                    u.subVectors(o, s),
                    f.subVectors(r, s),
                    u.cross(f),
                    n.setXYZ(h + 0, u.x, u.y, u.z),
                    n.setXYZ(h + 1, u.x, u.y, u.z),
                    n.setXYZ(h + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            rn.fromBufferAttribute(e, t),
            rn.normalize(),
            e.setXYZ(t, rn.x, rn.y, rn.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , u = a.itemSize
              , f = a.normalized
              , h = new c.constructor(l.length * u);
            let d = 0
              , _ = 0;
            for (let g = 0, m = l.length; g < m; g++) {
                a.isInterleavedBufferAttribute ? d = l[g] * a.data.stride + a.offset : d = l[g] * u;
                for (let p = 0; p < u; p++)
                    h[_++] = c[d++]
            }
            return new Ai(h,u,f)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new $r
          , n = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, n);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let u = 0, f = c.length; u < f; u++) {
                const h = c[u]
                  , d = e(h, n);
                l.push(d)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , u = [];
            for (let f = 0, h = c.length; f < h; f++) {
                const d = c[f];
                u.push(d.toJSON(e.data))
            }
            u.length > 0 && (r[l] = u,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = a.toJSON()),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone());
        const r = e.attributes;
        for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = []
              , f = s[c];
            for (let h = 0, d = f.length; h < d; h++)
                u.push(f[h].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const f = o[c];
            this.addGroup(f.start, f.count, f.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Wd = new jt
  , ts = new Ly
  , fl = new Sh
  , Xd = new Z
  , hl = new Z
  , dl = new Z
  , pl = new Z
  , nu = new Z
  , ml = new Z
  , qd = new Z
  , gl = new Z;
class Wn extends ci {
    constructor(e=new $r, t=new oo) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const r = t[n[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , r = n.attributes.position
          , s = n.morphAttributes.position
          , o = n.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            ml.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l]
                  , f = s[l];
                u !== 0 && (nu.fromBufferAttribute(f, e),
                o ? ml.addScaledVector(nu, u) : ml.addScaledVector(nu.sub(t), u))
            }
            t.add(ml)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        fl.copy(n.boundingSphere),
        fl.applyMatrix4(s),
        ts.copy(e.ray).recast(e.near),
        !(fl.containsPoint(ts.origin) === !1 && (ts.intersectSphere(fl, Xd) === null || ts.origin.distanceToSquared(Xd) > (e.far - e.near) ** 2)) && (Wd.copy(s).invert(),
        ts.copy(e.ray).applyMatrix4(Wd),
        !(n.boundingBox !== null && ts.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, ts)))
    }
    _computeIntersections(e, t, n) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , l = s.attributes.position
          , c = s.attributes.uv
          , u = s.attributes.uv1
          , f = s.attributes.normal
          , h = s.groups
          , d = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let _ = 0, g = h.length; _ < g; _++) {
                    const m = h[_]
                      , p = o[m.materialIndex]
                      , E = Math.max(m.start, d.start)
                      , S = Math.min(a.count, Math.min(m.start + m.count, d.start + d.count));
                    for (let v = E, b = S; v < b; v += 3) {
                        const A = a.getX(v)
                          , T = a.getX(v + 1)
                          , R = a.getX(v + 2);
                        r = _l(this, p, e, n, c, u, f, A, T, R),
                        r && (r.faceIndex = Math.floor(v / 3),
                        r.face.materialIndex = m.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, d.start)
                  , g = Math.min(a.count, d.start + d.count);
                for (let m = _, p = g; m < p; m += 3) {
                    const E = a.getX(m)
                      , S = a.getX(m + 1)
                      , v = a.getX(m + 2);
                    r = _l(this, o, e, n, c, u, f, E, S, v),
                    r && (r.faceIndex = Math.floor(m / 3),
                    t.push(r))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let _ = 0, g = h.length; _ < g; _++) {
                    const m = h[_]
                      , p = o[m.materialIndex]
                      , E = Math.max(m.start, d.start)
                      , S = Math.min(l.count, Math.min(m.start + m.count, d.start + d.count));
                    for (let v = E, b = S; v < b; v += 3) {
                        const A = v
                          , T = v + 1
                          , R = v + 2;
                        r = _l(this, p, e, n, c, u, f, A, T, R),
                        r && (r.faceIndex = Math.floor(v / 3),
                        r.face.materialIndex = m.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const _ = Math.max(0, d.start)
                  , g = Math.min(l.count, d.start + d.count);
                for (let m = _, p = g; m < p; m += 3) {
                    const E = m
                      , S = m + 1
                      , v = m + 2;
                    r = _l(this, o, e, n, c, u, f, E, S, v),
                    r && (r.faceIndex = Math.floor(m / 3),
                    t.push(r))
                }
            }
    }
}
function Vy(i, e, t, n, r, s, o, a) {
    let l;
    if (e.side === an ? l = n.intersectTriangle(o, s, r, !0, a) : l = n.intersectTriangle(r, s, o, e.side === _r, a),
    l === null)
        return null;
    gl.copy(a),
    gl.applyMatrix4(i.matrixWorld);
    const c = t.ray.origin.distanceTo(gl);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: gl.clone(),
        object: i
    }
}
function _l(i, e, t, n, r, s, o, a, l, c) {
    i.getVertexPosition(a, hl),
    i.getVertexPosition(l, dl),
    i.getVertexPosition(c, pl);
    const u = Vy(i, e, t, n, hl, dl, pl, qd);
    if (u) {
        const f = new Z;
        Ni.getBarycoord(qd, hl, dl, pl, f),
        r && (u.uv = Ni.getInterpolatedAttribute(r, a, l, c, f, new lt)),
        s && (u.uv1 = Ni.getInterpolatedAttribute(s, a, l, c, f, new lt)),
        o && (u.normal = Ni.getInterpolatedAttribute(o, a, l, c, f, new Z),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c,
            normal: new Z,
            materialIndex: 0
        };
        Ni.getNormal(hl, dl, pl, h.normal),
        u.face = h,
        u.barycoord = f
    }
    return u
}
class Ba extends $r {
    constructor(e=1, t=1, n=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , u = []
          , f = [];
        let h = 0
          , d = 0;
        _("z", "y", "x", -1, -1, n, t, e, o, s, 0),
        _("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
        _("x", "z", "y", 1, 1, e, n, t, r, o, 2),
        _("x", "z", "y", 1, -1, e, n, -t, r, o, 3),
        _("x", "y", "z", 1, -1, e, t, n, r, s, 4),
        _("x", "y", "z", -1, -1, e, t, -n, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new As(c,3)),
        this.setAttribute("normal", new As(u,3)),
        this.setAttribute("uv", new As(f,2));
        function _(g, m, p, E, S, v, b, A, T, R, y) {
            const x = v / T
              , P = b / R
              , U = v / 2
              , O = b / 2
              , B = A / 2
              , X = T + 1
              , H = R + 1;
            let Y = 0
              , N = 0;
            const k = new Z;
            for (let C = 0; C < H; C++) {
                const re = C * P - O;
                for (let ue = 0; ue < X; ue++) {
                    const we = ue * x - U;
                    k[g] = we * E,
                    k[m] = re * S,
                    k[p] = B,
                    c.push(k.x, k.y, k.z),
                    k[g] = 0,
                    k[m] = 0,
                    k[p] = A > 0 ? 1 : -1,
                    u.push(k.x, k.y, k.z),
                    f.push(ue / T),
                    f.push(1 - C / R),
                    Y += 1
                }
            }
            for (let C = 0; C < R; C++)
                for (let re = 0; re < T; re++) {
                    const ue = h + re + X * C
                      , we = h + re + X * (C + 1)
                      , q = h + (re + 1) + X * (C + 1)
                      , te = h + (re + 1) + X * C;
                    l.push(ue, we, te),
                    l.push(we, q, te),
                    N += 6
                }
            a.addGroup(d, N, y),
            d += N,
            h += Y
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ba(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Po(i) {
    const e = {};
    for (const t in i) {
        e[t] = {};
        for (const n in i[t]) {
            const r = i[t][n];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r
        }
    }
    return e
}
function Pn(i) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
        const n = Po(i[t]);
        for (const r in n)
            e[r] = n[r]
    }
    return e
}
function Gy(i) {
    const e = [];
    for (let t = 0; t < i.length; t++)
        e.push(i[t].clone());
    return e
}
function Dg(i) {
    const e = i.getRenderTarget();
    return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : pt.workingColorSpace
}
const Wy = {
    clone: Po,
    merge: Pn
};
var Xy = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
  , qy = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class zi extends Lo {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = Xy,
        this.fragmentShader = qy,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Po(e.uniforms),
        this.uniformsGroups = Gy(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (n[r] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class Lg extends ci {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new jt,
        this.projectionMatrix = new jt,
        this.projectionMatrixInverse = new jt,
        this.coordinateSystem = fr
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const br = new Z
  , Yd = new lt
  , $d = new lt;
class Mi extends Lg {
    constructor(e=50, t=1, n=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Lf * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Nc * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Lf * 2 * Math.atan(Math.tan(Nc * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        br.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(br.x, br.y).multiplyScalar(-e / br.z),
        br.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(br.x, br.y).multiplyScalar(-e / br.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, Yd, $d),
        t.subVectors($d, Yd)
    }
    setViewOffset(e, t, n, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Nc * .5 * this.fov) / this.zoom
          , n = 2 * t
          , r = this.aspect * n
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * n / c,
            r *= o.width / l,
            n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const js = -90
  , Ks = 1;
class Yy extends ci {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new Mi(js,Ks,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new Mi(js,Ks,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new Mi(js,Ks,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Mi(js,Ks,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new Mi(js,Ks,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new Mi(js,Ks,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,r,s,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === fr)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === nc)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,l,c,u] = this.children
          , f = e.getRenderTarget()
          , h = e.getActiveCubeFace()
          , d = e.getActiveMipmapLevel()
          , _ = e.xr.enabled;
        e.xr.enabled = !1;
        const g = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, r),
        e.render(t, s),
        e.setRenderTarget(n, 1, r),
        e.render(t, o),
        e.setRenderTarget(n, 2, r),
        e.render(t, a),
        e.setRenderTarget(n, 3, r),
        e.render(t, l),
        e.setRenderTarget(n, 4, r),
        e.render(t, c),
        n.texture.generateMipmaps = g,
        e.setRenderTarget(n, 5, r),
        e.render(t, u),
        e.setRenderTarget(f, h, d),
        e.xr.enabled = _,
        n.texture.needsPMREMUpdate = !0
    }
}
class Ig extends cn {
    constructor(e=[], t=wo, n, r, s, o, a, l, c, u) {
        super(e, t, n, r, s, o, a, l, c, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class $y extends Bi {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [n, n, n, n, n, n];
        this.texture = new Ig(r),
        this._setTextureOptions(t),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			",
            fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			"
        }
          , r = new Ba(5,5,5)
          , s = new zi({
            name: "CubemapFromEquirect",
            uniforms: Po(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: an,
            blending: Zi
        });
        s.uniforms.tEquirect.value = t;
        const o = new Wn(r,s)
          , a = t.minFilter;
        return t.minFilter === _s && (t.minFilter = ln),
        new Yy(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t=!0, n=!0, r=!0) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, n, r);
        e.setRenderTarget(s)
    }
}
class vl extends ci {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const jy = {
    type: "move"
};
class iu {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new vl,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new vl,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Z,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Z),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new vl,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Z,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Z),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const g of e.hand.values()) {
                    const m = t.getJointPose(g, n)
                      , p = this._getHandJoint(c, g);
                    m !== null && (p.matrix.fromArray(m.transform.matrix),
                    p.matrix.decompose(p.position, p.rotation, p.scale),
                    p.matrixWorldNeedsUpdate = !0,
                    p.jointRadius = m.radius),
                    p.visible = m !== null
                }
                const u = c.joints["index-finger-tip"]
                  , f = c.joints["thumb-tip"]
                  , h = u.position.distanceTo(f.position)
                  , d = .02
                  , _ = .005;
                c.inputState.pinching && h > d + _ ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && h <= d - _ && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, n),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(jy)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new vl;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
class If extends ci {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new vr,
        this.environmentIntensity = 1,
        this.environmentRotation = new vr,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
const ru = new Z
  , Ky = new Z
  , Zy = new nt;
class ls {
    constructor(e=new Z(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, r) {
        return this.normal.set(e, t, n),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const r = ru.subVectors(n, t).cross(Ky.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(ru)
          , r = this.normal.dot(n);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || Zy.getNormalMatrix(e)
          , r = this.coplanarPoint(ru).applyMatrix4(e)
          , s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ns = new Sh
  , xl = new Z;
class Ug {
    constructor(e=new ls, t=new ls, n=new ls, r=new ls, s=new ls, o=new ls) {
        this.planes = [e, t, n, r, s, o]
    }
    set(e, t, n, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=fr) {
        const n = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , l = r[3]
          , c = r[4]
          , u = r[5]
          , f = r[6]
          , h = r[7]
          , d = r[8]
          , _ = r[9]
          , g = r[10]
          , m = r[11]
          , p = r[12]
          , E = r[13]
          , S = r[14]
          , v = r[15];
        if (n[0].setComponents(l - s, h - c, m - d, v - p).normalize(),
        n[1].setComponents(l + s, h + c, m + d, v + p).normalize(),
        n[2].setComponents(l + o, h + u, m + _, v + E).normalize(),
        n[3].setComponents(l - o, h - u, m - _, v - E).normalize(),
        n[4].setComponents(l - a, h - f, m - g, v - S).normalize(),
        t === fr)
            n[5].setComponents(l + a, h + f, m + g, v + S).normalize();
        else if (t === nc)
            n[5].setComponents(a, f, g, S).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            ns.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            ns.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(ns)
    }
    intersectsSprite(e) {
        return ns.center.set(0, 0, 0),
        ns.radius = .7071067811865476,
        ns.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(ns)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(n) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const r = t[n];
            if (xl.x = r.normal.x > 0 ? e.max.x : e.min.x,
            xl.y = r.normal.y > 0 ? e.max.y : e.min.y,
            xl.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(xl) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Jy extends cn {
    constructor(e, t, n, r, s=ln, o=ln, a, l, c) {
        super(e, t, n, r, s, o, a, l, c),
        this.isVideoTexture = !0,
        this.generateMipmaps = !1;
        const u = this;
        function f() {
            u.needsUpdate = !0,
            e.requestVideoFrameCallback(f)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(f)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class Eh extends cn {
    constructor(e, t, n=Gr, r, s, o, a=Fi, l=Fi, c, u=Ca, f=1) {
        if (u !== Ca && u !== Co)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const h = {
            width: e,
            height: t,
            depth: f
        };
        super(h, r, s, o, a, l, u, n, c),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new yh(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
class Do extends $r {
    constructor(e=1, t=1, n=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(n)
          , l = Math.floor(r)
          , c = a + 1
          , u = l + 1
          , f = e / a
          , h = t / l
          , d = []
          , _ = []
          , g = []
          , m = [];
        for (let p = 0; p < u; p++) {
            const E = p * h - o;
            for (let S = 0; S < c; S++) {
                const v = S * f - s;
                _.push(v, -E, 0),
                g.push(0, 0, 1),
                m.push(S / a),
                m.push(1 - p / l)
            }
        }
        for (let p = 0; p < l; p++)
            for (let E = 0; E < a; E++) {
                const S = E + c * p
                  , v = E + c * (p + 1)
                  , b = E + 1 + c * (p + 1)
                  , A = E + 1 + c * p;
                d.push(S, v, A),
                d.push(v, b, A)
            }
        this.setIndex(d),
        this.setAttribute("position", new As(_,3)),
        this.setAttribute("normal", new As(g,3)),
        this.setAttribute("uv", new As(m,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Do(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class Qy extends Lo {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Ua,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class eS extends Lo {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const jd = {
    enabled: !1,
    files: {},
    add: function(i, e) {
        this.enabled !== !1 && (this.files[i] = e)
    },
    get: function(i) {
        if (this.enabled !== !1)
            return this.files[i]
    },
    remove: function(i) {
        delete this.files[i]
    },
    clear: function() {
        this.files = {}
    }
};
class tS {
    constructor(e, t, n) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(u) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(u, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(u) {
            o++,
            r.onProgress !== void 0 && r.onProgress(u, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(u) {
            r.onError !== void 0 && r.onError(u)
        }
        ,
        this.resolveURL = function(u) {
            return l ? l(u) : u
        }
        ,
        this.setURLModifier = function(u) {
            return l = u,
            this
        }
        ,
        this.addHandler = function(u, f) {
            return c.push(u, f),
            this
        }
        ,
        this.removeHandler = function(u) {
            const f = c.indexOf(u);
            return f !== -1 && c.splice(f, 2),
            this
        }
        ,
        this.getHandler = function(u) {
            for (let f = 0, h = c.length; f < h; f += 2) {
                const d = c[f]
                  , _ = c[f + 1];
                if (d.global && (d.lastIndex = 0),
                d.test(u))
                    return _
            }
            return null
        }
    }
}
const nS = new tS;
class Mh {
    constructor(e) {
        this.manager = e !== void 0 ? e : nS,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(r, s) {
            n.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
Mh.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class iS extends Mh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = jd.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Pa("img");
        function l() {
            u(),
            jd.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(f) {
            u(),
            r && r(f),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function u() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class Kd extends Mh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, r) {
        const s = new cn
          , o = new iS(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, n, r),
        s
    }
}
class Th extends Lg {
    constructor(e=-1, t=1, n=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = n - e
          , o = n + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= u * this.view.offsetY,
            l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
class rS extends Mi {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
class dn {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new dn(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
function Zd(i, e, t, n) {
    const r = sS(n);
    switch (t) {
    case xg:
        return i * e;
    case Sg:
        return i * e / r.components * r.byteLength;
    case _h:
        return i * e / r.components * r.byteLength;
    case Eg:
        return i * e * 2 / r.components * r.byteLength;
    case vh:
        return i * e * 2 / r.components * r.byteLength;
    case yg:
        return i * e * 3 / r.components * r.byteLength;
    case Oi:
        return i * e * 4 / r.components * r.byteLength;
    case xh:
        return i * e * 4 / r.components * r.byteLength;
    case Il:
    case Ul:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Nl:
    case Ol:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case af:
    case cf:
        return Math.max(i, 16) * Math.max(e, 8) / 4;
    case of:
    case lf:
        return Math.max(i, 8) * Math.max(e, 8) / 2;
    case uf:
    case ff:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hf:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case df:
        return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case pf:
        return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case mf:
        return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case gf:
        return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case _f:
        return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case vf:
        return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case xf:
        return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case yf:
        return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Sf:
        return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Ef:
        return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Mf:
        return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Tf:
        return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case bf:
        return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case wf:
        return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Fl:
    case Af:
    case Rf:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    case Mg:
    case Cf:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case Pf:
    case Df:
        return Math.ceil(i / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error("Unable to determine texture byte length for ".concat(t, " format."))
}
function sS(i) {
    switch (i) {
    case hi:
    case gg:
        return {
            byteLength: 1,
            components: 1
        };
    case Ra:
    case _g:
    case Ia:
        return {
            byteLength: 2,
            components: 1
        };
    case mh:
    case gh:
        return {
            byteLength: 2,
            components: 4
        };
    case Gr:
    case ph:
    case ur:
        return {
            byteLength: 4,
            components: 1
        };
    case vg:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error("Unknown texture type ".concat(i, "."))
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: uc
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = uc);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function Ng() {
    let i = null
      , e = !1
      , t = null
      , n = null;
    function r(s, o) {
        t(s, o),
        n = i.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = i.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            i.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            i = s
        }
    }
}
function oS(i) {
    const e = new WeakMap;
    function t(a, l) {
        const c = a.array
          , u = a.usage
          , f = c.byteLength
          , h = i.createBuffer();
        i.bindBuffer(l, h),
        i.bufferData(l, c, u),
        a.onUploadCallback();
        let d;
        if (c instanceof Float32Array)
            d = i.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? d = i.HALF_FLOAT : d = i.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            d = i.SHORT;
        else if (c instanceof Uint32Array)
            d = i.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            d = i.INT;
        else if (c instanceof Int8Array)
            d = i.BYTE;
        else if (c instanceof Uint8Array)
            d = i.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            d = i.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: h,
            type: d,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: f
        }
    }
    function n(a, l, c) {
        const u = l.array
          , f = l.updateRanges;
        if (i.bindBuffer(c, a),
        f.length === 0)
            i.bufferSubData(c, 0, u);
        else {
            f.sort( (d, _) => d.start - _.start);
            let h = 0;
            for (let d = 1; d < f.length; d++) {
                const _ = f[h]
                  , g = f[d];
                g.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, g.start + g.count - _.start) : (++h,
                f[h] = g)
            }
            f.length = h + 1;
            for (let d = 0, _ = f.length; d < _; d++) {
                const g = f[d];
                i.bufferSubData(c, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count)
            }
            l.clearUpdateRanges()
        }
        l.onUploadCallback()
    }
    function r(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (i.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: r,
        remove: s,
        update: o
    }
}
var aS = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif"
  , lS = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif"
  , cS = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif"
  , uS = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif"
  , fS = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif"
  , hS = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif"
  , dS = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif"
  , pS = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif"
  , mS = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif"
  , gS = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif"
  , _S = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif"
  , vS = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif"
  , xS = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated"
  , yS = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif"
  , SS = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif"
  , ES = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif"
  , MS = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif"
  , TS = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif"
  , bS = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif"
  , wS = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif"
  , AS = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif"
  , RS = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif"
  , CS = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif"
  , PS = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated"
  , DS = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif"
  , LS = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif"
  , IS = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif"
  , US = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif"
  , NS = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif"
  , OS = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif"
  , FS = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , BS = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}"
  , zS = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif"
  , kS = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif"
  , HS = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif"
  , VS = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif"
  , GS = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif"
  , WS = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif"
  , XS = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif"
  , qS = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif"
  , YS = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif"
  , $S = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}"
  , jS = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif"
  , KS = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;"
  , ZS = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert"
  , JS = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif"
  , QS = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif"
  , eE = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;"
  , tE = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon"
  , nE = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;"
  , iE = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong"
  , rE = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif"
  , sE = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}"
  , oE = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif"
  , aE = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif"
  , lE = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif"
  , cE = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif"
  , uE = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif"
  , fE = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif"
  , hE = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif"
  , dE = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif"
  , pE = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif"
  , mE = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif"
  , gE = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif"
  , _E = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif"
  , vE = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif"
  , xE = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif"
  , yE = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif"
  , SE = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif"
  , EE = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif"
  , ME = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif"
  , TE = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;"
  , bE = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif"
  , wE = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif"
  , AE = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif"
  , RE = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif"
  , CE = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif"
  , PE = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif"
  , DE = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif"
  , LE = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif"
  , IE = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif"
  , UE = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );"
  , NE = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}"
  , OE = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif"
  , FE = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;"
  , BE = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif"
  , zE = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif"
  , kE = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif"
  , HE = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif"
  , VE = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif"
  , GE = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif"
  , WE = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif"
  , XE = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}"
  , qE = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
  , YE = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif"
  , $E = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif"
  , jE = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif"
  , KE = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif"
  , ZE = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif"
  , JE = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif"
  , QE = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }"
  , eM = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif"
  , tM = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif"
  , nM = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif"
  , iM = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif"
  , rM = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif"
  , sM = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const oM = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}"
  , aM = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"
  , lM = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}"
  , cM = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"
  , uM = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}"
  , fM = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"
  , hM = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}"
  , dM = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}"
  , pM = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}"
  , mM = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}"
  , gM = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}"
  , _M = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}"
  , vM = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"
  , xM = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}"
  , yM = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}"
  , SM = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , EM = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}"
  , MM = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , TM = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}"
  , bM = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , wM = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}"
  , AM = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}"
  , RM = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}"
  , CM = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , PM = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}"
  , DM = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , LM = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}"
  , IM = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}"
  , UM = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}"
  , NM = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}"
  , OM = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}"
  , FM = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"
  , BM = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"
  , zM = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"
  , it = {
    alphahash_fragment: aS,
    alphahash_pars_fragment: lS,
    alphamap_fragment: cS,
    alphamap_pars_fragment: uS,
    alphatest_fragment: fS,
    alphatest_pars_fragment: hS,
    aomap_fragment: dS,
    aomap_pars_fragment: pS,
    batching_pars_vertex: mS,
    batching_vertex: gS,
    begin_vertex: _S,
    beginnormal_vertex: vS,
    bsdfs: xS,
    iridescence_fragment: yS,
    bumpmap_pars_fragment: SS,
    clipping_planes_fragment: ES,
    clipping_planes_pars_fragment: MS,
    clipping_planes_pars_vertex: TS,
    clipping_planes_vertex: bS,
    color_fragment: wS,
    color_pars_fragment: AS,
    color_pars_vertex: RS,
    color_vertex: CS,
    common: PS,
    cube_uv_reflection_fragment: DS,
    defaultnormal_vertex: LS,
    displacementmap_pars_vertex: IS,
    displacementmap_vertex: US,
    emissivemap_fragment: NS,
    emissivemap_pars_fragment: OS,
    colorspace_fragment: FS,
    colorspace_pars_fragment: BS,
    envmap_fragment: zS,
    envmap_common_pars_fragment: kS,
    envmap_pars_fragment: HS,
    envmap_pars_vertex: VS,
    envmap_physical_pars_fragment: QS,
    envmap_vertex: GS,
    fog_vertex: WS,
    fog_pars_vertex: XS,
    fog_fragment: qS,
    fog_pars_fragment: YS,
    gradientmap_pars_fragment: $S,
    lightmap_pars_fragment: jS,
    lights_lambert_fragment: KS,
    lights_lambert_pars_fragment: ZS,
    lights_pars_begin: JS,
    lights_toon_fragment: eE,
    lights_toon_pars_fragment: tE,
    lights_phong_fragment: nE,
    lights_phong_pars_fragment: iE,
    lights_physical_fragment: rE,
    lights_physical_pars_fragment: sE,
    lights_fragment_begin: oE,
    lights_fragment_maps: aE,
    lights_fragment_end: lE,
    logdepthbuf_fragment: cE,
    logdepthbuf_pars_fragment: uE,
    logdepthbuf_pars_vertex: fE,
    logdepthbuf_vertex: hE,
    map_fragment: dE,
    map_pars_fragment: pE,
    map_particle_fragment: mE,
    map_particle_pars_fragment: gE,
    metalnessmap_fragment: _E,
    metalnessmap_pars_fragment: vE,
    morphinstance_vertex: xE,
    morphcolor_vertex: yE,
    morphnormal_vertex: SE,
    morphtarget_pars_vertex: EE,
    morphtarget_vertex: ME,
    normal_fragment_begin: TE,
    normal_fragment_maps: bE,
    normal_pars_fragment: wE,
    normal_pars_vertex: AE,
    normal_vertex: RE,
    normalmap_pars_fragment: CE,
    clearcoat_normal_fragment_begin: PE,
    clearcoat_normal_fragment_maps: DE,
    clearcoat_pars_fragment: LE,
    iridescence_pars_fragment: IE,
    opaque_fragment: UE,
    packing: NE,
    premultiplied_alpha_fragment: OE,
    project_vertex: FE,
    dithering_fragment: BE,
    dithering_pars_fragment: zE,
    roughnessmap_fragment: kE,
    roughnessmap_pars_fragment: HE,
    shadowmap_pars_fragment: VE,
    shadowmap_pars_vertex: GE,
    shadowmap_vertex: WE,
    shadowmask_pars_fragment: XE,
    skinbase_vertex: qE,
    skinning_pars_vertex: YE,
    skinning_vertex: $E,
    skinnormal_vertex: jE,
    specularmap_fragment: KE,
    specularmap_pars_fragment: ZE,
    tonemapping_fragment: JE,
    tonemapping_pars_fragment: QE,
    transmission_fragment: eM,
    transmission_pars_fragment: tM,
    uv_pars_fragment: nM,
    uv_pars_vertex: iM,
    uv_vertex: rM,
    worldpos_vertex: sM,
    background_vert: oM,
    background_frag: aM,
    backgroundCube_vert: lM,
    backgroundCube_frag: cM,
    cube_vert: uM,
    cube_frag: fM,
    depth_vert: hM,
    depth_frag: dM,
    distanceRGBA_vert: pM,
    distanceRGBA_frag: mM,
    equirect_vert: gM,
    equirect_frag: _M,
    linedashed_vert: vM,
    linedashed_frag: xM,
    meshbasic_vert: yM,
    meshbasic_frag: SM,
    meshlambert_vert: EM,
    meshlambert_frag: MM,
    meshmatcap_vert: TM,
    meshmatcap_frag: bM,
    meshnormal_vert: wM,
    meshnormal_frag: AM,
    meshphong_vert: RM,
    meshphong_frag: CM,
    meshphysical_vert: PM,
    meshphysical_frag: DM,
    meshtoon_vert: LM,
    meshtoon_frag: IM,
    points_vert: UM,
    points_frag: NM,
    shadow_vert: OM,
    shadow_frag: FM,
    sprite_vert: BM,
    sprite_frag: zM
}
  , Se = {
    common: {
        diffuse: {
            value: new St(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new nt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new nt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new nt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new nt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new nt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new nt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new nt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new nt
        },
        normalScale: {
            value: new lt(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new nt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new nt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new nt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new nt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new St(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new St(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new nt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new nt
        }
    },
    sprite: {
        diffuse: {
            value: new St(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new lt(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new nt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new nt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Gi = {
    basic: {
        uniforms: Pn([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.fog]),
        vertexShader: it.meshbasic_vert,
        fragmentShader: it.meshbasic_frag
    },
    lambert: {
        uniforms: Pn([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, Se.lights, {
            emissive: {
                value: new St(0)
            }
        }]),
        vertexShader: it.meshlambert_vert,
        fragmentShader: it.meshlambert_frag
    },
    phong: {
        uniforms: Pn([Se.common, Se.specularmap, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, Se.lights, {
            emissive: {
                value: new St(0)
            },
            specular: {
                value: new St(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: it.meshphong_vert,
        fragmentShader: it.meshphong_frag
    },
    standard: {
        uniforms: Pn([Se.common, Se.envmap, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.roughnessmap, Se.metalnessmap, Se.fog, Se.lights, {
            emissive: {
                value: new St(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: it.meshphysical_vert,
        fragmentShader: it.meshphysical_frag
    },
    toon: {
        uniforms: Pn([Se.common, Se.aomap, Se.lightmap, Se.emissivemap, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.gradientmap, Se.fog, Se.lights, {
            emissive: {
                value: new St(0)
            }
        }]),
        vertexShader: it.meshtoon_vert,
        fragmentShader: it.meshtoon_frag
    },
    matcap: {
        uniforms: Pn([Se.common, Se.bumpmap, Se.normalmap, Se.displacementmap, Se.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: it.meshmatcap_vert,
        fragmentShader: it.meshmatcap_frag
    },
    points: {
        uniforms: Pn([Se.points, Se.fog]),
        vertexShader: it.points_vert,
        fragmentShader: it.points_frag
    },
    dashed: {
        uniforms: Pn([Se.common, Se.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: it.linedashed_vert,
        fragmentShader: it.linedashed_frag
    },
    depth: {
        uniforms: Pn([Se.common, Se.displacementmap]),
        vertexShader: it.depth_vert,
        fragmentShader: it.depth_frag
    },
    normal: {
        uniforms: Pn([Se.common, Se.bumpmap, Se.normalmap, Se.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: it.meshnormal_vert,
        fragmentShader: it.meshnormal_frag
    },
    sprite: {
        uniforms: Pn([Se.sprite, Se.fog]),
        vertexShader: it.sprite_vert,
        fragmentShader: it.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new nt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: it.background_vert,
        fragmentShader: it.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new nt
            }
        },
        vertexShader: it.backgroundCube_vert,
        fragmentShader: it.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: it.cube_vert,
        fragmentShader: it.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: it.equirect_vert,
        fragmentShader: it.equirect_frag
    },
    distanceRGBA: {
        uniforms: Pn([Se.common, Se.displacementmap, {
            referencePosition: {
                value: new Z
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: it.distanceRGBA_vert,
        fragmentShader: it.distanceRGBA_frag
    },
    shadow: {
        uniforms: Pn([Se.lights, Se.fog, {
            color: {
                value: new St(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: it.shadow_vert,
        fragmentShader: it.shadow_frag
    }
};
Gi.physical = {
    uniforms: Pn([Gi.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new nt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new nt
        },
        clearcoatNormalScale: {
            value: new lt(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new nt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new nt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new nt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new St(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new nt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new nt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new nt
        },
        transmissionSamplerSize: {
            value: new lt
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new nt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new St(0)
        },
        specularColor: {
            value: new St(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new nt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new nt
        },
        anisotropyVector: {
            value: new lt
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new nt
        }
    }]),
    vertexShader: it.meshphysical_vert,
    fragmentShader: it.meshphysical_frag
};
const yl = {
    r: 0,
    b: 0,
    g: 0
}
  , is = new vr
  , kM = new jt;
function HM(i, e, t, n, r, s, o) {
    const a = new St(0);
    let l = s === !0 ? 0 : 1, c, u, f = null, h = 0, d = null;
    function _(S) {
        let v = S.isScene === !0 ? S.background : null;
        return v && v.isTexture && (v = (S.backgroundBlurriness > 0 ? t : e).get(v)),
        v
    }
    function g(S) {
        let v = !1;
        const b = _(S);
        b === null ? p(a, l) : b && b.isColor && (p(b, 1),
        v = !0);
        const A = i.xr.getEnvironmentBlendMode();
        A === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : A === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (i.autoClear || v) && (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil))
    }
    function m(S, v) {
        const b = _(v);
        b && (b.isCubeTexture || b.mapping === fc) ? (u === void 0 && (u = new Wn(new Ba(1,1,1),new zi({
            name: "BackgroundCubeMaterial",
            uniforms: Po(Gi.backgroundCube.uniforms),
            vertexShader: Gi.backgroundCube.vertexShader,
            fragmentShader: Gi.backgroundCube.fragmentShader,
            side: an,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(A, T, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(u)),
        is.copy(v.backgroundRotation),
        is.x *= -1,
        is.y *= -1,
        is.z *= -1,
        b.isCubeTexture && b.isRenderTargetTexture === !1 && (is.y *= -1,
        is.z *= -1),
        u.material.uniforms.envMap.value = b,
        u.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = v.backgroundIntensity,
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(kM.makeRotationFromEuler(is)),
        u.material.toneMapped = pt.getTransfer(b.colorSpace) !== Mt,
        (f !== b || h !== b.version || d !== i.toneMapping) && (u.material.needsUpdate = !0,
        f = b,
        h = b.version,
        d = i.toneMapping),
        u.layers.enableAll(),
        S.unshift(u, u.geometry, u.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new Wn(new Do(2,2),new zi({
            name: "BackgroundMaterial",
            uniforms: Po(Gi.background.uniforms),
            vertexShader: Gi.background.vertexShader,
            fragmentShader: Gi.background.fragmentShader,
            side: _r,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = b,
        c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity,
        c.material.toneMapped = pt.getTransfer(b.colorSpace) !== Mt,
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(b.matrix),
        (f !== b || h !== b.version || d !== i.toneMapping) && (c.material.needsUpdate = !0,
        f = b,
        h = b.version,
        d = i.toneMapping),
        c.layers.enableAll(),
        S.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function p(S, v) {
        S.getRGB(yl, Dg(i)),
        n.buffers.color.setClear(yl.r, yl.g, yl.b, v, o)
    }
    function E() {
        u !== void 0 && (u.geometry.dispose(),
        u.material.dispose(),
        u = void 0),
        c !== void 0 && (c.geometry.dispose(),
        c.material.dispose(),
        c = void 0)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(S, v=1) {
            a.set(S),
            l = v,
            p(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(S) {
            l = S,
            p(a, l)
        },
        render: g,
        addToRenderList: m,
        dispose: E
    }
}
function VM(i, e) {
    const t = i.getParameter(i.MAX_VERTEX_ATTRIBS)
      , n = {}
      , r = h(null);
    let s = r
      , o = !1;
    function a(x, P, U, O, B) {
        let X = !1;
        const H = f(O, U, P);
        s !== H && (s = H,
        c(s.object)),
        X = d(x, O, U, B),
        X && _(x, O, U, B),
        B !== null && e.update(B, i.ELEMENT_ARRAY_BUFFER),
        (X || o) && (o = !1,
        v(x, P, U, O),
        B !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(B).buffer))
    }
    function l() {
        return i.createVertexArray()
    }
    function c(x) {
        return i.bindVertexArray(x)
    }
    function u(x) {
        return i.deleteVertexArray(x)
    }
    function f(x, P, U) {
        const O = U.wireframe === !0;
        let B = n[x.id];
        B === void 0 && (B = {},
        n[x.id] = B);
        let X = B[P.id];
        X === void 0 && (X = {},
        B[P.id] = X);
        let H = X[O];
        return H === void 0 && (H = h(l()),
        X[O] = H),
        H
    }
    function h(x) {
        const P = []
          , U = []
          , O = [];
        for (let B = 0; B < t; B++)
            P[B] = 0,
            U[B] = 0,
            O[B] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: P,
            enabledAttributes: U,
            attributeDivisors: O,
            object: x,
            attributes: {},
            index: null
        }
    }
    function d(x, P, U, O) {
        const B = s.attributes
          , X = P.attributes;
        let H = 0;
        const Y = U.getAttributes();
        for (const N in Y)
            if (Y[N].location >= 0) {
                const C = B[N];
                let re = X[N];
                if (re === void 0 && (N === "instanceMatrix" && x.instanceMatrix && (re = x.instanceMatrix),
                N === "instanceColor" && x.instanceColor && (re = x.instanceColor)),
                C === void 0 || C.attribute !== re || re && C.data !== re.data)
                    return !0;
                H++
            }
        return s.attributesNum !== H || s.index !== O
    }
    function _(x, P, U, O) {
        const B = {}
          , X = P.attributes;
        let H = 0;
        const Y = U.getAttributes();
        for (const N in Y)
            if (Y[N].location >= 0) {
                let C = X[N];
                C === void 0 && (N === "instanceMatrix" && x.instanceMatrix && (C = x.instanceMatrix),
                N === "instanceColor" && x.instanceColor && (C = x.instanceColor));
                const re = {};
                re.attribute = C,
                C && C.data && (re.data = C.data),
                B[N] = re,
                H++
            }
        s.attributes = B,
        s.attributesNum = H,
        s.index = O
    }
    function g() {
        const x = s.newAttributes;
        for (let P = 0, U = x.length; P < U; P++)
            x[P] = 0
    }
    function m(x) {
        p(x, 0)
    }
    function p(x, P) {
        const U = s.newAttributes
          , O = s.enabledAttributes
          , B = s.attributeDivisors;
        U[x] = 1,
        O[x] === 0 && (i.enableVertexAttribArray(x),
        O[x] = 1),
        B[x] !== P && (i.vertexAttribDivisor(x, P),
        B[x] = P)
    }
    function E() {
        const x = s.newAttributes
          , P = s.enabledAttributes;
        for (let U = 0, O = P.length; U < O; U++)
            P[U] !== x[U] && (i.disableVertexAttribArray(U),
            P[U] = 0)
    }
    function S(x, P, U, O, B, X, H) {
        H === !0 ? i.vertexAttribIPointer(x, P, U, B, X) : i.vertexAttribPointer(x, P, U, O, B, X)
    }
    function v(x, P, U, O) {
        g();
        const B = O.attributes
          , X = U.getAttributes()
          , H = P.defaultAttributeValues;
        for (const Y in X) {
            const N = X[Y];
            if (N.location >= 0) {
                let k = B[Y];
                if (k === void 0 && (Y === "instanceMatrix" && x.instanceMatrix && (k = x.instanceMatrix),
                Y === "instanceColor" && x.instanceColor && (k = x.instanceColor)),
                k !== void 0) {
                    const C = k.normalized
                      , re = k.itemSize
                      , ue = e.get(k);
                    if (ue === void 0)
                        continue;
                    const we = ue.buffer
                      , q = ue.type
                      , te = ue.bytesPerElement
                      , fe = q === i.INT || q === i.UNSIGNED_INT || k.gpuType === ph;
                    if (k.isInterleavedBufferAttribute) {
                        const oe = k.data
                          , me = oe.stride
                          , He = k.offset;
                        if (oe.isInstancedInterleavedBuffer) {
                            for (let ze = 0; ze < N.locationSize; ze++)
                                p(N.location + ze, oe.meshPerAttribute);
                            x.isInstancedMesh !== !0 && O._maxInstanceCount === void 0 && (O._maxInstanceCount = oe.meshPerAttribute * oe.count)
                        } else
                            for (let ze = 0; ze < N.locationSize; ze++)
                                m(N.location + ze);
                        i.bindBuffer(i.ARRAY_BUFFER, we);
                        for (let ze = 0; ze < N.locationSize; ze++)
                            S(N.location + ze, re / N.locationSize, q, C, me * te, (He + re / N.locationSize * ze) * te, fe)
                    } else {
                        if (k.isInstancedBufferAttribute) {
                            for (let oe = 0; oe < N.locationSize; oe++)
                                p(N.location + oe, k.meshPerAttribute);
                            x.isInstancedMesh !== !0 && O._maxInstanceCount === void 0 && (O._maxInstanceCount = k.meshPerAttribute * k.count)
                        } else
                            for (let oe = 0; oe < N.locationSize; oe++)
                                m(N.location + oe);
                        i.bindBuffer(i.ARRAY_BUFFER, we);
                        for (let oe = 0; oe < N.locationSize; oe++)
                            S(N.location + oe, re / N.locationSize, q, C, re * te, re / N.locationSize * oe * te, fe)
                    }
                } else if (H !== void 0) {
                    const C = H[Y];
                    if (C !== void 0)
                        switch (C.length) {
                        case 2:
                            i.vertexAttrib2fv(N.location, C);
                            break;
                        case 3:
                            i.vertexAttrib3fv(N.location, C);
                            break;
                        case 4:
                            i.vertexAttrib4fv(N.location, C);
                            break;
                        default:
                            i.vertexAttrib1fv(N.location, C)
                        }
                }
            }
        }
        E()
    }
    function b() {
        R();
        for (const x in n) {
            const P = n[x];
            for (const U in P) {
                const O = P[U];
                for (const B in O)
                    u(O[B].object),
                    delete O[B];
                delete P[U]
            }
            delete n[x]
        }
    }
    function A(x) {
        if (n[x.id] === void 0)
            return;
        const P = n[x.id];
        for (const U in P) {
            const O = P[U];
            for (const B in O)
                u(O[B].object),
                delete O[B];
            delete P[U]
        }
        delete n[x.id]
    }
    function T(x) {
        for (const P in n) {
            const U = n[P];
            if (U[x.id] === void 0)
                continue;
            const O = U[x.id];
            for (const B in O)
                u(O[B].object),
                delete O[B];
            delete U[x.id]
        }
    }
    function R() {
        y(),
        o = !0,
        s !== r && (s = r,
        c(s.object))
    }
    function y() {
        r.geometry = null,
        r.program = null,
        r.wireframe = !1
    }
    return {
        setup: a,
        reset: R,
        resetDefaultState: y,
        dispose: b,
        releaseStatesOfGeometry: A,
        releaseStatesOfProgram: T,
        initAttributes: g,
        enableAttribute: m,
        disableUnusedAttributes: E
    }
}
function GM(i, e, t) {
    let n;
    function r(c) {
        n = c
    }
    function s(c, u) {
        i.drawArrays(n, c, u),
        t.update(u, n, 1)
    }
    function o(c, u, f) {
        f !== 0 && (i.drawArraysInstanced(n, c, u, f),
        t.update(u, n, f))
    }
    function a(c, u, f) {
        if (f === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, u, 0, f);
        let d = 0;
        for (let _ = 0; _ < f; _++)
            d += u[_];
        t.update(d, n, 1)
    }
    function l(c, u, f, h) {
        if (f === 0)
            return;
        const d = e.get("WEBGL_multi_draw");
        if (d === null)
            for (let _ = 0; _ < c.length; _++)
                o(c[_], u[_], h[_]);
        else {
            d.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, h, 0, f);
            let _ = 0;
            for (let g = 0; g < f; g++)
                _ += u[g] * h[g];
            t.update(_, n, 1)
        }
    }
    this.setMode = r,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function WM(i, e, t, n) {
    let r;
    function s() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const T = e.get("EXT_texture_filter_anisotropic");
            r = i.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function o(T) {
        return !(T !== Oi && n.convert(T) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(T) {
        const R = T === Ia && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(T !== hi && n.convert(T) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && T !== ur && !R)
    }
    function l(T) {
        if (T === "highp") {
            if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
                return "highp";
            T = "mediump"
        }
        return T === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."),
    c = u);
    const f = t.logarithmicDepthBuffer === !0
      , h = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control")
      , d = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)
      , _ = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , g = i.getParameter(i.MAX_TEXTURE_SIZE)
      , m = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE)
      , p = i.getParameter(i.MAX_VERTEX_ATTRIBS)
      , E = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS)
      , S = i.getParameter(i.MAX_VARYING_VECTORS)
      , v = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS)
      , b = _ > 0
      , A = i.getParameter(i.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: f,
        reverseDepthBuffer: h,
        maxTextures: d,
        maxVertexTextures: _,
        maxTextureSize: g,
        maxCubemapSize: m,
        maxAttributes: p,
        maxVertexUniforms: E,
        maxVaryings: S,
        maxFragmentUniforms: v,
        vertexTextures: b,
        maxSamples: A
    }
}
function XM(i) {
    const e = this;
    let t = null
      , n = 0
      , r = !1
      , s = !1;
    const o = new ls
      , a = new nt
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(f, h) {
        const d = f.length !== 0 || h || n !== 0 || r;
        return r = h,
        n = f.length,
        d
    }
    ,
    this.beginShadows = function() {
        s = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(f, h) {
        t = u(f, h, 0)
    }
    ,
    this.setState = function(f, h, d) {
        const _ = f.clippingPlanes
          , g = f.clipIntersection
          , m = f.clipShadows
          , p = i.get(f);
        if (!r || _ === null || _.length === 0 || s && !m)
            s ? u(null) : c();
        else {
            const E = s ? 0 : n
              , S = E * 4;
            let v = p.clippingState || null;
            l.value = v,
            v = u(_, h, S, d);
            for (let b = 0; b !== S; ++b)
                v[b] = t[b];
            p.clippingState = v,
            this.numIntersection = g ? this.numPlanes : 0,
            this.numPlanes += E
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function u(f, h, d, _) {
        const g = f !== null ? f.length : 0;
        let m = null;
        if (g !== 0) {
            if (m = l.value,
            _ !== !0 || m === null) {
                const p = d + g * 4
                  , E = h.matrixWorldInverse;
                a.getNormalMatrix(E),
                (m === null || m.length < p) && (m = new Float32Array(p));
                for (let S = 0, v = d; S !== g; ++S,
                v += 4)
                    o.copy(f[S]).applyMatrix4(E, a),
                    o.normal.toArray(m, v),
                    m[v + 3] = o.constant
            }
            l.value = m,
            l.needsUpdate = !0
        }
        return e.numPlanes = g,
        e.numIntersection = 0,
        m
    }
}
function qM(i) {
    let e = new WeakMap;
    function t(o, a) {
        return a === nf ? o.mapping = wo : a === rf && (o.mapping = Ao),
        o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === nf || a === rf)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new $y(l.height);
                        return c.fromEquirectangularTexture(i, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: s
    }
}
const ao = 4
  , Jd = [.125, .215, .35, .446, .526, .582]
  , fs = 20
  , su = new Th
  , Qd = new St;
let ou = null
  , au = 0
  , lu = 0
  , cu = !1;
const cs = (1 + Math.sqrt(5)) / 2
  , Zs = 1 / cs
  , ep = [new Z(-cs,Zs,0), new Z(cs,Zs,0), new Z(-Zs,0,cs), new Z(Zs,0,cs), new Z(0,cs,-Zs), new Z(0,cs,Zs), new Z(-1,1,-1), new Z(1,1,-1), new Z(-1,1,1), new Z(1,1,1)]
  , YM = new Z;
class tp {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, r=100, s={}) {
        const {size: o=256, position: a=YM} = s;
        ou = this._renderer.getRenderTarget(),
        au = this._renderer.getActiveCubeFace(),
        lu = this._renderer.getActiveMipmapLevel(),
        cu = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(o);
        const l = this._allocateTargets();
        return l.depthBuffer = !0,
        this._sceneToCubeUV(e, n, r, l, a),
        t > 0 && this._blur(l, 0, 0, t),
        this._applyPMREM(l),
        this._cleanup(l),
        l
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = rp(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = ip(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(ou, au, lu),
        this._renderer.xr.enabled = cu,
        e.scissorTest = !1,
        Sl(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === wo || e.mapping === Ao ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        ou = this._renderer.getRenderTarget(),
        au = this._renderer.getActiveCubeFace(),
        lu = this._renderer.getActiveMipmapLevel(),
        cu = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: ln,
            minFilter: ln,
            generateMipmaps: !1,
            type: Ia,
            format: Oi,
            colorSpace: Wr,
            depthBuffer: !1
        }
          , r = np(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = np(e, t, n);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = $M(s)),
            this._blurMaterial = jM(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Wn(this._lodPlanes[0],e);
        this._renderer.compile(t, su)
    }
    _sceneToCubeUV(e, t, n, r, s) {
        const l = new Mi(90,1,t,n)
          , c = [1, -1, 1, 1, 1, 1]
          , u = [1, 1, 1, -1, -1, -1]
          , f = this._renderer
          , h = f.autoClear
          , d = f.toneMapping;
        f.getClearColor(Qd),
        f.toneMapping = Br,
        f.autoClear = !1;
        const _ = new oo({
            name: "PMREM.Background",
            side: an,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new Wn(new Ba,_);
        let m = !1;
        const p = e.background;
        p ? p.isColor && (_.color.copy(p),
        e.background = null,
        m = !0) : (_.color.copy(Qd),
        m = !0);
        for (let E = 0; E < 6; E++) {
            const S = E % 3;
            S === 0 ? (l.up.set(0, c[E], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x + u[E], s.y, s.z)) : S === 1 ? (l.up.set(0, 0, c[E]),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y + u[E], s.z)) : (l.up.set(0, c[E], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y, s.z + u[E]));
            const v = this._cubeSize;
            Sl(r, S * v, E > 2 ? v : 0, v, v),
            f.setRenderTarget(r),
            m && f.render(g, l),
            f.render(e, l)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        f.toneMapping = d,
        f.autoClear = h,
        e.background = p
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , r = e.mapping === wo || e.mapping === Ao;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = rp()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ip());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Wn(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Sl(t, 0, 0, 3 * l, 2 * l),
        n.setRenderTarget(t),
        n.render(o, su)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let s = 1; s < r; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , a = ep[(r - s - 1) % ep.length];
            this._blur(e, s - 1, s, o, a)
        }
        t.autoClear = n
    }
    _blur(e, t, n, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, r, "latitudinal", s),
        this._halfBlur(o, e, n, n, r, "longitudinal", s)
    }
    _halfBlur(e, t, n, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , f = new Wn(this._lodPlanes[r],c)
          , h = c.uniforms
          , d = this._sizeLods[n] - 1
          , _ = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * fs - 1)
          , g = s / _
          , m = isFinite(s) ? 1 + Math.floor(u * g) : fs;
        m > fs && console.warn("sigmaRadians, ".concat(s, ", is too large and will clip, as it requested ").concat(m, " samples when the maximum is set to ").concat(fs));
        const p = [];
        let E = 0;
        for (let T = 0; T < fs; ++T) {
            const R = T / g
              , y = Math.exp(-R * R / 2);
            p.push(y),
            T === 0 ? E += y : T < m && (E += 2 * y)
        }
        for (let T = 0; T < p.length; T++)
            p[T] = p[T] / E;
        h.envMap.value = e.texture,
        h.samples.value = m,
        h.weights.value = p,
        h.latitudinal.value = o === "latitudinal",
        a && (h.poleAxis.value = a);
        const {_lodMax: S} = this;
        h.dTheta.value = _,
        h.mipInt.value = S - n;
        const v = this._sizeLods[r]
          , b = 3 * v * (r > S - ao ? r - S + ao : 0)
          , A = 4 * (this._cubeSize - v);
        Sl(t, b, A, 3 * v, 2 * v),
        l.setRenderTarget(t),
        l.render(f, su)
    }
}
function $M(i) {
    const e = []
      , t = []
      , n = [];
    let r = i;
    const s = i - ao + 1 + Jd.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > i - ao ? l = Jd[o - i + ao - 1] : o === 0 && (l = 0),
        n.push(l);
        const c = 1 / (a - 2)
          , u = -c
          , f = 1 + c
          , h = [u, u, f, u, f, f, u, u, f, f, u, f]
          , d = 6
          , _ = 6
          , g = 3
          , m = 2
          , p = 1
          , E = new Float32Array(g * _ * d)
          , S = new Float32Array(m * _ * d)
          , v = new Float32Array(p * _ * d);
        for (let A = 0; A < d; A++) {
            const T = A % 3 * 2 / 3 - 1
              , R = A > 2 ? 0 : -1
              , y = [T, R, 0, T + 2 / 3, R, 0, T + 2 / 3, R + 1, 0, T, R, 0, T + 2 / 3, R + 1, 0, T, R + 1, 0];
            E.set(y, g * _ * A),
            S.set(h, m * _ * A);
            const x = [A, A, A, A, A, A];
            v.set(x, p * _ * A)
        }
        const b = new $r;
        b.setAttribute("position", new Ai(E,g)),
        b.setAttribute("uv", new Ai(S,m)),
        b.setAttribute("faceIndex", new Ai(v,p)),
        e.push(b),
        r > ao && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function np(i, e, t) {
    const n = new Bi(i,e,t);
    return n.texture.mapping = fc,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function Sl(i, e, t, n, r) {
    i.viewport.set(e, t, n, r),
    i.scissor.set(e, t, n, r)
}
function jM(i, e, t) {
    const n = new Float32Array(fs)
      , r = new Z(0,1,0);
    return new zi({
        name: "SphericalGaussianBlur",
        defines: {
            n: fs,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: "".concat(i, ".0")
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: bh(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		",
        blending: Zi,
        depthTest: !1,
        depthWrite: !1
    })
}
function ip() {
    return new zi({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: bh(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		",
        blending: Zi,
        depthTest: !1,
        depthWrite: !1
    })
}
function rp() {
    return new zi({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: bh(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		",
        blending: Zi,
        depthTest: !1,
        depthWrite: !1
    })
}
function bh() {
    return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	"
}
function KM(i) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === nf || l === rf
              , u = l === wo || l === Ao;
            if (c || u) {
                let f = e.get(a);
                const h = f !== void 0 ? f.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== h)
                    return t === null && (t = new tp(i)),
                    f = c ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f),
                    f.texture.pmremVersion = a.pmremVersion,
                    e.set(a, f),
                    f.texture;
                if (f !== void 0)
                    return f.texture;
                {
                    const d = a.image;
                    return c && d && d.height > 0 || u && d && r(d) ? (t === null && (t = new tp(i)),
                    f = c ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    f.texture.pmremVersion = a.pmremVersion,
                    e.set(a, f),
                    a.addEventListener("dispose", s),
                    f.texture) : null
                }
            }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++)
            a[u] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function ZM(i) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let r;
        switch (n) {
        case "WEBGL_depth_texture":
            r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = i.getExtension(n)
        }
        return e[n] = r,
        r
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const r = t(n);
            return r === null && go("THREE.WebGLRenderer: " + n + " extension not supported."),
            r
        }
    }
}
function JM(i, e, t, n) {
    const r = {}
      , s = new WeakMap;
    function o(f) {
        const h = f.target;
        h.index !== null && e.remove(h.index);
        for (const _ in h.attributes)
            e.remove(h.attributes[_]);
        h.removeEventListener("dispose", o),
        delete r[h.id];
        const d = s.get(h);
        d && (e.remove(d),
        s.delete(h)),
        n.releaseStatesOfGeometry(h),
        h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
        t.memory.geometries--
    }
    function a(f, h) {
        return r[h.id] === !0 || (h.addEventListener("dispose", o),
        r[h.id] = !0,
        t.memory.geometries++),
        h
    }
    function l(f) {
        const h = f.attributes;
        for (const d in h)
            e.update(h[d], i.ARRAY_BUFFER)
    }
    function c(f) {
        const h = []
          , d = f.index
          , _ = f.attributes.position;
        let g = 0;
        if (d !== null) {
            const E = d.array;
            g = d.version;
            for (let S = 0, v = E.length; S < v; S += 3) {
                const b = E[S + 0]
                  , A = E[S + 1]
                  , T = E[S + 2];
                h.push(b, A, A, T, T, b)
            }
        } else if (_ !== void 0) {
            const E = _.array;
            g = _.version;
            for (let S = 0, v = E.length / 3 - 1; S < v; S += 3) {
                const b = S + 0
                  , A = S + 1
                  , T = S + 2;
                h.push(b, A, A, T, T, b)
            }
        } else
            return;
        const m = new (bg(h) ? Pg : Cg)(h,1);
        m.version = g;
        const p = s.get(f);
        p && e.remove(p),
        s.set(f, m)
    }
    function u(f) {
        const h = s.get(f);
        if (h) {
            const d = f.index;
            d !== null && h.version < d.version && c(f)
        } else
            c(f);
        return s.get(f)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}
function QM(i, e, t) {
    let n;
    function r(h) {
        n = h
    }
    let s, o;
    function a(h) {
        s = h.type,
        o = h.bytesPerElement
    }
    function l(h, d) {
        i.drawElements(n, d, s, h * o),
        t.update(d, n, 1)
    }
    function c(h, d, _) {
        _ !== 0 && (i.drawElementsInstanced(n, d, s, h * o, _),
        t.update(d, n, _))
    }
    function u(h, d, _) {
        if (_ === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, d, 0, s, h, 0, _);
        let m = 0;
        for (let p = 0; p < _; p++)
            m += d[p];
        t.update(m, n, 1)
    }
    function f(h, d, _, g) {
        if (_ === 0)
            return;
        const m = e.get("WEBGL_multi_draw");
        if (m === null)
            for (let p = 0; p < h.length; p++)
                c(h[p] / o, d[p], g[p]);
        else {
            m.multiDrawElementsInstancedWEBGL(n, d, 0, s, h, 0, g, 0, _);
            let p = 0;
            for (let E = 0; E < _; E++)
                p += d[E] * g[E];
            t.update(p, n, 1)
        }
    }
    this.setMode = r,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = u,
    this.renderMultiDrawInstances = f
}
function eT(i) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(s, o, a) {
        switch (t.calls++,
        o) {
        case i.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case i.LINES:
            t.lines += a * (s / 2);
            break;
        case i.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case i.LINE_LOOP:
            t.lines += a * s;
            break;
        case i.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: n
    }
}
function tT(i, e, t) {
    const n = new WeakMap
      , r = new Wt;
    function s(o, a, l) {
        const c = o.morphTargetInfluences
          , u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , f = u !== void 0 ? u.length : 0;
        let h = n.get(a);
        if (h === void 0 || h.count !== f) {
            let y = function() {
                T.dispose(),
                n.delete(a),
                a.removeEventListener("dispose", y)
            };
            h !== void 0 && h.texture.dispose();
            const d = a.morphAttributes.position !== void 0
              , _ = a.morphAttributes.normal !== void 0
              , g = a.morphAttributes.color !== void 0
              , m = a.morphAttributes.position || []
              , p = a.morphAttributes.normal || []
              , E = a.morphAttributes.color || [];
            let S = 0;
            d === !0 && (S = 1),
            _ === !0 && (S = 2),
            g === !0 && (S = 3);
            let v = a.attributes.position.count * S
              , b = 1;
            v > e.maxTextureSize && (b = Math.ceil(v / e.maxTextureSize),
            v = e.maxTextureSize);
            const A = new Float32Array(v * b * 4 * f)
              , T = new wg(A,v,b,f);
            T.type = ur,
            T.needsUpdate = !0;
            const R = S * 4;
            for (let x = 0; x < f; x++) {
                const P = m[x]
                  , U = p[x]
                  , O = E[x]
                  , B = v * b * 4 * x;
                for (let X = 0; X < P.count; X++) {
                    const H = X * R;
                    d === !0 && (r.fromBufferAttribute(P, X),
                    A[B + H + 0] = r.x,
                    A[B + H + 1] = r.y,
                    A[B + H + 2] = r.z,
                    A[B + H + 3] = 0),
                    _ === !0 && (r.fromBufferAttribute(U, X),
                    A[B + H + 4] = r.x,
                    A[B + H + 5] = r.y,
                    A[B + H + 6] = r.z,
                    A[B + H + 7] = 0),
                    g === !0 && (r.fromBufferAttribute(O, X),
                    A[B + H + 8] = r.x,
                    A[B + H + 9] = r.y,
                    A[B + H + 10] = r.z,
                    A[B + H + 11] = O.itemSize === 4 ? r.w : 1)
                }
            }
            h = {
                count: f,
                texture: T,
                size: new lt(v,b)
            },
            n.set(a, h),
            a.addEventListener("dispose", y)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(i, "morphTexture", o.morphTexture, t);
        else {
            let d = 0;
            for (let g = 0; g < c.length; g++)
                d += c[g];
            const _ = a.morphTargetsRelative ? 1 : 1 - d;
            l.getUniforms().setValue(i, "morphTargetBaseInfluence", _),
            l.getUniforms().setValue(i, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(i, "morphTargetsTexture", h.texture, t),
        l.getUniforms().setValue(i, "morphTargetsTextureSize", h.size)
    }
    return {
        update: s
    }
}
function nT(i, e, t, n) {
    let r = new WeakMap;
    function s(l) {
        const c = n.render.frame
          , u = l.geometry
          , f = e.get(l, u);
        if (r.get(f) !== c && (e.update(f),
        r.set(f, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        r.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER),
        r.set(l, c))),
        l.isSkinnedMesh) {
            const h = l.skeleton;
            r.get(h) !== c && (h.update(),
            r.set(h, c))
        }
        return f
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const Og = new cn
  , sp = new Eh(1,1)
  , Fg = new wg
  , Bg = new Py
  , zg = new Ig
  , op = []
  , ap = []
  , lp = new Float32Array(16)
  , cp = new Float32Array(9)
  , up = new Float32Array(4);
function Io(i, e, t) {
    const n = i[0];
    if (n <= 0 || n > 0)
        return i;
    const r = e * t;
    let s = op[r];
    if (s === void 0 && (s = new Float32Array(r),
    op[r] = s),
    e !== 0) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            i[o].toArray(s, a)
    }
    return s
}
function tn(i, e) {
    if (i.length !== e.length)
        return !1;
    for (let t = 0, n = i.length; t < n; t++)
        if (i[t] !== e[t])
            return !1;
    return !0
}
function nn(i, e) {
    for (let t = 0, n = e.length; t < n; t++)
        i[t] = e[t]
}
function hc(i, e) {
    let t = ap[e];
    t === void 0 && (t = new Int32Array(e),
    ap[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = i.allocateTextureUnit();
    return t
}
function iT(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1f(this.addr, e),
    t[0] = e)
}
function rT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (tn(t, e))
            return;
        i.uniform2fv(this.addr, e),
        nn(t, e)
    }
}
function sT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (tn(t, e))
            return;
        i.uniform3fv(this.addr, e),
        nn(t, e)
    }
}
function oT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (tn(t, e))
            return;
        i.uniform4fv(this.addr, e),
        nn(t, e)
    }
}
function aT(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (tn(t, e))
            return;
        i.uniformMatrix2fv(this.addr, !1, e),
        nn(t, e)
    } else {
        if (tn(t, n))
            return;
        up.set(n),
        i.uniformMatrix2fv(this.addr, !1, up),
        nn(t, n)
    }
}
function lT(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (tn(t, e))
            return;
        i.uniformMatrix3fv(this.addr, !1, e),
        nn(t, e)
    } else {
        if (tn(t, n))
            return;
        cp.set(n),
        i.uniformMatrix3fv(this.addr, !1, cp),
        nn(t, n)
    }
}
function cT(i, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (tn(t, e))
            return;
        i.uniformMatrix4fv(this.addr, !1, e),
        nn(t, e)
    } else {
        if (tn(t, n))
            return;
        lp.set(n),
        i.uniformMatrix4fv(this.addr, !1, lp),
        nn(t, n)
    }
}
function uT(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1i(this.addr, e),
    t[0] = e)
}
function fT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (tn(t, e))
            return;
        i.uniform2iv(this.addr, e),
        nn(t, e)
    }
}
function hT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (tn(t, e))
            return;
        i.uniform3iv(this.addr, e),
        nn(t, e)
    }
}
function dT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (tn(t, e))
            return;
        i.uniform4iv(this.addr, e),
        nn(t, e)
    }
}
function pT(i, e) {
    const t = this.cache;
    t[0] !== e && (i.uniform1ui(this.addr, e),
    t[0] = e)
}
function mT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (tn(t, e))
            return;
        i.uniform2uiv(this.addr, e),
        nn(t, e)
    }
}
function gT(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (tn(t, e))
            return;
        i.uniform3uiv(this.addr, e),
        nn(t, e)
    }
}
function _T(i, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (tn(t, e))
            return;
        i.uniform4uiv(this.addr, e),
        nn(t, e)
    }
}
function vT(i, e, t) {
    const n = this.cache
      , r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r),
    n[0] = r);
    let s;
    this.type === i.SAMPLER_2D_SHADOW ? (sp.compareFunction = Tg,
    s = sp) : s = Og,
    t.setTexture2D(e || s, r)
}
function xT(i, e, t) {
    const n = this.cache
      , r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r),
    n[0] = r),
    t.setTexture3D(e || Bg, r)
}
function yT(i, e, t) {
    const n = this.cache
      , r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r),
    n[0] = r),
    t.setTextureCube(e || zg, r)
}
function ST(i, e, t) {
    const n = this.cache
      , r = t.allocateTextureUnit();
    n[0] !== r && (i.uniform1i(this.addr, r),
    n[0] = r),
    t.setTexture2DArray(e || Fg, r)
}
function ET(i) {
    switch (i) {
    case 5126:
        return iT;
    case 35664:
        return rT;
    case 35665:
        return sT;
    case 35666:
        return oT;
    case 35674:
        return aT;
    case 35675:
        return lT;
    case 35676:
        return cT;
    case 5124:
    case 35670:
        return uT;
    case 35667:
    case 35671:
        return fT;
    case 35668:
    case 35672:
        return hT;
    case 35669:
    case 35673:
        return dT;
    case 5125:
        return pT;
    case 36294:
        return mT;
    case 36295:
        return gT;
    case 36296:
        return _T;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return vT;
    case 35679:
    case 36299:
    case 36307:
        return xT;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return yT;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return ST
    }
}
function MT(i, e) {
    i.uniform1fv(this.addr, e)
}
function TT(i, e) {
    const t = Io(e, this.size, 2);
    i.uniform2fv(this.addr, t)
}
function bT(i, e) {
    const t = Io(e, this.size, 3);
    i.uniform3fv(this.addr, t)
}
function wT(i, e) {
    const t = Io(e, this.size, 4);
    i.uniform4fv(this.addr, t)
}
function AT(i, e) {
    const t = Io(e, this.size, 4);
    i.uniformMatrix2fv(this.addr, !1, t)
}
function RT(i, e) {
    const t = Io(e, this.size, 9);
    i.uniformMatrix3fv(this.addr, !1, t)
}
function CT(i, e) {
    const t = Io(e, this.size, 16);
    i.uniformMatrix4fv(this.addr, !1, t)
}
function PT(i, e) {
    i.uniform1iv(this.addr, e)
}
function DT(i, e) {
    i.uniform2iv(this.addr, e)
}
function LT(i, e) {
    i.uniform3iv(this.addr, e)
}
function IT(i, e) {
    i.uniform4iv(this.addr, e)
}
function UT(i, e) {
    i.uniform1uiv(this.addr, e)
}
function NT(i, e) {
    i.uniform2uiv(this.addr, e)
}
function OT(i, e) {
    i.uniform3uiv(this.addr, e)
}
function FT(i, e) {
    i.uniform4uiv(this.addr, e)
}
function BT(i, e, t) {
    const n = this.cache
      , r = e.length
      , s = hc(t, r);
    tn(n, s) || (i.uniform1iv(this.addr, s),
    nn(n, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || Og, s[o])
}
function zT(i, e, t) {
    const n = this.cache
      , r = e.length
      , s = hc(t, r);
    tn(n, s) || (i.uniform1iv(this.addr, s),
    nn(n, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || Bg, s[o])
}
function kT(i, e, t) {
    const n = this.cache
      , r = e.length
      , s = hc(t, r);
    tn(n, s) || (i.uniform1iv(this.addr, s),
    nn(n, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || zg, s[o])
}
function HT(i, e, t) {
    const n = this.cache
      , r = e.length
      , s = hc(t, r);
    tn(n, s) || (i.uniform1iv(this.addr, s),
    nn(n, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || Fg, s[o])
}
function VT(i) {
    switch (i) {
    case 5126:
        return MT;
    case 35664:
        return TT;
    case 35665:
        return bT;
    case 35666:
        return wT;
    case 35674:
        return AT;
    case 35675:
        return RT;
    case 35676:
        return CT;
    case 5124:
    case 35670:
        return PT;
    case 35667:
    case 35671:
        return DT;
    case 35668:
    case 35672:
        return LT;
    case 35669:
    case 35673:
        return IT;
    case 5125:
        return UT;
    case 36294:
        return NT;
    case 36295:
        return OT;
    case 36296:
        return FT;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return BT;
    case 35679:
    case 36299:
    case 36307:
        return zT;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return kT;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return HT
    }
}
class GT {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = ET(t.type)
    }
}
class WT {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = VT(t.type)
    }
}
class XT {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], n)
        }
    }
}
const uu = /(\w+)(\])?(\[|\.)?/g;
function fp(i, e) {
    i.seq.push(e),
    i.map[e.id] = e
}
function qT(i, e, t) {
    const n = i.name
      , r = n.length;
    for (uu.lastIndex = 0; ; ) {
        const s = uu.exec(n)
          , o = uu.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            fp(t, c === void 0 ? new GT(a,i,e) : new WT(a,i,e));
            break
        } else {
            let f = t.map[a];
            f === void 0 && (f = new XT(a),
            fp(t, f)),
            t = f
        }
    }
}
class Bl {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < n; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            qT(s, o, this)
        }
    }
    setValue(e, t, n, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, n, r)
    }
    setOptional(e, t, n) {
        const r = t[n];
        r !== void 0 && this.setValue(e, n, r)
    }
    static upload(e, t, n, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && n.push(o)
        }
        return n
    }
}
function hp(i, e, t) {
    const n = i.createShader(e);
    return i.shaderSource(n, t),
    i.compileShader(n),
    n
}
const YT = 37297;
let $T = 0;
function jT(i, e) {
    const t = i.split("\n")
      , n = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        n.push("".concat(a === e ? ">" : " ", " ").concat(a, ": ").concat(t[o]))
    }
    return n.join("\n")
}
const dp = new nt;
function KT(i) {
    pt._getMatrix(dp, pt.workingColorSpace, i);
    const e = "mat3( ".concat(dp.elements.map(t => t.toFixed(4)), " )");
    switch (pt.getTransfer(i)) {
    case tc:
        return [e, "LinearTransferOETF"];
    case Mt:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", i),
        [e, "LinearTransferOETF"]
    }
}
function pp(i, e, t) {
    const n = i.getShaderParameter(e, i.COMPILE_STATUS)
      , r = i.getShaderInfoLog(e).trim();
    if (n && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + "\n\n" + r + "\n\n" + jT(i.getShaderSource(e), o)
    } else
        return r
}
function ZT(i, e) {
    const t = KT(e);
    return ["vec4 ".concat(i, "( vec4 value ) {"), "	return ".concat(t[1], "( vec4( value.rgb * ").concat(t[0], ", value.a ) );"), "}"].join("\n")
}
function JT(i, e) {
    let t;
    switch (e) {
    case ny:
        t = "Linear";
        break;
    case iy:
        t = "Reinhard";
        break;
    case ry:
        t = "Cineon";
        break;
    case sy:
        t = "ACESFilmic";
        break;
    case ay:
        t = "AgX";
        break;
    case ly:
        t = "Neutral";
        break;
    case oy:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const El = new Z;
function QT() {
    pt.getLuminanceCoefficients(El);
    const i = El.x.toFixed(4)
      , e = El.y.toFixed(4)
      , t = El.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", "	const vec3 weights = vec3( ".concat(i, ", ").concat(e, ", ").concat(t, " );"), "	return dot( weights, rgb );", "}"].join("\n")
}
function eb(i) {
    return [i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(ea).join("\n")
}
function tb(i) {
    const e = [];
    for (const t in i) {
        const n = i[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join("\n")
}
function nb(i, e) {
    const t = {}
      , n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < n; r++) {
        const s = i.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === i.FLOAT_MAT2 && (a = 2),
        s.type === i.FLOAT_MAT3 && (a = 3),
        s.type === i.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: i.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function ea(i) {
    return i !== ""
}
function mp(i, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function gp(i, e) {
    return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const ib = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Uf(i) {
    return i.replace(ib, sb)
}
const rb = new Map;
function sb(i, e) {
    let t = it[e];
    if (t === void 0) {
        const n = rb.get(e);
        if (n !== void 0)
            t = it[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Uf(t)
}
const ob = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function _p(i) {
    return i.replace(ob, ab)
}
function ab(i, e, t, n) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function vp(i) {
    let e = "precision ".concat(i.precision, " float;\n	precision ").concat(i.precision, " int;\n	precision ").concat(i.precision, " sampler2D;\n	precision ").concat(i.precision, " samplerCube;\n	precision ").concat(i.precision, " sampler3D;\n	precision ").concat(i.precision, " sampler2DArray;\n	precision ").concat(i.precision, " sampler2DShadow;\n	precision ").concat(i.precision, " samplerCubeShadow;\n	precision ").concat(i.precision, " sampler2DArrayShadow;\n	precision ").concat(i.precision, " isampler2D;\n	precision ").concat(i.precision, " isampler3D;\n	precision ").concat(i.precision, " isamplerCube;\n	precision ").concat(i.precision, " isampler2DArray;\n	precision ").concat(i.precision, " usampler2D;\n	precision ").concat(i.precision, " usampler3D;\n	precision ").concat(i.precision, " usamplerCube;\n	precision ").concat(i.precision, " usampler2DArray;\n	");
    return i.precision === "highp" ? e += "\n#define HIGH_PRECISION" : i.precision === "mediump" ? e += "\n#define MEDIUM_PRECISION" : i.precision === "lowp" && (e += "\n#define LOW_PRECISION"),
    e
}
function lb(i) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return i.shadowMapType === dg ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Nx ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === rr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function cb(i) {
    let e = "ENVMAP_TYPE_CUBE";
    if (i.envMap)
        switch (i.envMapMode) {
        case wo:
        case Ao:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case fc:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function ub(i) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (i.envMap)
        switch (i.envMapMode) {
        case Ao:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function fb(i) {
    let e = "ENVMAP_BLENDING_NONE";
    if (i.envMap)
        switch (i.combine) {
        case pg:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case ey:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case ty:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function hb(i) {
    const e = i.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
        texelHeight: n,
        maxMip: t
    }
}
function db(i, e, t, n) {
    const r = i.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = lb(t)
      , c = cb(t)
      , u = ub(t)
      , f = fb(t)
      , h = hb(t)
      , d = eb(t)
      , _ = tb(s)
      , g = r.createProgram();
    let m, p, E = t.glslVersion ? "#version " + t.glslVersion + "\n" : "";
    t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(ea).join("\n"),
    m.length > 0 && (m += "\n"),
    p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(ea).join("\n"),
    p.length > 0 && (p += "\n")) : (m = [vp(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(ea).join("\n"),
    p = [vp(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + f : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Br ? "#define TONE_MAPPING" : "", t.toneMapping !== Br ? it.tonemapping_pars_fragment : "", t.toneMapping !== Br ? JT("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", it.colorspace_pars_fragment, ZT("linearToOutputTexel", t.outputColorSpace), QT(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", "\n"].filter(ea).join("\n")),
    o = Uf(o),
    o = mp(o, t),
    o = gp(o, t),
    a = Uf(a),
    a = mp(a, t),
    a = gp(a, t),
    o = _p(o),
    a = _p(a),
    t.isRawShaderMaterial !== !0 && (E = "#version 300 es\n",
    m = [d, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m,
    p = ["#define varying in", t.glslVersion === Dd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Dd ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + p);
    const S = E + m + o
      , v = E + p + a
      , b = hp(r, r.VERTEX_SHADER, S)
      , A = hp(r, r.FRAGMENT_SHADER, v);
    r.attachShader(g, b),
    r.attachShader(g, A),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"),
    r.linkProgram(g);
    function T(P) {
        if (i.debug.checkShaderErrors) {
            const U = r.getProgramInfoLog(g).trim()
              , O = r.getShaderInfoLog(b).trim()
              , B = r.getShaderInfoLog(A).trim();
            let X = !0
              , H = !0;
            if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
                if (X = !1,
                typeof i.debug.onShaderError == "function")
                    i.debug.onShaderError(r, g, b, A);
                else {
                    const Y = pp(r, b, "vertex")
                      , N = pp(r, A, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + P.name + "\nMaterial Type: " + P.type + "\n\nProgram Info Log: " + U + "\n" + Y + "\n" + N)
                }
            else
                U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (O === "" || B === "") && (H = !1);
            H && (P.diagnostics = {
                runnable: X,
                programLog: U,
                vertexShader: {
                    log: O,
                    prefix: m
                },
                fragmentShader: {
                    log: B,
                    prefix: p
                }
            })
        }
        r.deleteShader(b),
        r.deleteShader(A),
        R = new Bl(r,g),
        y = nb(r, g)
    }
    let R;
    this.getUniforms = function() {
        return R === void 0 && T(this),
        R
    }
    ;
    let y;
    this.getAttributes = function() {
        return y === void 0 && T(this),
        y
    }
    ;
    let x = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return x === !1 && (x = r.getProgramParameter(g, YT)),
        x
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        r.deleteProgram(g),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = $T++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = g,
    this.vertexShader = b,
    this.fragmentShader = A,
    this
}
let pb = 0;
class mb {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(n)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new gb(e),
        t.set(e, n)),
        n
    }
}
class gb {
    constructor(e) {
        this.id = pb++,
        this.code = e,
        this.usedTimes = 0
    }
}
function _b(i, e, t, n, r, s, o) {
    const a = new Ag
      , l = new mb
      , c = new Set
      , u = []
      , f = r.logarithmicDepthBuffer
      , h = r.vertexTextures;
    let d = r.precision;
    const _ = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(y) {
        return c.add(y),
        y === 0 ? "uv" : "uv".concat(y)
    }
    function m(y, x, P, U, O) {
        const B = U.fog
          , X = O.geometry
          , H = y.isMeshStandardMaterial ? U.environment : null
          , Y = (y.isMeshStandardMaterial ? t : e).get(y.envMap || H)
          , N = Y && Y.mapping === fc ? Y.image.height : null
          , k = _[y.type];
        y.precision !== null && (d = r.getMaxPrecision(y.precision),
        d !== y.precision && console.warn("THREE.WebGLProgram.getParameters:", y.precision, "not supported, using", d, "instead."));
        const C = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color
          , re = C !== void 0 ? C.length : 0;
        let ue = 0;
        X.morphAttributes.position !== void 0 && (ue = 1),
        X.morphAttributes.normal !== void 0 && (ue = 2),
        X.morphAttributes.color !== void 0 && (ue = 3);
        let we, q, te, fe;
        if (k) {
            const be = Gi[k];
            we = be.vertexShader,
            q = be.fragmentShader
        } else
            we = y.vertexShader,
            q = y.fragmentShader,
            l.update(y),
            te = l.getVertexShaderID(y),
            fe = l.getFragmentShaderID(y);
        const oe = i.getRenderTarget()
          , me = i.state.buffers.depth.getReversed()
          , He = O.isInstancedMesh === !0
          , ze = O.isBatchedMesh === !0
          , Qe = !!y.map
          , et = !!y.matcap
          , De = !!Y
          , I = !!y.aoMap
          , Je = !!y.lightMap
          , Ge = !!y.bumpMap
          , G = !!y.normalMap
          , Ee = !!y.displacementMap
          , Ke = !!y.emissiveMap
          , Ue = !!y.metalnessMap
          , ge = !!y.roughnessMap
          , ht = y.anisotropy > 0
          , D = y.clearcoat > 0
          , M = y.dispersion > 0
          , V = y.iridescence > 0
          , ne = y.sheen > 0
          , ee = y.transmission > 0
          , J = ht && !!y.anisotropyMap
          , Ae = D && !!y.clearcoatMap
          , de = D && !!y.clearcoatNormalMap
          , Ce = D && !!y.clearcoatRoughnessMap
          , $ = V && !!y.iridescenceMap
          , K = V && !!y.iridescenceThicknessMap
          , ae = ne && !!y.sheenColorMap
          , Me = ne && !!y.sheenRoughnessMap
          , Te = !!y.specularMap
          , ce = !!y.specularColorMap
          , Ne = !!y.specularIntensityMap
          , L = ee && !!y.transmissionMap
          , he = ee && !!y.thicknessMap
          , ie = !!y.gradientMap
          , pe = !!y.alphaMap
          , se = y.alphaTest > 0
          , Q = !!y.alphaHash
          , Pe = !!y.extensions;
        let Ve = Br;
        y.toneMapped && (oe === null || oe.isXRRenderTarget === !0) && (Ve = i.toneMapping);
        const gt = {
            shaderID: k,
            shaderType: y.type,
            shaderName: y.name,
            vertexShader: we,
            fragmentShader: q,
            defines: y.defines,
            customVertexShaderID: te,
            customFragmentShaderID: fe,
            isRawShaderMaterial: y.isRawShaderMaterial === !0,
            glslVersion: y.glslVersion,
            precision: d,
            batching: ze,
            batchingColor: ze && O._colorsTexture !== null,
            instancing: He,
            instancingColor: He && O.instanceColor !== null,
            instancingMorph: He && O.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: oe === null ? i.outputColorSpace : oe.isXRRenderTarget === !0 ? oe.texture.colorSpace : Wr,
            alphaToCoverage: !!y.alphaToCoverage,
            map: Qe,
            matcap: et,
            envMap: De,
            envMapMode: De && Y.mapping,
            envMapCubeUVHeight: N,
            aoMap: I,
            lightMap: Je,
            bumpMap: Ge,
            normalMap: G,
            displacementMap: h && Ee,
            emissiveMap: Ke,
            normalMapObjectSpace: G && y.normalMapType === hy,
            normalMapTangentSpace: G && y.normalMapType === fy,
            metalnessMap: Ue,
            roughnessMap: ge,
            anisotropy: ht,
            anisotropyMap: J,
            clearcoat: D,
            clearcoatMap: Ae,
            clearcoatNormalMap: de,
            clearcoatRoughnessMap: Ce,
            dispersion: M,
            iridescence: V,
            iridescenceMap: $,
            iridescenceThicknessMap: K,
            sheen: ne,
            sheenColorMap: ae,
            sheenRoughnessMap: Me,
            specularMap: Te,
            specularColorMap: ce,
            specularIntensityMap: Ne,
            transmission: ee,
            transmissionMap: L,
            thicknessMap: he,
            gradientMap: ie,
            opaque: y.transparent === !1 && y.blending === mo && y.alphaToCoverage === !1,
            alphaMap: pe,
            alphaTest: se,
            alphaHash: Q,
            combine: y.combine,
            mapUv: Qe && g(y.map.channel),
            aoMapUv: I && g(y.aoMap.channel),
            lightMapUv: Je && g(y.lightMap.channel),
            bumpMapUv: Ge && g(y.bumpMap.channel),
            normalMapUv: G && g(y.normalMap.channel),
            displacementMapUv: Ee && g(y.displacementMap.channel),
            emissiveMapUv: Ke && g(y.emissiveMap.channel),
            metalnessMapUv: Ue && g(y.metalnessMap.channel),
            roughnessMapUv: ge && g(y.roughnessMap.channel),
            anisotropyMapUv: J && g(y.anisotropyMap.channel),
            clearcoatMapUv: Ae && g(y.clearcoatMap.channel),
            clearcoatNormalMapUv: de && g(y.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ce && g(y.clearcoatRoughnessMap.channel),
            iridescenceMapUv: $ && g(y.iridescenceMap.channel),
            iridescenceThicknessMapUv: K && g(y.iridescenceThicknessMap.channel),
            sheenColorMapUv: ae && g(y.sheenColorMap.channel),
            sheenRoughnessMapUv: Me && g(y.sheenRoughnessMap.channel),
            specularMapUv: Te && g(y.specularMap.channel),
            specularColorMapUv: ce && g(y.specularColorMap.channel),
            specularIntensityMapUv: Ne && g(y.specularIntensityMap.channel),
            transmissionMapUv: L && g(y.transmissionMap.channel),
            thicknessMapUv: he && g(y.thicknessMap.channel),
            alphaMapUv: pe && g(y.alphaMap.channel),
            vertexTangents: !!X.attributes.tangent && (G || ht),
            vertexColors: y.vertexColors,
            vertexAlphas: y.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4,
            pointsUvs: O.isPoints === !0 && !!X.attributes.uv && (Qe || pe),
            fog: !!B,
            useFog: y.fog === !0,
            fogExp2: !!B && B.isFogExp2,
            flatShading: y.flatShading === !0,
            sizeAttenuation: y.sizeAttenuation === !0,
            logarithmicDepthBuffer: f,
            reverseDepthBuffer: me,
            skinning: O.isSkinnedMesh === !0,
            morphTargets: X.morphAttributes.position !== void 0,
            morphNormals: X.morphAttributes.normal !== void 0,
            morphColors: X.morphAttributes.color !== void 0,
            morphTargetsCount: re,
            morphTextureStride: ue,
            numDirLights: x.directional.length,
            numPointLights: x.point.length,
            numSpotLights: x.spot.length,
            numSpotLightMaps: x.spotLightMap.length,
            numRectAreaLights: x.rectArea.length,
            numHemiLights: x.hemi.length,
            numDirLightShadows: x.directionalShadowMap.length,
            numPointLightShadows: x.pointShadowMap.length,
            numSpotLightShadows: x.spotShadowMap.length,
            numSpotLightShadowsWithMaps: x.numSpotLightShadowsWithMaps,
            numLightProbes: x.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: y.dithering,
            shadowMapEnabled: i.shadowMap.enabled && P.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: Ve,
            decodeVideoTexture: Qe && y.map.isVideoTexture === !0 && pt.getTransfer(y.map.colorSpace) === Mt,
            decodeVideoTextureEmissive: Ke && y.emissiveMap.isVideoTexture === !0 && pt.getTransfer(y.emissiveMap.colorSpace) === Mt,
            premultipliedAlpha: y.premultipliedAlpha,
            doubleSided: y.side === pn,
            flipSided: y.side === an,
            useDepthPacking: y.depthPacking >= 0,
            depthPacking: y.depthPacking || 0,
            index0AttributeName: y.index0AttributeName,
            extensionClipCullDistance: Pe && y.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Pe && y.extensions.multiDraw === !0 || ze) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: y.customProgramCacheKey()
        };
        return gt.vertexUv1s = c.has(1),
        gt.vertexUv2s = c.has(2),
        gt.vertexUv3s = c.has(3),
        c.clear(),
        gt
    }
    function p(y) {
        const x = [];
        if (y.shaderID ? x.push(y.shaderID) : (x.push(y.customVertexShaderID),
        x.push(y.customFragmentShaderID)),
        y.defines !== void 0)
            for (const P in y.defines)
                x.push(P),
                x.push(y.defines[P]);
        return y.isRawShaderMaterial === !1 && (E(x, y),
        S(x, y),
        x.push(i.outputColorSpace)),
        x.push(y.customProgramCacheKey),
        x.join()
    }
    function E(y, x) {
        y.push(x.precision),
        y.push(x.outputColorSpace),
        y.push(x.envMapMode),
        y.push(x.envMapCubeUVHeight),
        y.push(x.mapUv),
        y.push(x.alphaMapUv),
        y.push(x.lightMapUv),
        y.push(x.aoMapUv),
        y.push(x.bumpMapUv),
        y.push(x.normalMapUv),
        y.push(x.displacementMapUv),
        y.push(x.emissiveMapUv),
        y.push(x.metalnessMapUv),
        y.push(x.roughnessMapUv),
        y.push(x.anisotropyMapUv),
        y.push(x.clearcoatMapUv),
        y.push(x.clearcoatNormalMapUv),
        y.push(x.clearcoatRoughnessMapUv),
        y.push(x.iridescenceMapUv),
        y.push(x.iridescenceThicknessMapUv),
        y.push(x.sheenColorMapUv),
        y.push(x.sheenRoughnessMapUv),
        y.push(x.specularMapUv),
        y.push(x.specularColorMapUv),
        y.push(x.specularIntensityMapUv),
        y.push(x.transmissionMapUv),
        y.push(x.thicknessMapUv),
        y.push(x.combine),
        y.push(x.fogExp2),
        y.push(x.sizeAttenuation),
        y.push(x.morphTargetsCount),
        y.push(x.morphAttributeCount),
        y.push(x.numDirLights),
        y.push(x.numPointLights),
        y.push(x.numSpotLights),
        y.push(x.numSpotLightMaps),
        y.push(x.numHemiLights),
        y.push(x.numRectAreaLights),
        y.push(x.numDirLightShadows),
        y.push(x.numPointLightShadows),
        y.push(x.numSpotLightShadows),
        y.push(x.numSpotLightShadowsWithMaps),
        y.push(x.numLightProbes),
        y.push(x.shadowMapType),
        y.push(x.toneMapping),
        y.push(x.numClippingPlanes),
        y.push(x.numClipIntersection),
        y.push(x.depthPacking)
    }
    function S(y, x) {
        a.disableAll(),
        x.supportsVertexTextures && a.enable(0),
        x.instancing && a.enable(1),
        x.instancingColor && a.enable(2),
        x.instancingMorph && a.enable(3),
        x.matcap && a.enable(4),
        x.envMap && a.enable(5),
        x.normalMapObjectSpace && a.enable(6),
        x.normalMapTangentSpace && a.enable(7),
        x.clearcoat && a.enable(8),
        x.iridescence && a.enable(9),
        x.alphaTest && a.enable(10),
        x.vertexColors && a.enable(11),
        x.vertexAlphas && a.enable(12),
        x.vertexUv1s && a.enable(13),
        x.vertexUv2s && a.enable(14),
        x.vertexUv3s && a.enable(15),
        x.vertexTangents && a.enable(16),
        x.anisotropy && a.enable(17),
        x.alphaHash && a.enable(18),
        x.batching && a.enable(19),
        x.dispersion && a.enable(20),
        x.batchingColor && a.enable(21),
        y.push(a.mask),
        a.disableAll(),
        x.fog && a.enable(0),
        x.useFog && a.enable(1),
        x.flatShading && a.enable(2),
        x.logarithmicDepthBuffer && a.enable(3),
        x.reverseDepthBuffer && a.enable(4),
        x.skinning && a.enable(5),
        x.morphTargets && a.enable(6),
        x.morphNormals && a.enable(7),
        x.morphColors && a.enable(8),
        x.premultipliedAlpha && a.enable(9),
        x.shadowMapEnabled && a.enable(10),
        x.doubleSided && a.enable(11),
        x.flipSided && a.enable(12),
        x.useDepthPacking && a.enable(13),
        x.dithering && a.enable(14),
        x.transmission && a.enable(15),
        x.sheen && a.enable(16),
        x.opaque && a.enable(17),
        x.pointsUvs && a.enable(18),
        x.decodeVideoTexture && a.enable(19),
        x.decodeVideoTextureEmissive && a.enable(20),
        x.alphaToCoverage && a.enable(21),
        y.push(a.mask)
    }
    function v(y) {
        const x = _[y.type];
        let P;
        if (x) {
            const U = Gi[x];
            P = Wy.clone(U.uniforms)
        } else
            P = y.uniforms;
        return P
    }
    function b(y, x) {
        let P;
        for (let U = 0, O = u.length; U < O; U++) {
            const B = u[U];
            if (B.cacheKey === x) {
                P = B,
                ++P.usedTimes;
                break
            }
        }
        return P === void 0 && (P = new db(i,x,y,s),
        u.push(P)),
        P
    }
    function A(y) {
        if (--y.usedTimes === 0) {
            const x = u.indexOf(y);
            u[x] = u[u.length - 1],
            u.pop(),
            y.destroy()
        }
    }
    function T(y) {
        l.remove(y)
    }
    function R() {
        l.dispose()
    }
    return {
        getParameters: m,
        getProgramCacheKey: p,
        getUniforms: v,
        acquireProgram: b,
        releaseProgram: A,
        releaseShaderCache: T,
        programs: u,
        dispose: R
    }
}
function vb() {
    let i = new WeakMap;
    function e(o) {
        return i.has(o)
    }
    function t(o) {
        let a = i.get(o);
        return a === void 0 && (a = {},
        i.set(o, a)),
        a
    }
    function n(o) {
        i.delete(o)
    }
    function r(o, a, l) {
        i.get(o)[a] = l
    }
    function s() {
        i = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: r,
        dispose: s
    }
}
function xb(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id
}
function xp(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id
}
function yp() {
    const i = [];
    let e = 0;
    const t = []
      , n = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        n.length = 0,
        r.length = 0
    }
    function o(f, h, d, _, g, m) {
        let p = i[e];
        return p === void 0 ? (p = {
            id: f.id,
            object: f,
            geometry: h,
            material: d,
            groupOrder: _,
            renderOrder: f.renderOrder,
            z: g,
            group: m
        },
        i[e] = p) : (p.id = f.id,
        p.object = f,
        p.geometry = h,
        p.material = d,
        p.groupOrder = _,
        p.renderOrder = f.renderOrder,
        p.z = g,
        p.group = m),
        e++,
        p
    }
    function a(f, h, d, _, g, m) {
        const p = o(f, h, d, _, g, m);
        d.transmission > 0 ? n.push(p) : d.transparent === !0 ? r.push(p) : t.push(p)
    }
    function l(f, h, d, _, g, m) {
        const p = o(f, h, d, _, g, m);
        d.transmission > 0 ? n.unshift(p) : d.transparent === !0 ? r.unshift(p) : t.unshift(p)
    }
    function c(f, h) {
        t.length > 1 && t.sort(f || xb),
        n.length > 1 && n.sort(h || xp),
        r.length > 1 && r.sort(h || xp)
    }
    function u() {
        for (let f = e, h = i.length; f < h; f++) {
            const d = i[f];
            if (d.id === null)
                break;
            d.id = null,
            d.object = null,
            d.geometry = null,
            d.material = null,
            d.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}
function yb() {
    let i = new WeakMap;
    function e(n, r) {
        const s = i.get(n);
        let o;
        return s === void 0 ? (o = new yp,
        i.set(n, [o])) : r >= s.length ? (o = new yp,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        i = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function Sb() {
    const i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0)
                return i[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new Z,
                    color: new St
                };
                break;
            case "SpotLight":
                t = {
                    position: new Z,
                    direction: new Z,
                    color: new St,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new Z,
                    color: new St,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new Z,
                    skyColor: new St,
                    groundColor: new St
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new St,
                    position: new Z,
                    halfWidth: new Z,
                    halfHeight: new Z
                };
                break
            }
            return i[e.id] = t,
            t
        }
    }
}
function Eb() {
    const i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0)
                return i[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new lt
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new lt
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new lt,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return i[e.id] = t,
            t
        }
    }
}
let Mb = 0;
function Tb(i, e) {
    return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0)
}
function bb(i) {
    const e = new Sb
      , t = Eb()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        n.probe.push(new Z);
    const r = new Z
      , s = new jt
      , o = new jt;
    function a(c) {
        let u = 0
          , f = 0
          , h = 0;
        for (let y = 0; y < 9; y++)
            n.probe[y].set(0, 0, 0);
        let d = 0
          , _ = 0
          , g = 0
          , m = 0
          , p = 0
          , E = 0
          , S = 0
          , v = 0
          , b = 0
          , A = 0
          , T = 0;
        c.sort(Tb);
        for (let y = 0, x = c.length; y < x; y++) {
            const P = c[y]
              , U = P.color
              , O = P.intensity
              , B = P.distance
              , X = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
            if (P.isAmbientLight)
                u += U.r * O,
                f += U.g * O,
                h += U.b * O;
            else if (P.isLightProbe) {
                for (let H = 0; H < 9; H++)
                    n.probe[H].addScaledVector(P.sh.coefficients[H], O);
                T++
            } else if (P.isDirectionalLight) {
                const H = e.get(P);
                if (H.color.copy(P.color).multiplyScalar(P.intensity),
                P.castShadow) {
                    const Y = P.shadow
                      , N = t.get(P);
                    N.shadowIntensity = Y.intensity,
                    N.shadowBias = Y.bias,
                    N.shadowNormalBias = Y.normalBias,
                    N.shadowRadius = Y.radius,
                    N.shadowMapSize = Y.mapSize,
                    n.directionalShadow[d] = N,
                    n.directionalShadowMap[d] = X,
                    n.directionalShadowMatrix[d] = P.shadow.matrix,
                    E++
                }
                n.directional[d] = H,
                d++
            } else if (P.isSpotLight) {
                const H = e.get(P);
                H.position.setFromMatrixPosition(P.matrixWorld),
                H.color.copy(U).multiplyScalar(O),
                H.distance = B,
                H.coneCos = Math.cos(P.angle),
                H.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)),
                H.decay = P.decay,
                n.spot[g] = H;
                const Y = P.shadow;
                if (P.map && (n.spotLightMap[b] = P.map,
                b++,
                Y.updateMatrices(P),
                P.castShadow && A++),
                n.spotLightMatrix[g] = Y.matrix,
                P.castShadow) {
                    const N = t.get(P);
                    N.shadowIntensity = Y.intensity,
                    N.shadowBias = Y.bias,
                    N.shadowNormalBias = Y.normalBias,
                    N.shadowRadius = Y.radius,
                    N.shadowMapSize = Y.mapSize,
                    n.spotShadow[g] = N,
                    n.spotShadowMap[g] = X,
                    v++
                }
                g++
            } else if (P.isRectAreaLight) {
                const H = e.get(P);
                H.color.copy(U).multiplyScalar(O),
                H.halfWidth.set(P.width * .5, 0, 0),
                H.halfHeight.set(0, P.height * .5, 0),
                n.rectArea[m] = H,
                m++
            } else if (P.isPointLight) {
                const H = e.get(P);
                if (H.color.copy(P.color).multiplyScalar(P.intensity),
                H.distance = P.distance,
                H.decay = P.decay,
                P.castShadow) {
                    const Y = P.shadow
                      , N = t.get(P);
                    N.shadowIntensity = Y.intensity,
                    N.shadowBias = Y.bias,
                    N.shadowNormalBias = Y.normalBias,
                    N.shadowRadius = Y.radius,
                    N.shadowMapSize = Y.mapSize,
                    N.shadowCameraNear = Y.camera.near,
                    N.shadowCameraFar = Y.camera.far,
                    n.pointShadow[_] = N,
                    n.pointShadowMap[_] = X,
                    n.pointShadowMatrix[_] = P.shadow.matrix,
                    S++
                }
                n.point[_] = H,
                _++
            } else if (P.isHemisphereLight) {
                const H = e.get(P);
                H.skyColor.copy(P.color).multiplyScalar(O),
                H.groundColor.copy(P.groundColor).multiplyScalar(O),
                n.hemi[p] = H,
                p++
            }
        }
        m > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Se.LTC_FLOAT_1,
        n.rectAreaLTC2 = Se.LTC_FLOAT_2) : (n.rectAreaLTC1 = Se.LTC_HALF_1,
        n.rectAreaLTC2 = Se.LTC_HALF_2)),
        n.ambient[0] = u,
        n.ambient[1] = f,
        n.ambient[2] = h;
        const R = n.hash;
        (R.directionalLength !== d || R.pointLength !== _ || R.spotLength !== g || R.rectAreaLength !== m || R.hemiLength !== p || R.numDirectionalShadows !== E || R.numPointShadows !== S || R.numSpotShadows !== v || R.numSpotMaps !== b || R.numLightProbes !== T) && (n.directional.length = d,
        n.spot.length = g,
        n.rectArea.length = m,
        n.point.length = _,
        n.hemi.length = p,
        n.directionalShadow.length = E,
        n.directionalShadowMap.length = E,
        n.pointShadow.length = S,
        n.pointShadowMap.length = S,
        n.spotShadow.length = v,
        n.spotShadowMap.length = v,
        n.directionalShadowMatrix.length = E,
        n.pointShadowMatrix.length = S,
        n.spotLightMatrix.length = v + b - A,
        n.spotLightMap.length = b,
        n.numSpotLightShadowsWithMaps = A,
        n.numLightProbes = T,
        R.directionalLength = d,
        R.pointLength = _,
        R.spotLength = g,
        R.rectAreaLength = m,
        R.hemiLength = p,
        R.numDirectionalShadows = E,
        R.numPointShadows = S,
        R.numSpotShadows = v,
        R.numSpotMaps = b,
        R.numLightProbes = T,
        n.version = Mb++)
    }
    function l(c, u) {
        let f = 0
          , h = 0
          , d = 0
          , _ = 0
          , g = 0;
        const m = u.matrixWorldInverse;
        for (let p = 0, E = c.length; p < E; p++) {
            const S = c[p];
            if (S.isDirectionalLight) {
                const v = n.directional[f];
                v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(m),
                f++
            } else if (S.isSpotLight) {
                const v = n.spot[d];
                v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(m),
                v.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                v.direction.sub(r),
                v.direction.transformDirection(m),
                d++
            } else if (S.isRectAreaLight) {
                const v = n.rectArea[_];
                v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(m),
                o.identity(),
                s.copy(S.matrixWorld),
                s.premultiply(m),
                o.extractRotation(s),
                v.halfWidth.set(S.width * .5, 0, 0),
                v.halfHeight.set(0, S.height * .5, 0),
                v.halfWidth.applyMatrix4(o),
                v.halfHeight.applyMatrix4(o),
                _++
            } else if (S.isPointLight) {
                const v = n.point[h];
                v.position.setFromMatrixPosition(S.matrixWorld),
                v.position.applyMatrix4(m),
                h++
            } else if (S.isHemisphereLight) {
                const v = n.hemi[g];
                v.direction.setFromMatrixPosition(S.matrixWorld),
                v.direction.transformDirection(m),
                g++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: n
    }
}
function Sp(i) {
    const e = new bb(i)
      , t = []
      , n = [];
    function r(u) {
        c.camera = u,
        t.length = 0,
        n.length = 0
    }
    function s(u) {
        t.push(u)
    }
    function o(u) {
        n.push(u)
    }
    function a() {
        e.setup(t)
    }
    function l(u) {
        e.setupView(t, u)
    }
    const c = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: r,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}
function wb(i) {
    let e = new WeakMap;
    function t(r, s=0) {
        const o = e.get(r);
        let a;
        return o === void 0 ? (a = new Sp(i),
        e.set(r, [a])) : s >= o.length ? (a = new Sp(i),
        o.push(a)) : a = o[s],
        a
    }
    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
const Ab = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}"
  , Rb = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function Cb(i, e, t) {
    let n = new Ug;
    const r = new lt
      , s = new lt
      , o = new Wt
      , a = new Qy({
        depthPacking: uy
    })
      , l = new eS
      , c = {}
      , u = t.maxTextureSize
      , f = {
        [_r]: an,
        [an]: _r,
        [pn]: pn
    }
      , h = new zi({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new lt
            },
            radius: {
                value: 4
            }
        },
        vertexShader: Ab,
        fragmentShader: Rb
    })
      , d = h.clone();
    d.defines.HORIZONTAL_PASS = 1;
    const _ = new $r;
    _.setAttribute("position", new Ai(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const g = new Wn(_,h)
      , m = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = dg;
    let p = this.type;
    this.render = function(A, T, R) {
        if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || A.length === 0)
            return;
        const y = i.getRenderTarget()
          , x = i.getActiveCubeFace()
          , P = i.getActiveMipmapLevel()
          , U = i.state;
        U.setBlending(Zi),
        U.buffers.color.setClear(1, 1, 1, 1),
        U.buffers.depth.setTest(!0),
        U.setScissorTest(!1);
        const O = p !== rr && this.type === rr
          , B = p === rr && this.type !== rr;
        for (let X = 0, H = A.length; X < H; X++) {
            const Y = A[X]
              , N = Y.shadow;
            if (N === void 0) {
                console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
                continue
            }
            if (N.autoUpdate === !1 && N.needsUpdate === !1)
                continue;
            r.copy(N.mapSize);
            const k = N.getFrameExtents();
            if (r.multiply(k),
            s.copy(N.mapSize),
            (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / k.x),
            r.x = s.x * k.x,
            N.mapSize.x = s.x),
            r.y > u && (s.y = Math.floor(u / k.y),
            r.y = s.y * k.y,
            N.mapSize.y = s.y)),
            N.map === null || O === !0 || B === !0) {
                const re = this.type !== rr ? {
                    minFilter: Fi,
                    magFilter: Fi
                } : {};
                N.map !== null && N.map.dispose(),
                N.map = new Bi(r.x,r.y,re),
                N.map.texture.name = Y.name + ".shadowMap",
                N.camera.updateProjectionMatrix()
            }
            i.setRenderTarget(N.map),
            i.clear();
            const C = N.getViewportCount();
            for (let re = 0; re < C; re++) {
                const ue = N.getViewport(re);
                o.set(s.x * ue.x, s.y * ue.y, s.x * ue.z, s.y * ue.w),
                U.viewport(o),
                N.updateMatrices(Y, re),
                n = N.getFrustum(),
                v(T, R, N.camera, Y, this.type)
            }
            N.isPointLightShadow !== !0 && this.type === rr && E(N, R),
            N.needsUpdate = !1
        }
        p = this.type,
        m.needsUpdate = !1,
        i.setRenderTarget(y, x, P)
    }
    ;
    function E(A, T) {
        const R = e.update(g);
        h.defines.VSM_SAMPLES !== A.blurSamples && (h.defines.VSM_SAMPLES = A.blurSamples,
        d.defines.VSM_SAMPLES = A.blurSamples,
        h.needsUpdate = !0,
        d.needsUpdate = !0),
        A.mapPass === null && (A.mapPass = new Bi(r.x,r.y)),
        h.uniforms.shadow_pass.value = A.map.texture,
        h.uniforms.resolution.value = A.mapSize,
        h.uniforms.radius.value = A.radius,
        i.setRenderTarget(A.mapPass),
        i.clear(),
        i.renderBufferDirect(T, null, R, h, g, null),
        d.uniforms.shadow_pass.value = A.mapPass.texture,
        d.uniforms.resolution.value = A.mapSize,
        d.uniforms.radius.value = A.radius,
        i.setRenderTarget(A.map),
        i.clear(),
        i.renderBufferDirect(T, null, R, d, g, null)
    }
    function S(A, T, R, y) {
        let x = null;
        const P = R.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (P !== void 0)
            x = P;
        else if (x = R.isPointLight === !0 ? l : a,
        i.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0 || T.alphaToCoverage === !0) {
            const U = x.uuid
              , O = T.uuid;
            let B = c[U];
            B === void 0 && (B = {},
            c[U] = B);
            let X = B[O];
            X === void 0 && (X = x.clone(),
            B[O] = X,
            T.addEventListener("dispose", b)),
            x = X
        }
        if (x.visible = T.visible,
        x.wireframe = T.wireframe,
        y === rr ? x.side = T.shadowSide !== null ? T.shadowSide : T.side : x.side = T.shadowSide !== null ? T.shadowSide : f[T.side],
        x.alphaMap = T.alphaMap,
        x.alphaTest = T.alphaToCoverage === !0 ? .5 : T.alphaTest,
        x.map = T.map,
        x.clipShadows = T.clipShadows,
        x.clippingPlanes = T.clippingPlanes,
        x.clipIntersection = T.clipIntersection,
        x.displacementMap = T.displacementMap,
        x.displacementScale = T.displacementScale,
        x.displacementBias = T.displacementBias,
        x.wireframeLinewidth = T.wireframeLinewidth,
        x.linewidth = T.linewidth,
        R.isPointLight === !0 && x.isMeshDistanceMaterial === !0) {
            const U = i.properties.get(x);
            U.light = R
        }
        return x
    }
    function v(A, T, R, y, x) {
        if (A.visible === !1)
            return;
        if (A.layers.test(T.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && x === rr) && (!A.frustumCulled || n.intersectsObject(A))) {
            A.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, A.matrixWorld);
            const O = e.update(A)
              , B = A.material;
            if (Array.isArray(B)) {
                const X = O.groups;
                for (let H = 0, Y = X.length; H < Y; H++) {
                    const N = X[H]
                      , k = B[N.materialIndex];
                    if (k && k.visible) {
                        const C = S(A, k, y, x);
                        A.onBeforeShadow(i, A, T, R, O, C, N),
                        i.renderBufferDirect(R, null, O, C, A, N),
                        A.onAfterShadow(i, A, T, R, O, C, N)
                    }
                }
            } else if (B.visible) {
                const X = S(A, B, y, x);
                A.onBeforeShadow(i, A, T, R, O, X, null),
                i.renderBufferDirect(R, null, O, X, A, null),
                A.onAfterShadow(i, A, T, R, O, X, null)
            }
        }
        const U = A.children;
        for (let O = 0, B = U.length; O < B; O++)
            v(U[O], T, R, y, x)
    }
    function b(A) {
        A.target.removeEventListener("dispose", b);
        for (const R in c) {
            const y = c[R]
              , x = A.target.uuid;
            x in y && (y[x].dispose(),
            delete y[x])
        }
    }
}
const Pb = {
    [Ku]: Ql,
    [Zu]: ef,
    [Ju]: tf,
    [bo]: Qu,
    [Ql]: Ku,
    [ef]: Zu,
    [tf]: Ju,
    [Qu]: bo
};
function Db(i, e) {
    function t() {
        let L = !1;
        const he = new Wt;
        let ie = null;
        const pe = new Wt(0,0,0,0);
        return {
            setMask: function(se) {
                ie !== se && !L && (i.colorMask(se, se, se, se),
                ie = se)
            },
            setLocked: function(se) {
                L = se
            },
            setClear: function(se, Q, Pe, Ve, gt) {
                gt === !0 && (se *= Ve,
                Q *= Ve,
                Pe *= Ve),
                he.set(se, Q, Pe, Ve),
                pe.equals(he) === !1 && (i.clearColor(se, Q, Pe, Ve),
                pe.copy(he))
            },
            reset: function() {
                L = !1,
                ie = null,
                pe.set(-1, 0, 0, 0)
            }
        }
    }
    function n() {
        let L = !1
          , he = !1
          , ie = null
          , pe = null
          , se = null;
        return {
            setReversed: function(Q) {
                if (he !== Q) {
                    const Pe = e.get("EXT_clip_control");
                    Q ? Pe.clipControlEXT(Pe.LOWER_LEFT_EXT, Pe.ZERO_TO_ONE_EXT) : Pe.clipControlEXT(Pe.LOWER_LEFT_EXT, Pe.NEGATIVE_ONE_TO_ONE_EXT),
                    he = Q;
                    const Ve = se;
                    se = null,
                    this.setClear(Ve)
                }
            },
            getReversed: function() {
                return he
            },
            setTest: function(Q) {
                Q ? oe(i.DEPTH_TEST) : me(i.DEPTH_TEST)
            },
            setMask: function(Q) {
                ie !== Q && !L && (i.depthMask(Q),
                ie = Q)
            },
            setFunc: function(Q) {
                if (he && (Q = Pb[Q]),
                pe !== Q) {
                    switch (Q) {
                    case Ku:
                        i.depthFunc(i.NEVER);
                        break;
                    case Ql:
                        i.depthFunc(i.ALWAYS);
                        break;
                    case Zu:
                        i.depthFunc(i.LESS);
                        break;
                    case bo:
                        i.depthFunc(i.LEQUAL);
                        break;
                    case Ju:
                        i.depthFunc(i.EQUAL);
                        break;
                    case Qu:
                        i.depthFunc(i.GEQUAL);
                        break;
                    case ef:
                        i.depthFunc(i.GREATER);
                        break;
                    case tf:
                        i.depthFunc(i.NOTEQUAL);
                        break;
                    default:
                        i.depthFunc(i.LEQUAL)
                    }
                    pe = Q
                }
            },
            setLocked: function(Q) {
                L = Q
            },
            setClear: function(Q) {
                se !== Q && (he && (Q = 1 - Q),
                i.clearDepth(Q),
                se = Q)
            },
            reset: function() {
                L = !1,
                ie = null,
                pe = null,
                se = null,
                he = !1
            }
        }
    }
    function r() {
        let L = !1
          , he = null
          , ie = null
          , pe = null
          , se = null
          , Q = null
          , Pe = null
          , Ve = null
          , gt = null;
        return {
            setTest: function(be) {
                L || (be ? oe(i.STENCIL_TEST) : me(i.STENCIL_TEST))
            },
            setMask: function(be) {
                he !== be && !L && (i.stencilMask(be),
                he = be)
            },
            setFunc: function(be, Oe, tt) {
                (ie !== be || pe !== Oe || se !== tt) && (i.stencilFunc(be, Oe, tt),
                ie = be,
                pe = Oe,
                se = tt)
            },
            setOp: function(be, Oe, tt) {
                (Q !== be || Pe !== Oe || Ve !== tt) && (i.stencilOp(be, Oe, tt),
                Q = be,
                Pe = Oe,
                Ve = tt)
            },
            setLocked: function(be) {
                L = be
            },
            setClear: function(be) {
                gt !== be && (i.clearStencil(be),
                gt = be)
            },
            reset: function() {
                L = !1,
                he = null,
                ie = null,
                pe = null,
                se = null,
                Q = null,
                Pe = null,
                Ve = null,
                gt = null
            }
        }
    }
    const s = new t
      , o = new n
      , a = new r
      , l = new WeakMap
      , c = new WeakMap;
    let u = {}
      , f = {}
      , h = new WeakMap
      , d = []
      , _ = null
      , g = !1
      , m = null
      , p = null
      , E = null
      , S = null
      , v = null
      , b = null
      , A = null
      , T = new St(0,0,0)
      , R = 0
      , y = !1
      , x = null
      , P = null
      , U = null
      , O = null
      , B = null;
    const X = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let H = !1
      , Y = 0;
    const N = i.getParameter(i.VERSION);
    N.indexOf("WebGL") !== -1 ? (Y = parseFloat(/^WebGL (\d)/.exec(N)[1]),
    H = Y >= 1) : N.indexOf("OpenGL ES") !== -1 && (Y = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),
    H = Y >= 2);
    let k = null
      , C = {};
    const re = i.getParameter(i.SCISSOR_BOX)
      , ue = i.getParameter(i.VIEWPORT)
      , we = new Wt().fromArray(re)
      , q = new Wt().fromArray(ue);
    function te(L, he, ie, pe) {
        const se = new Uint8Array(4)
          , Q = i.createTexture();
        i.bindTexture(L, Q),
        i.texParameteri(L, i.TEXTURE_MIN_FILTER, i.NEAREST),
        i.texParameteri(L, i.TEXTURE_MAG_FILTER, i.NEAREST);
        for (let Pe = 0; Pe < ie; Pe++)
            L === i.TEXTURE_3D || L === i.TEXTURE_2D_ARRAY ? i.texImage3D(he, 0, i.RGBA, 1, 1, pe, 0, i.RGBA, i.UNSIGNED_BYTE, se) : i.texImage2D(he + Pe, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, se);
        return Q
    }
    const fe = {};
    fe[i.TEXTURE_2D] = te(i.TEXTURE_2D, i.TEXTURE_2D, 1),
    fe[i.TEXTURE_CUBE_MAP] = te(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    fe[i.TEXTURE_2D_ARRAY] = te(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1),
    fe[i.TEXTURE_3D] = te(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    oe(i.DEPTH_TEST),
    o.setFunc(bo),
    Ge(!1),
    G(bd),
    oe(i.CULL_FACE),
    I(Zi);
    function oe(L) {
        u[L] !== !0 && (i.enable(L),
        u[L] = !0)
    }
    function me(L) {
        u[L] !== !1 && (i.disable(L),
        u[L] = !1)
    }
    function He(L, he) {
        return f[L] !== he ? (i.bindFramebuffer(L, he),
        f[L] = he,
        L === i.DRAW_FRAMEBUFFER && (f[i.FRAMEBUFFER] = he),
        L === i.FRAMEBUFFER && (f[i.DRAW_FRAMEBUFFER] = he),
        !0) : !1
    }
    function ze(L, he) {
        let ie = d
          , pe = !1;
        if (L) {
            ie = h.get(he),
            ie === void 0 && (ie = [],
            h.set(he, ie));
            const se = L.textures;
            if (ie.length !== se.length || ie[0] !== i.COLOR_ATTACHMENT0) {
                for (let Q = 0, Pe = se.length; Q < Pe; Q++)
                    ie[Q] = i.COLOR_ATTACHMENT0 + Q;
                ie.length = se.length,
                pe = !0
            }
        } else
            ie[0] !== i.BACK && (ie[0] = i.BACK,
            pe = !0);
        pe && i.drawBuffers(ie)
    }
    function Qe(L) {
        return _ !== L ? (i.useProgram(L),
        _ = L,
        !0) : !1
    }
    const et = {
        [us]: i.FUNC_ADD,
        [Fx]: i.FUNC_SUBTRACT,
        [Bx]: i.FUNC_REVERSE_SUBTRACT
    };
    et[zx] = i.MIN,
    et[kx] = i.MAX;
    const De = {
        [Hx]: i.ZERO,
        [Vx]: i.ONE,
        [Gx]: i.SRC_COLOR,
        [$u]: i.SRC_ALPHA,
        [jx]: i.SRC_ALPHA_SATURATE,
        [Yx]: i.DST_COLOR,
        [Xx]: i.DST_ALPHA,
        [Wx]: i.ONE_MINUS_SRC_COLOR,
        [ju]: i.ONE_MINUS_SRC_ALPHA,
        [$x]: i.ONE_MINUS_DST_COLOR,
        [qx]: i.ONE_MINUS_DST_ALPHA,
        [Kx]: i.CONSTANT_COLOR,
        [Zx]: i.ONE_MINUS_CONSTANT_COLOR,
        [Jx]: i.CONSTANT_ALPHA,
        [Qx]: i.ONE_MINUS_CONSTANT_ALPHA
    };
    function I(L, he, ie, pe, se, Q, Pe, Ve, gt, be) {
        if (L === Zi) {
            g === !0 && (me(i.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (oe(i.BLEND),
        g = !0),
        L !== Ox) {
            if (L !== m || be !== y) {
                if ((p !== us || v !== us) && (i.blendEquation(i.FUNC_ADD),
                p = us,
                v = us),
                be)
                    switch (L) {
                    case mo:
                        i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                        break;
                    case wd:
                        i.blendFunc(i.ONE, i.ONE);
                        break;
                    case Ad:
                        i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                        break;
                    case Rd:
                        i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", L);
                        break
                    }
                else
                    switch (L) {
                    case mo:
                        i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
                        break;
                    case wd:
                        i.blendFunc(i.SRC_ALPHA, i.ONE);
                        break;
                    case Ad:
                        i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
                        break;
                    case Rd:
                        i.blendFunc(i.ZERO, i.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", L);
                        break
                    }
                E = null,
                S = null,
                b = null,
                A = null,
                T.set(0, 0, 0),
                R = 0,
                m = L,
                y = be
            }
            return
        }
        se = se || he,
        Q = Q || ie,
        Pe = Pe || pe,
        (he !== p || se !== v) && (i.blendEquationSeparate(et[he], et[se]),
        p = he,
        v = se),
        (ie !== E || pe !== S || Q !== b || Pe !== A) && (i.blendFuncSeparate(De[ie], De[pe], De[Q], De[Pe]),
        E = ie,
        S = pe,
        b = Q,
        A = Pe),
        (Ve.equals(T) === !1 || gt !== R) && (i.blendColor(Ve.r, Ve.g, Ve.b, gt),
        T.copy(Ve),
        R = gt),
        m = L,
        y = !1
    }
    function Je(L, he) {
        L.side === pn ? me(i.CULL_FACE) : oe(i.CULL_FACE);
        let ie = L.side === an;
        he && (ie = !ie),
        Ge(ie),
        L.blending === mo && L.transparent === !1 ? I(Zi) : I(L.blending, L.blendEquation, L.blendSrc, L.blendDst, L.blendEquationAlpha, L.blendSrcAlpha, L.blendDstAlpha, L.blendColor, L.blendAlpha, L.premultipliedAlpha),
        o.setFunc(L.depthFunc),
        o.setTest(L.depthTest),
        o.setMask(L.depthWrite),
        s.setMask(L.colorWrite);
        const pe = L.stencilWrite;
        a.setTest(pe),
        pe && (a.setMask(L.stencilWriteMask),
        a.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask),
        a.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)),
        Ke(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits),
        L.alphaToCoverage === !0 ? oe(i.SAMPLE_ALPHA_TO_COVERAGE) : me(i.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Ge(L) {
        x !== L && (L ? i.frontFace(i.CW) : i.frontFace(i.CCW),
        x = L)
    }
    function G(L) {
        L !== Ix ? (oe(i.CULL_FACE),
        L !== P && (L === bd ? i.cullFace(i.BACK) : L === Ux ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : me(i.CULL_FACE),
        P = L
    }
    function Ee(L) {
        L !== U && (H && i.lineWidth(L),
        U = L)
    }
    function Ke(L, he, ie) {
        L ? (oe(i.POLYGON_OFFSET_FILL),
        (O !== he || B !== ie) && (i.polygonOffset(he, ie),
        O = he,
        B = ie)) : me(i.POLYGON_OFFSET_FILL)
    }
    function Ue(L) {
        L ? oe(i.SCISSOR_TEST) : me(i.SCISSOR_TEST)
    }
    function ge(L) {
        L === void 0 && (L = i.TEXTURE0 + X - 1),
        k !== L && (i.activeTexture(L),
        k = L)
    }
    function ht(L, he, ie) {
        ie === void 0 && (k === null ? ie = i.TEXTURE0 + X - 1 : ie = k);
        let pe = C[ie];
        pe === void 0 && (pe = {
            type: void 0,
            texture: void 0
        },
        C[ie] = pe),
        (pe.type !== L || pe.texture !== he) && (k !== ie && (i.activeTexture(ie),
        k = ie),
        i.bindTexture(L, he || fe[L]),
        pe.type = L,
        pe.texture = he)
    }
    function D() {
        const L = C[k];
        L !== void 0 && L.type !== void 0 && (i.bindTexture(L.type, null),
        L.type = void 0,
        L.texture = void 0)
    }
    function M() {
        try {
            i.compressedTexImage2D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function V() {
        try {
            i.compressedTexImage3D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function ne() {
        try {
            i.texSubImage2D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function ee() {
        try {
            i.texSubImage3D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function J() {
        try {
            i.compressedTexSubImage2D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function Ae() {
        try {
            i.compressedTexSubImage3D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function de() {
        try {
            i.texStorage2D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function Ce() {
        try {
            i.texStorage3D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function $() {
        try {
            i.texImage2D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function K() {
        try {
            i.texImage3D(...arguments)
        } catch (L) {
            console.error("THREE.WebGLState:", L)
        }
    }
    function ae(L) {
        we.equals(L) === !1 && (i.scissor(L.x, L.y, L.z, L.w),
        we.copy(L))
    }
    function Me(L) {
        q.equals(L) === !1 && (i.viewport(L.x, L.y, L.z, L.w),
        q.copy(L))
    }
    function Te(L, he) {
        let ie = c.get(he);
        ie === void 0 && (ie = new WeakMap,
        c.set(he, ie));
        let pe = ie.get(L);
        pe === void 0 && (pe = i.getUniformBlockIndex(he, L.name),
        ie.set(L, pe))
    }
    function ce(L, he) {
        const pe = c.get(he).get(L);
        l.get(he) !== pe && (i.uniformBlockBinding(he, pe, L.__bindingPointIndex),
        l.set(he, pe))
    }
    function Ne() {
        i.disable(i.BLEND),
        i.disable(i.CULL_FACE),
        i.disable(i.DEPTH_TEST),
        i.disable(i.POLYGON_OFFSET_FILL),
        i.disable(i.SCISSOR_TEST),
        i.disable(i.STENCIL_TEST),
        i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
        i.blendEquation(i.FUNC_ADD),
        i.blendFunc(i.ONE, i.ZERO),
        i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
        i.blendColor(0, 0, 0, 0),
        i.colorMask(!0, !0, !0, !0),
        i.clearColor(0, 0, 0, 0),
        i.depthMask(!0),
        i.depthFunc(i.LESS),
        o.setReversed(!1),
        i.clearDepth(1),
        i.stencilMask(4294967295),
        i.stencilFunc(i.ALWAYS, 0, 4294967295),
        i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
        i.clearStencil(0),
        i.cullFace(i.BACK),
        i.frontFace(i.CCW),
        i.polygonOffset(0, 0),
        i.activeTexture(i.TEXTURE0),
        i.bindFramebuffer(i.FRAMEBUFFER, null),
        i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
        i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
        i.useProgram(null),
        i.lineWidth(1),
        i.scissor(0, 0, i.canvas.width, i.canvas.height),
        i.viewport(0, 0, i.canvas.width, i.canvas.height),
        u = {},
        k = null,
        C = {},
        f = {},
        h = new WeakMap,
        d = [],
        _ = null,
        g = !1,
        m = null,
        p = null,
        E = null,
        S = null,
        v = null,
        b = null,
        A = null,
        T = new St(0,0,0),
        R = 0,
        y = !1,
        x = null,
        P = null,
        U = null,
        O = null,
        B = null,
        we.set(0, 0, i.canvas.width, i.canvas.height),
        q.set(0, 0, i.canvas.width, i.canvas.height),
        s.reset(),
        o.reset(),
        a.reset()
    }
    return {
        buffers: {
            color: s,
            depth: o,
            stencil: a
        },
        enable: oe,
        disable: me,
        bindFramebuffer: He,
        drawBuffers: ze,
        useProgram: Qe,
        setBlending: I,
        setMaterial: Je,
        setFlipSided: Ge,
        setCullFace: G,
        setLineWidth: Ee,
        setPolygonOffset: Ke,
        setScissorTest: Ue,
        activeTexture: ge,
        bindTexture: ht,
        unbindTexture: D,
        compressedTexImage2D: M,
        compressedTexImage3D: V,
        texImage2D: $,
        texImage3D: K,
        updateUBOMapping: Te,
        uniformBlockBinding: ce,
        texStorage2D: de,
        texStorage3D: Ce,
        texSubImage2D: ne,
        texSubImage3D: ee,
        compressedTexSubImage2D: J,
        compressedTexSubImage3D: Ae,
        scissor: ae,
        viewport: Me,
        reset: Ne
    }
}
function Lb(i, e, t, n, r, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new lt
      , u = new WeakMap;
    let f;
    const h = new WeakMap;
    let d = !1;
    try {
        d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch (D) {}
    function _(D, M) {
        return d ? new OffscreenCanvas(D,M) : Pa("canvas")
    }
    function g(D, M, V) {
        let ne = 1;
        const ee = ht(D);
        if ((ee.width > V || ee.height > V) && (ne = V / Math.max(ee.width, ee.height)),
        ne < 1)
            if (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && D instanceof ImageBitmap || typeof VideoFrame < "u" && D instanceof VideoFrame) {
                const J = Math.floor(ne * ee.width)
                  , Ae = Math.floor(ne * ee.height);
                f === void 0 && (f = _(J, Ae));
                const de = M ? _(J, Ae) : f;
                return de.width = J,
                de.height = Ae,
                de.getContext("2d").drawImage(D, 0, 0, J, Ae),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ee.width + "x" + ee.height + ") to (" + J + "x" + Ae + ")."),
                de
            } else
                return "data"in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ee.width + "x" + ee.height + ")."),
                D;
        return D
    }
    function m(D) {
        return D.generateMipmaps
    }
    function p(D) {
        i.generateMipmap(D)
    }
    function E(D) {
        return D.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : D.isWebGL3DRenderTarget ? i.TEXTURE_3D : D.isWebGLArrayRenderTarget || D.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D
    }
    function S(D, M, V, ne, ee=!1) {
        if (D !== null) {
            if (i[D] !== void 0)
                return i[D];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'")
        }
        let J = M;
        if (M === i.RED && (V === i.FLOAT && (J = i.R32F),
        V === i.HALF_FLOAT && (J = i.R16F),
        V === i.UNSIGNED_BYTE && (J = i.R8)),
        M === i.RED_INTEGER && (V === i.UNSIGNED_BYTE && (J = i.R8UI),
        V === i.UNSIGNED_SHORT && (J = i.R16UI),
        V === i.UNSIGNED_INT && (J = i.R32UI),
        V === i.BYTE && (J = i.R8I),
        V === i.SHORT && (J = i.R16I),
        V === i.INT && (J = i.R32I)),
        M === i.RG && (V === i.FLOAT && (J = i.RG32F),
        V === i.HALF_FLOAT && (J = i.RG16F),
        V === i.UNSIGNED_BYTE && (J = i.RG8)),
        M === i.RG_INTEGER && (V === i.UNSIGNED_BYTE && (J = i.RG8UI),
        V === i.UNSIGNED_SHORT && (J = i.RG16UI),
        V === i.UNSIGNED_INT && (J = i.RG32UI),
        V === i.BYTE && (J = i.RG8I),
        V === i.SHORT && (J = i.RG16I),
        V === i.INT && (J = i.RG32I)),
        M === i.RGB_INTEGER && (V === i.UNSIGNED_BYTE && (J = i.RGB8UI),
        V === i.UNSIGNED_SHORT && (J = i.RGB16UI),
        V === i.UNSIGNED_INT && (J = i.RGB32UI),
        V === i.BYTE && (J = i.RGB8I),
        V === i.SHORT && (J = i.RGB16I),
        V === i.INT && (J = i.RGB32I)),
        M === i.RGBA_INTEGER && (V === i.UNSIGNED_BYTE && (J = i.RGBA8UI),
        V === i.UNSIGNED_SHORT && (J = i.RGBA16UI),
        V === i.UNSIGNED_INT && (J = i.RGBA32UI),
        V === i.BYTE && (J = i.RGBA8I),
        V === i.SHORT && (J = i.RGBA16I),
        V === i.INT && (J = i.RGBA32I)),
        M === i.RGB && V === i.UNSIGNED_INT_5_9_9_9_REV && (J = i.RGB9_E5),
        M === i.RGBA) {
            const Ae = ee ? tc : pt.getTransfer(ne);
            V === i.FLOAT && (J = i.RGBA32F),
            V === i.HALF_FLOAT && (J = i.RGBA16F),
            V === i.UNSIGNED_BYTE && (J = Ae === Mt ? i.SRGB8_ALPHA8 : i.RGBA8),
            V === i.UNSIGNED_SHORT_4_4_4_4 && (J = i.RGBA4),
            V === i.UNSIGNED_SHORT_5_5_5_1 && (J = i.RGB5_A1)
        }
        return (J === i.R16F || J === i.R32F || J === i.RG16F || J === i.RG32F || J === i.RGBA16F || J === i.RGBA32F) && e.get("EXT_color_buffer_float"),
        J
    }
    function v(D, M) {
        let V;
        return D ? M === null || M === Gr || M === Ro ? V = i.DEPTH24_STENCIL8 : M === ur ? V = i.DEPTH32F_STENCIL8 : M === Ra && (V = i.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === Gr || M === Ro ? V = i.DEPTH_COMPONENT24 : M === ur ? V = i.DEPTH_COMPONENT32F : M === Ra && (V = i.DEPTH_COMPONENT16),
        V
    }
    function b(D, M) {
        return m(D) === !0 || D.isFramebufferTexture && D.minFilter !== Fi && D.minFilter !== ln ? Math.log2(Math.max(M.width, M.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? M.mipmaps.length : 1
    }
    function A(D) {
        const M = D.target;
        M.removeEventListener("dispose", A),
        R(M),
        M.isVideoTexture && u.delete(M)
    }
    function T(D) {
        const M = D.target;
        M.removeEventListener("dispose", T),
        x(M)
    }
    function R(D) {
        const M = n.get(D);
        if (M.__webglInit === void 0)
            return;
        const V = D.source
          , ne = h.get(V);
        if (ne) {
            const ee = ne[M.__cacheKey];
            ee.usedTimes--,
            ee.usedTimes === 0 && y(D),
            Object.keys(ne).length === 0 && h.delete(V)
        }
        n.remove(D)
    }
    function y(D) {
        const M = n.get(D);
        i.deleteTexture(M.__webglTexture);
        const V = D.source
          , ne = h.get(V);
        delete ne[M.__cacheKey],
        o.memory.textures--
    }
    function x(D) {
        const M = n.get(D);
        if (D.depthTexture && (D.depthTexture.dispose(),
        n.remove(D.depthTexture)),
        D.isWebGLCubeRenderTarget)
            for (let ne = 0; ne < 6; ne++) {
                if (Array.isArray(M.__webglFramebuffer[ne]))
                    for (let ee = 0; ee < M.__webglFramebuffer[ne].length; ee++)
                        i.deleteFramebuffer(M.__webglFramebuffer[ne][ee]);
                else
                    i.deleteFramebuffer(M.__webglFramebuffer[ne]);
                M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer[ne])
            }
        else {
            if (Array.isArray(M.__webglFramebuffer))
                for (let ne = 0; ne < M.__webglFramebuffer.length; ne++)
                    i.deleteFramebuffer(M.__webglFramebuffer[ne]);
            else
                i.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && i.deleteRenderbuffer(M.__webglDepthbuffer),
            M.__webglMultisampledFramebuffer && i.deleteFramebuffer(M.__webglMultisampledFramebuffer),
            M.__webglColorRenderbuffer)
                for (let ne = 0; ne < M.__webglColorRenderbuffer.length; ne++)
                    M.__webglColorRenderbuffer[ne] && i.deleteRenderbuffer(M.__webglColorRenderbuffer[ne]);
            M.__webglDepthRenderbuffer && i.deleteRenderbuffer(M.__webglDepthRenderbuffer)
        }
        const V = D.textures;
        for (let ne = 0, ee = V.length; ne < ee; ne++) {
            const J = n.get(V[ne]);
            J.__webglTexture && (i.deleteTexture(J.__webglTexture),
            o.memory.textures--),
            n.remove(V[ne])
        }
        n.remove(D)
    }
    let P = 0;
    function U() {
        P = 0
    }
    function O() {
        const D = P;
        return D >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + r.maxTextures),
        P += 1,
        D
    }
    function B(D) {
        const M = [];
        return M.push(D.wrapS),
        M.push(D.wrapT),
        M.push(D.wrapR || 0),
        M.push(D.magFilter),
        M.push(D.minFilter),
        M.push(D.anisotropy),
        M.push(D.internalFormat),
        M.push(D.format),
        M.push(D.type),
        M.push(D.generateMipmaps),
        M.push(D.premultiplyAlpha),
        M.push(D.flipY),
        M.push(D.unpackAlignment),
        M.push(D.colorSpace),
        M.join()
    }
    function X(D, M) {
        const V = n.get(D);
        if (D.isVideoTexture && Ue(D),
        D.isRenderTargetTexture === !1 && D.version > 0 && V.__version !== D.version) {
            const ne = D.image;
            if (ne === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ne.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                fe(V, D, M);
                return
            }
        }
        t.bindTexture(i.TEXTURE_2D, V.__webglTexture, i.TEXTURE0 + M)
    }
    function H(D, M) {
        const V = n.get(D);
        if (D.version > 0 && V.__version !== D.version) {
            fe(V, D, M);
            return
        }
        t.bindTexture(i.TEXTURE_2D_ARRAY, V.__webglTexture, i.TEXTURE0 + M)
    }
    function Y(D, M) {
        const V = n.get(D);
        if (D.version > 0 && V.__version !== D.version) {
            fe(V, D, M);
            return
        }
        t.bindTexture(i.TEXTURE_3D, V.__webglTexture, i.TEXTURE0 + M)
    }
    function N(D, M) {
        const V = n.get(D);
        if (D.version > 0 && V.__version !== D.version) {
            oe(V, D, M);
            return
        }
        t.bindTexture(i.TEXTURE_CUBE_MAP, V.__webglTexture, i.TEXTURE0 + M)
    }
    const k = {
        [ec]: i.REPEAT,
        [gs]: i.CLAMP_TO_EDGE,
        [sf]: i.MIRRORED_REPEAT
    }
      , C = {
        [Fi]: i.NEAREST,
        [cy]: i.NEAREST_MIPMAP_NEAREST,
        [tl]: i.NEAREST_MIPMAP_LINEAR,
        [ln]: i.LINEAR,
        [Uc]: i.LINEAR_MIPMAP_NEAREST,
        [_s]: i.LINEAR_MIPMAP_LINEAR
    }
      , re = {
        [dy]: i.NEVER,
        [xy]: i.ALWAYS,
        [py]: i.LESS,
        [Tg]: i.LEQUAL,
        [my]: i.EQUAL,
        [vy]: i.GEQUAL,
        [gy]: i.GREATER,
        [_y]: i.NOTEQUAL
    };
    function ue(D, M) {
        if (M.type === ur && e.has("OES_texture_float_linear") === !1 && (M.magFilter === ln || M.magFilter === Uc || M.magFilter === tl || M.magFilter === _s || M.minFilter === ln || M.minFilter === Uc || M.minFilter === tl || M.minFilter === _s) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        i.texParameteri(D, i.TEXTURE_WRAP_S, k[M.wrapS]),
        i.texParameteri(D, i.TEXTURE_WRAP_T, k[M.wrapT]),
        (D === i.TEXTURE_3D || D === i.TEXTURE_2D_ARRAY) && i.texParameteri(D, i.TEXTURE_WRAP_R, k[M.wrapR]),
        i.texParameteri(D, i.TEXTURE_MAG_FILTER, C[M.magFilter]),
        i.texParameteri(D, i.TEXTURE_MIN_FILTER, C[M.minFilter]),
        M.compareFunction && (i.texParameteri(D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
        i.texParameteri(D, i.TEXTURE_COMPARE_FUNC, re[M.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (M.magFilter === Fi || M.minFilter !== tl && M.minFilter !== _s || M.type === ur && e.has("OES_texture_float_linear") === !1)
                return;
            if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
                const V = e.get("EXT_texture_filter_anisotropic");
                i.texParameterf(D, V.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, r.getMaxAnisotropy())),
                n.get(M).__currentAnisotropy = M.anisotropy
            }
        }
    }
    function we(D, M) {
        let V = !1;
        D.__webglInit === void 0 && (D.__webglInit = !0,
        M.addEventListener("dispose", A));
        const ne = M.source;
        let ee = h.get(ne);
        ee === void 0 && (ee = {},
        h.set(ne, ee));
        const J = B(M);
        if (J !== D.__cacheKey) {
            ee[J] === void 0 && (ee[J] = {
                texture: i.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            V = !0),
            ee[J].usedTimes++;
            const Ae = ee[D.__cacheKey];
            Ae !== void 0 && (ee[D.__cacheKey].usedTimes--,
            Ae.usedTimes === 0 && y(M)),
            D.__cacheKey = J,
            D.__webglTexture = ee[J].texture
        }
        return V
    }
    function q(D, M, V) {
        return Math.floor(Math.floor(D / V) / M)
    }
    function te(D, M, V, ne) {
        const J = D.updateRanges;
        if (J.length === 0)
            t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, M.width, M.height, V, ne, M.data);
        else {
            J.sort( (K, ae) => K.start - ae.start);
            let Ae = 0;
            for (let K = 1; K < J.length; K++) {
                const ae = J[Ae]
                  , Me = J[K]
                  , Te = ae.start + ae.count
                  , ce = q(Me.start, M.width, 4)
                  , Ne = q(ae.start, M.width, 4);
                Me.start <= Te + 1 && ce === Ne && q(Me.start + Me.count - 1, M.width, 4) === ce ? ae.count = Math.max(ae.count, Me.start + Me.count - ae.start) : (++Ae,
                J[Ae] = Me)
            }
            J.length = Ae + 1;
            const de = i.getParameter(i.UNPACK_ROW_LENGTH)
              , Ce = i.getParameter(i.UNPACK_SKIP_PIXELS)
              , $ = i.getParameter(i.UNPACK_SKIP_ROWS);
            i.pixelStorei(i.UNPACK_ROW_LENGTH, M.width);
            for (let K = 0, ae = J.length; K < ae; K++) {
                const Me = J[K]
                  , Te = Math.floor(Me.start / 4)
                  , ce = Math.ceil(Me.count / 4)
                  , Ne = Te % M.width
                  , L = Math.floor(Te / M.width)
                  , he = ce
                  , ie = 1;
                i.pixelStorei(i.UNPACK_SKIP_PIXELS, Ne),
                i.pixelStorei(i.UNPACK_SKIP_ROWS, L),
                t.texSubImage2D(i.TEXTURE_2D, 0, Ne, L, he, ie, V, ne, M.data)
            }
            D.clearUpdateRanges(),
            i.pixelStorei(i.UNPACK_ROW_LENGTH, de),
            i.pixelStorei(i.UNPACK_SKIP_PIXELS, Ce),
            i.pixelStorei(i.UNPACK_SKIP_ROWS, $)
        }
    }
    function fe(D, M, V) {
        let ne = i.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (ne = i.TEXTURE_2D_ARRAY),
        M.isData3DTexture && (ne = i.TEXTURE_3D);
        const ee = we(D, M)
          , J = M.source;
        t.bindTexture(ne, D.__webglTexture, i.TEXTURE0 + V);
        const Ae = n.get(J);
        if (J.version !== Ae.__version || ee === !0) {
            t.activeTexture(i.TEXTURE0 + V);
            const de = pt.getPrimaries(pt.workingColorSpace)
              , Ce = M.colorSpace === Xi ? null : pt.getPrimaries(M.colorSpace)
              , $ = M.colorSpace === Xi || de === Ce ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY),
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment),
            i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, $);
            let K = g(M.image, !1, r.maxTextureSize);
            K = ge(M, K);
            const ae = s.convert(M.format, M.colorSpace)
              , Me = s.convert(M.type);
            let Te = S(M.internalFormat, ae, Me, M.colorSpace, M.isVideoTexture);
            ue(ne, M);
            let ce;
            const Ne = M.mipmaps
              , L = M.isVideoTexture !== !0
              , he = Ae.__version === void 0 || ee === !0
              , ie = J.dataReady
              , pe = b(M, K);
            if (M.isDepthTexture)
                Te = v(M.format === Co, M.type),
                he && (L ? t.texStorage2D(i.TEXTURE_2D, 1, Te, K.width, K.height) : t.texImage2D(i.TEXTURE_2D, 0, Te, K.width, K.height, 0, ae, Me, null));
            else if (M.isDataTexture)
                if (Ne.length > 0) {
                    L && he && t.texStorage2D(i.TEXTURE_2D, pe, Te, Ne[0].width, Ne[0].height);
                    for (let se = 0, Q = Ne.length; se < Q; se++)
                        ce = Ne[se],
                        L ? ie && t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, ce.width, ce.height, ae, Me, ce.data) : t.texImage2D(i.TEXTURE_2D, se, Te, ce.width, ce.height, 0, ae, Me, ce.data);
                    M.generateMipmaps = !1
                } else
                    L ? (he && t.texStorage2D(i.TEXTURE_2D, pe, Te, K.width, K.height),
                    ie && te(M, K, ae, Me)) : t.texImage2D(i.TEXTURE_2D, 0, Te, K.width, K.height, 0, ae, Me, K.data);
            else if (M.isCompressedTexture)
                if (M.isCompressedArrayTexture) {
                    L && he && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Te, Ne[0].width, Ne[0].height, K.depth);
                    for (let se = 0, Q = Ne.length; se < Q; se++)
                        if (ce = Ne[se],
                        M.format !== Oi)
                            if (ae !== null)
                                if (L) {
                                    if (ie)
                                        if (M.layerUpdates.size > 0) {
                                            const Pe = Zd(ce.width, ce.height, M.format, M.type);
                                            for (const Ve of M.layerUpdates) {
                                                const gt = ce.data.subarray(Ve * Pe / ce.data.BYTES_PER_ELEMENT, (Ve + 1) * Pe / ce.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, se, 0, 0, Ve, ce.width, ce.height, 1, ae, gt)
                                            }
                                            M.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, se, 0, 0, 0, ce.width, ce.height, K.depth, ae, ce.data)
                                } else
                                    t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, se, Te, ce.width, ce.height, K.depth, 0, ce.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            L ? ie && t.texSubImage3D(i.TEXTURE_2D_ARRAY, se, 0, 0, 0, ce.width, ce.height, K.depth, ae, Me, ce.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, se, Te, ce.width, ce.height, K.depth, 0, ae, Me, ce.data)
                } else {
                    L && he && t.texStorage2D(i.TEXTURE_2D, pe, Te, Ne[0].width, Ne[0].height);
                    for (let se = 0, Q = Ne.length; se < Q; se++)
                        ce = Ne[se],
                        M.format !== Oi ? ae !== null ? L ? ie && t.compressedTexSubImage2D(i.TEXTURE_2D, se, 0, 0, ce.width, ce.height, ae, ce.data) : t.compressedTexImage2D(i.TEXTURE_2D, se, Te, ce.width, ce.height, 0, ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : L ? ie && t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, ce.width, ce.height, ae, Me, ce.data) : t.texImage2D(i.TEXTURE_2D, se, Te, ce.width, ce.height, 0, ae, Me, ce.data)
                }
            else if (M.isDataArrayTexture)
                if (L) {
                    if (he && t.texStorage3D(i.TEXTURE_2D_ARRAY, pe, Te, K.width, K.height, K.depth),
                    ie)
                        if (M.layerUpdates.size > 0) {
                            const se = Zd(K.width, K.height, M.format, M.type);
                            for (const Q of M.layerUpdates) {
                                const Pe = K.data.subarray(Q * se / K.data.BYTES_PER_ELEMENT, (Q + 1) * se / K.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, Q, K.width, K.height, 1, ae, Me, Pe)
                            }
                            M.clearLayerUpdates()
                        } else
                            t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, K.width, K.height, K.depth, ae, Me, K.data)
                } else
                    t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Te, K.width, K.height, K.depth, 0, ae, Me, K.data);
            else if (M.isData3DTexture)
                L ? (he && t.texStorage3D(i.TEXTURE_3D, pe, Te, K.width, K.height, K.depth),
                ie && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, K.width, K.height, K.depth, ae, Me, K.data)) : t.texImage3D(i.TEXTURE_3D, 0, Te, K.width, K.height, K.depth, 0, ae, Me, K.data);
            else if (M.isFramebufferTexture) {
                if (he)
                    if (L)
                        t.texStorage2D(i.TEXTURE_2D, pe, Te, K.width, K.height);
                    else {
                        let se = K.width
                          , Q = K.height;
                        for (let Pe = 0; Pe < pe; Pe++)
                            t.texImage2D(i.TEXTURE_2D, Pe, Te, se, Q, 0, ae, Me, null),
                            se >>= 1,
                            Q >>= 1
                    }
            } else if (Ne.length > 0) {
                if (L && he) {
                    const se = ht(Ne[0]);
                    t.texStorage2D(i.TEXTURE_2D, pe, Te, se.width, se.height)
                }
                for (let se = 0, Q = Ne.length; se < Q; se++)
                    ce = Ne[se],
                    L ? ie && t.texSubImage2D(i.TEXTURE_2D, se, 0, 0, ae, Me, ce) : t.texImage2D(i.TEXTURE_2D, se, Te, ae, Me, ce);
                M.generateMipmaps = !1
            } else if (L) {
                if (he) {
                    const se = ht(K);
                    t.texStorage2D(i.TEXTURE_2D, pe, Te, se.width, se.height)
                }
                ie && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ae, Me, K)
            } else
                t.texImage2D(i.TEXTURE_2D, 0, Te, ae, Me, K);
            m(M) && p(ne),
            Ae.__version = J.version,
            M.onUpdate && M.onUpdate(M)
        }
        D.__version = M.version
    }
    function oe(D, M, V) {
        if (M.image.length !== 6)
            return;
        const ne = we(D, M)
          , ee = M.source;
        t.bindTexture(i.TEXTURE_CUBE_MAP, D.__webglTexture, i.TEXTURE0 + V);
        const J = n.get(ee);
        if (ee.version !== J.__version || ne === !0) {
            t.activeTexture(i.TEXTURE0 + V);
            const Ae = pt.getPrimaries(pt.workingColorSpace)
              , de = M.colorSpace === Xi ? null : pt.getPrimaries(M.colorSpace)
              , Ce = M.colorSpace === Xi || Ae === de ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, M.flipY),
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            i.pixelStorei(i.UNPACK_ALIGNMENT, M.unpackAlignment),
            i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ce);
            const $ = M.isCompressedTexture || M.image[0].isCompressedTexture
              , K = M.image[0] && M.image[0].isDataTexture
              , ae = [];
            for (let Q = 0; Q < 6; Q++)
                !$ && !K ? ae[Q] = g(M.image[Q], !0, r.maxCubemapSize) : ae[Q] = K ? M.image[Q].image : M.image[Q],
                ae[Q] = ge(M, ae[Q]);
            const Me = ae[0]
              , Te = s.convert(M.format, M.colorSpace)
              , ce = s.convert(M.type)
              , Ne = S(M.internalFormat, Te, ce, M.colorSpace)
              , L = M.isVideoTexture !== !0
              , he = J.__version === void 0 || ne === !0
              , ie = ee.dataReady;
            let pe = b(M, Me);
            ue(i.TEXTURE_CUBE_MAP, M);
            let se;
            if ($) {
                L && he && t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, Ne, Me.width, Me.height);
                for (let Q = 0; Q < 6; Q++) {
                    se = ae[Q].mipmaps;
                    for (let Pe = 0; Pe < se.length; Pe++) {
                        const Ve = se[Pe];
                        M.format !== Oi ? Te !== null ? L ? ie && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe, 0, 0, Ve.width, Ve.height, Te, Ve.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe, Ne, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : L ? ie && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe, 0, 0, Ve.width, Ve.height, Te, ce, Ve.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe, Ne, Ve.width, Ve.height, 0, Te, ce, Ve.data)
                    }
                }
            } else {
                if (se = M.mipmaps,
                L && he) {
                    se.length > 0 && pe++;
                    const Q = ht(ae[0]);
                    t.texStorage2D(i.TEXTURE_CUBE_MAP, pe, Ne, Q.width, Q.height)
                }
                for (let Q = 0; Q < 6; Q++)
                    if (K) {
                        L ? ie && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, 0, 0, 0, ae[Q].width, ae[Q].height, Te, ce, ae[Q].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, 0, Ne, ae[Q].width, ae[Q].height, 0, Te, ce, ae[Q].data);
                        for (let Pe = 0; Pe < se.length; Pe++) {
                            const gt = se[Pe].image[Q].image;
                            L ? ie && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe + 1, 0, 0, gt.width, gt.height, Te, ce, gt.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe + 1, Ne, gt.width, gt.height, 0, Te, ce, gt.data)
                        }
                    } else {
                        L ? ie && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, 0, 0, 0, Te, ce, ae[Q]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, 0, Ne, Te, ce, ae[Q]);
                        for (let Pe = 0; Pe < se.length; Pe++) {
                            const Ve = se[Pe];
                            L ? ie && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe + 1, 0, 0, Te, ce, Ve.image[Q]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Pe + 1, Ne, Te, ce, Ve.image[Q])
                        }
                    }
            }
            m(M) && p(i.TEXTURE_CUBE_MAP),
            J.__version = ee.version,
            M.onUpdate && M.onUpdate(M)
        }
        D.__version = M.version
    }
    function me(D, M, V, ne, ee, J) {
        const Ae = s.convert(V.format, V.colorSpace)
          , de = s.convert(V.type)
          , Ce = S(V.internalFormat, Ae, de, V.colorSpace)
          , $ = n.get(M)
          , K = n.get(V);
        if (K.__renderTarget = M,
        !$.__hasExternalTextures) {
            const ae = Math.max(1, M.width >> J)
              , Me = Math.max(1, M.height >> J);
            ee === i.TEXTURE_3D || ee === i.TEXTURE_2D_ARRAY ? t.texImage3D(ee, J, Ce, ae, Me, M.depth, 0, Ae, de, null) : t.texImage2D(ee, J, Ce, ae, Me, 0, Ae, de, null)
        }
        t.bindFramebuffer(i.FRAMEBUFFER, D),
        Ke(M) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, ne, ee, K.__webglTexture, 0, Ee(M)) : (ee === i.TEXTURE_2D || ee >= i.TEXTURE_CUBE_MAP_POSITIVE_X && ee <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, ne, ee, K.__webglTexture, J),
        t.bindFramebuffer(i.FRAMEBUFFER, null)
    }
    function He(D, M, V) {
        if (i.bindRenderbuffer(i.RENDERBUFFER, D),
        M.depthBuffer) {
            const ne = M.depthTexture
              , ee = ne && ne.isDepthTexture ? ne.type : null
              , J = v(M.stencilBuffer, ee)
              , Ae = M.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
              , de = Ee(M);
            Ke(M) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, de, J, M.width, M.height) : V ? i.renderbufferStorageMultisample(i.RENDERBUFFER, de, J, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, J, M.width, M.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, Ae, i.RENDERBUFFER, D)
        } else {
            const ne = M.textures;
            for (let ee = 0; ee < ne.length; ee++) {
                const J = ne[ee]
                  , Ae = s.convert(J.format, J.colorSpace)
                  , de = s.convert(J.type)
                  , Ce = S(J.internalFormat, Ae, de, J.colorSpace)
                  , $ = Ee(M);
                V && Ke(M) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, $, Ce, M.width, M.height) : Ke(M) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, $, Ce, M.width, M.height) : i.renderbufferStorage(i.RENDERBUFFER, Ce, M.width, M.height)
            }
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null)
    }
    function ze(D, M) {
        if (M && M.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(i.FRAMEBUFFER, D),
        !(M.depthTexture && M.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const ne = n.get(M.depthTexture);
        ne.__renderTarget = M,
        (!ne.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width,
        M.depthTexture.image.height = M.height,
        M.depthTexture.needsUpdate = !0),
        X(M.depthTexture, 0);
        const ee = ne.__webglTexture
          , J = Ee(M);
        if (M.depthTexture.format === Ca)
            Ke(M) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, ee, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, ee, 0);
        else if (M.depthTexture.format === Co)
            Ke(M) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, ee, 0, J) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, ee, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Qe(D) {
        const M = n.get(D)
          , V = D.isWebGLCubeRenderTarget === !0;
        if (M.__boundDepthTexture !== D.depthTexture) {
            const ne = D.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(),
            ne) {
                const ee = () => {
                    delete M.__boundDepthTexture,
                    delete M.__depthDisposeCallback,
                    ne.removeEventListener("dispose", ee)
                }
                ;
                ne.addEventListener("dispose", ee),
                M.__depthDisposeCallback = ee
            }
            M.__boundDepthTexture = ne
        }
        if (D.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (V)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const ne = D.texture.mipmaps;
            ne && ne.length > 0 ? ze(M.__webglFramebuffer[0], D) : ze(M.__webglFramebuffer, D)
        } else if (V) {
            M.__webglDepthbuffer = [];
            for (let ne = 0; ne < 6; ne++)
                if (t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer[ne]),
                M.__webglDepthbuffer[ne] === void 0)
                    M.__webglDepthbuffer[ne] = i.createRenderbuffer(),
                    He(M.__webglDepthbuffer[ne], D, !1);
                else {
                    const ee = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
                      , J = M.__webglDepthbuffer[ne];
                    i.bindRenderbuffer(i.RENDERBUFFER, J),
                    i.framebufferRenderbuffer(i.FRAMEBUFFER, ee, i.RENDERBUFFER, J)
                }
        } else {
            const ne = D.texture.mipmaps;
            if (ne && ne.length > 0 ? t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer[0]) : t.bindFramebuffer(i.FRAMEBUFFER, M.__webglFramebuffer),
            M.__webglDepthbuffer === void 0)
                M.__webglDepthbuffer = i.createRenderbuffer(),
                He(M.__webglDepthbuffer, D, !1);
            else {
                const ee = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
                  , J = M.__webglDepthbuffer;
                i.bindRenderbuffer(i.RENDERBUFFER, J),
                i.framebufferRenderbuffer(i.FRAMEBUFFER, ee, i.RENDERBUFFER, J)
            }
        }
        t.bindFramebuffer(i.FRAMEBUFFER, null)
    }
    function et(D, M, V) {
        const ne = n.get(D);
        M !== void 0 && me(ne.__webglFramebuffer, D, D.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0),
        V !== void 0 && Qe(D)
    }
    function De(D) {
        const M = D.texture
          , V = n.get(D)
          , ne = n.get(M);
        D.addEventListener("dispose", T);
        const ee = D.textures
          , J = D.isWebGLCubeRenderTarget === !0
          , Ae = ee.length > 1;
        if (Ae || (ne.__webglTexture === void 0 && (ne.__webglTexture = i.createTexture()),
        ne.__version = M.version,
        o.memory.textures++),
        J) {
            V.__webglFramebuffer = [];
            for (let de = 0; de < 6; de++)
                if (M.mipmaps && M.mipmaps.length > 0) {
                    V.__webglFramebuffer[de] = [];
                    for (let Ce = 0; Ce < M.mipmaps.length; Ce++)
                        V.__webglFramebuffer[de][Ce] = i.createFramebuffer()
                } else
                    V.__webglFramebuffer[de] = i.createFramebuffer()
        } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
                V.__webglFramebuffer = [];
                for (let de = 0; de < M.mipmaps.length; de++)
                    V.__webglFramebuffer[de] = i.createFramebuffer()
            } else
                V.__webglFramebuffer = i.createFramebuffer();
            if (Ae)
                for (let de = 0, Ce = ee.length; de < Ce; de++) {
                    const $ = n.get(ee[de]);
                    $.__webglTexture === void 0 && ($.__webglTexture = i.createTexture(),
                    o.memory.textures++)
                }
            if (D.samples > 0 && Ke(D) === !1) {
                V.__webglMultisampledFramebuffer = i.createFramebuffer(),
                V.__webglColorRenderbuffer = [],
                t.bindFramebuffer(i.FRAMEBUFFER, V.__webglMultisampledFramebuffer);
                for (let de = 0; de < ee.length; de++) {
                    const Ce = ee[de];
                    V.__webglColorRenderbuffer[de] = i.createRenderbuffer(),
                    i.bindRenderbuffer(i.RENDERBUFFER, V.__webglColorRenderbuffer[de]);
                    const $ = s.convert(Ce.format, Ce.colorSpace)
                      , K = s.convert(Ce.type)
                      , ae = S(Ce.internalFormat, $, K, Ce.colorSpace, D.isXRRenderTarget === !0)
                      , Me = Ee(D);
                    i.renderbufferStorageMultisample(i.RENDERBUFFER, Me, ae, D.width, D.height),
                    i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + de, i.RENDERBUFFER, V.__webglColorRenderbuffer[de])
                }
                i.bindRenderbuffer(i.RENDERBUFFER, null),
                D.depthBuffer && (V.__webglDepthRenderbuffer = i.createRenderbuffer(),
                He(V.__webglDepthRenderbuffer, D, !0)),
                t.bindFramebuffer(i.FRAMEBUFFER, null)
            }
        }
        if (J) {
            t.bindTexture(i.TEXTURE_CUBE_MAP, ne.__webglTexture),
            ue(i.TEXTURE_CUBE_MAP, M);
            for (let de = 0; de < 6; de++)
                if (M.mipmaps && M.mipmaps.length > 0)
                    for (let Ce = 0; Ce < M.mipmaps.length; Ce++)
                        me(V.__webglFramebuffer[de][Ce], D, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + de, Ce);
                else
                    me(V.__webglFramebuffer[de], D, M, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0);
            m(M) && p(i.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (Ae) {
            for (let de = 0, Ce = ee.length; de < Ce; de++) {
                const $ = ee[de]
                  , K = n.get($);
                t.bindTexture(i.TEXTURE_2D, K.__webglTexture),
                ue(i.TEXTURE_2D, $),
                me(V.__webglFramebuffer, D, $, i.COLOR_ATTACHMENT0 + de, i.TEXTURE_2D, 0),
                m($) && p(i.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let de = i.TEXTURE_2D;
            if ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (de = D.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
            t.bindTexture(de, ne.__webglTexture),
            ue(de, M),
            M.mipmaps && M.mipmaps.length > 0)
                for (let Ce = 0; Ce < M.mipmaps.length; Ce++)
                    me(V.__webglFramebuffer[Ce], D, M, i.COLOR_ATTACHMENT0, de, Ce);
            else
                me(V.__webglFramebuffer, D, M, i.COLOR_ATTACHMENT0, de, 0);
            m(M) && p(de),
            t.unbindTexture()
        }
        D.depthBuffer && Qe(D)
    }
    function I(D) {
        const M = D.textures;
        for (let V = 0, ne = M.length; V < ne; V++) {
            const ee = M[V];
            if (m(ee)) {
                const J = E(D)
                  , Ae = n.get(ee).__webglTexture;
                t.bindTexture(J, Ae),
                p(J),
                t.unbindTexture()
            }
        }
    }
    const Je = []
      , Ge = [];
    function G(D) {
        if (D.samples > 0) {
            if (Ke(D) === !1) {
                const M = D.textures
                  , V = D.width
                  , ne = D.height;
                let ee = i.COLOR_BUFFER_BIT;
                const J = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT
                  , Ae = n.get(D)
                  , de = M.length > 1;
                if (de)
                    for (let $ = 0; $ < M.length; $++)
                        t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglMultisampledFramebuffer),
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + $, i.RENDERBUFFER, null),
                        t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglFramebuffer),
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + $, i.TEXTURE_2D, null, 0);
                t.bindFramebuffer(i.READ_FRAMEBUFFER, Ae.__webglMultisampledFramebuffer);
                const Ce = D.texture.mipmaps;
                Ce && Ce.length > 0 ? t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Ae.__webglFramebuffer[0]) : t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Ae.__webglFramebuffer);
                for (let $ = 0; $ < M.length; $++) {
                    if (D.resolveDepthBuffer && (D.depthBuffer && (ee |= i.DEPTH_BUFFER_BIT),
                    D.stencilBuffer && D.resolveStencilBuffer && (ee |= i.STENCIL_BUFFER_BIT)),
                    de) {
                        i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Ae.__webglColorRenderbuffer[$]);
                        const K = n.get(M[$]).__webglTexture;
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, K, 0)
                    }
                    i.blitFramebuffer(0, 0, V, ne, 0, 0, V, ne, ee, i.NEAREST),
                    l === !0 && (Je.length = 0,
                    Ge.length = 0,
                    Je.push(i.COLOR_ATTACHMENT0 + $),
                    D.depthBuffer && D.resolveDepthBuffer === !1 && (Je.push(J),
                    Ge.push(J),
                    i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, Ge)),
                    i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Je))
                }
                if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
                de)
                    for (let $ = 0; $ < M.length; $++) {
                        t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglMultisampledFramebuffer),
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + $, i.RENDERBUFFER, Ae.__webglColorRenderbuffer[$]);
                        const K = n.get(M[$]).__webglTexture;
                        t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglFramebuffer),
                        i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + $, i.TEXTURE_2D, K, 0)
                    }
                t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Ae.__webglMultisampledFramebuffer)
            } else if (D.depthBuffer && D.resolveDepthBuffer === !1 && l) {
                const M = D.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
                i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [M])
            }
        }
    }
    function Ee(D) {
        return Math.min(r.maxSamples, D.samples)
    }
    function Ke(D) {
        const M = n.get(D);
        return D.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
    }
    function Ue(D) {
        const M = o.render.frame;
        u.get(D) !== M && (u.set(D, M),
        D.update())
    }
    function ge(D, M) {
        const V = D.colorSpace
          , ne = D.format
          , ee = D.type;
        return D.isCompressedTexture === !0 || D.isVideoTexture === !0 || V !== Wr && V !== Xi && (pt.getTransfer(V) === Mt ? (ne !== Oi || ee !== hi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", V)),
        M
    }
    function ht(D) {
        return typeof HTMLImageElement < "u" && D instanceof HTMLImageElement ? (c.width = D.naturalWidth || D.width,
        c.height = D.naturalHeight || D.height) : typeof VideoFrame < "u" && D instanceof VideoFrame ? (c.width = D.displayWidth,
        c.height = D.displayHeight) : (c.width = D.width,
        c.height = D.height),
        c
    }
    this.allocateTextureUnit = O,
    this.resetTextureUnits = U,
    this.setTexture2D = X,
    this.setTexture2DArray = H,
    this.setTexture3D = Y,
    this.setTextureCube = N,
    this.rebindTextures = et,
    this.setupRenderTarget = De,
    this.updateRenderTargetMipmap = I,
    this.updateMultisampleRenderTarget = G,
    this.setupDepthRenderbuffer = Qe,
    this.setupFrameBufferTexture = me,
    this.useMultisampledRTT = Ke
}
function Ib(i, e) {
    function t(n, r=Xi) {
        let s;
        const o = pt.getTransfer(r);
        if (n === hi)
            return i.UNSIGNED_BYTE;
        if (n === mh)
            return i.UNSIGNED_SHORT_4_4_4_4;
        if (n === gh)
            return i.UNSIGNED_SHORT_5_5_5_1;
        if (n === vg)
            return i.UNSIGNED_INT_5_9_9_9_REV;
        if (n === gg)
            return i.BYTE;
        if (n === _g)
            return i.SHORT;
        if (n === Ra)
            return i.UNSIGNED_SHORT;
        if (n === ph)
            return i.INT;
        if (n === Gr)
            return i.UNSIGNED_INT;
        if (n === ur)
            return i.FLOAT;
        if (n === Ia)
            return i.HALF_FLOAT;
        if (n === xg)
            return i.ALPHA;
        if (n === yg)
            return i.RGB;
        if (n === Oi)
            return i.RGBA;
        if (n === Ca)
            return i.DEPTH_COMPONENT;
        if (n === Co)
            return i.DEPTH_STENCIL;
        if (n === Sg)
            return i.RED;
        if (n === _h)
            return i.RED_INTEGER;
        if (n === Eg)
            return i.RG;
        if (n === vh)
            return i.RG_INTEGER;
        if (n === xh)
            return i.RGBA_INTEGER;
        if (n === Il || n === Ul || n === Nl || n === Ol)
            if (o === Mt)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (n === Il)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === Ul)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === Nl)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Ol)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (n === Il)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === Ul)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === Nl)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Ol)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === of || n === af || n === lf || n === cf)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (n === of)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === af)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === lf)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === cf)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === uf || n === ff || n === hf)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (n === uf || n === ff)
                    return o === Mt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === hf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === df || n === pf || n === mf || n === gf || n === _f || n === vf || n === xf || n === yf || n === Sf || n === Ef || n === Mf || n === Tf || n === bf || n === wf)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (n === df)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === pf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === mf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === gf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === _f)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === vf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === xf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === yf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === Sf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Ef)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Mf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Tf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === bf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === wf)
                    return o === Mt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === Fl || n === Af || n === Rf)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (n === Fl)
                    return o === Mt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Af)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Rf)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === Mg || n === Cf || n === Pf || n === Df)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (n === Fl)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Cf)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Pf)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Df)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === Ro ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null
    }
    return {
        convert: t
    }
}
const Ub = "\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}"
  , Nb = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n	if ( coord.x >= 1.0 ) {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n	} else {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n	}\n\n}";
class Ob {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, n) {
        if (this.texture === null) {
            const r = new cn
              , s = e.properties.get(r);
            s.__webglTexture = t.texture,
            (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = r
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , n = new zi({
                vertexShader: Ub,
                fragmentShader: Nb,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new Wn(new Do(20,20),n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class Fb extends Yr {
    constructor(e, t) {
        super();
        const n = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , u = null
          , f = null
          , h = null
          , d = null
          , _ = null;
        const g = new Ob
          , m = t.getContextAttributes();
        let p = null
          , E = null;
        const S = []
          , v = []
          , b = new lt;
        let A = null;
        const T = new Mi;
        T.viewport = new Wt;
        const R = new Mi;
        R.viewport = new Wt;
        const y = [T, R]
          , x = new rS;
        let P = null
          , U = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(q) {
            let te = S[q];
            return te === void 0 && (te = new iu,
            S[q] = te),
            te.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(q) {
            let te = S[q];
            return te === void 0 && (te = new iu,
            S[q] = te),
            te.getGripSpace()
        }
        ,
        this.getHand = function(q) {
            let te = S[q];
            return te === void 0 && (te = new iu,
            S[q] = te),
            te.getHandSpace()
        }
        ;
        function O(q) {
            const te = v.indexOf(q.inputSource);
            if (te === -1)
                return;
            const fe = S[te];
            fe !== void 0 && (fe.update(q.inputSource, q.frame, c || o),
            fe.dispatchEvent({
                type: q.type,
                data: q.inputSource
            }))
        }
        function B() {
            r.removeEventListener("select", O),
            r.removeEventListener("selectstart", O),
            r.removeEventListener("selectend", O),
            r.removeEventListener("squeeze", O),
            r.removeEventListener("squeezestart", O),
            r.removeEventListener("squeezeend", O),
            r.removeEventListener("end", B),
            r.removeEventListener("inputsourceschange", X);
            for (let q = 0; q < S.length; q++) {
                const te = v[q];
                te !== null && (v[q] = null,
                S[q].disconnect(te))
            }
            P = null,
            U = null,
            g.reset(),
            e.setRenderTarget(p),
            d = null,
            h = null,
            f = null,
            r = null,
            E = null,
            we.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(A),
            e.setSize(b.width, b.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(q) {
            s = q,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(q) {
            a = q,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(q) {
            c = q
        }
        ,
        this.getBaseLayer = function() {
            return h !== null ? h : d
        }
        ,
        this.getBinding = function() {
            return f
        }
        ,
        this.getFrame = function() {
            return _
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(q) {
            if (r = q,
            r !== null) {
                if (p = e.getRenderTarget(),
                r.addEventListener("select", O),
                r.addEventListener("selectstart", O),
                r.addEventListener("selectend", O),
                r.addEventListener("squeeze", O),
                r.addEventListener("squeezestart", O),
                r.addEventListener("squeezeend", O),
                r.addEventListener("end", B),
                r.addEventListener("inputsourceschange", X),
                m.xrCompatible !== !0 && await t.makeXRCompatible(),
                A = e.getPixelRatio(),
                e.getSize(b),
                typeof XRWebGLBinding < "u" && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let fe = null
                      , oe = null
                      , me = null;
                    m.depth && (me = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    fe = m.stencil ? Co : Ca,
                    oe = m.stencil ? Ro : Gr);
                    const He = {
                        colorFormat: t.RGBA8,
                        depthFormat: me,
                        scaleFactor: s
                    };
                    f = new XRWebGLBinding(r,t),
                    h = f.createProjectionLayer(He),
                    r.updateRenderState({
                        layers: [h]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(h.textureWidth, h.textureHeight, !1),
                    E = new Bi(h.textureWidth,h.textureHeight,{
                        format: Oi,
                        type: hi,
                        depthTexture: new Eh(h.textureWidth,h.textureHeight,oe,void 0,void 0,void 0,void 0,void 0,void 0,fe),
                        stencilBuffer: m.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: m.antialias ? 4 : 0,
                        resolveDepthBuffer: h.ignoreDepthValues === !1,
                        resolveStencilBuffer: h.ignoreDepthValues === !1
                    })
                } else {
                    const fe = {
                        antialias: m.antialias,
                        alpha: !0,
                        depth: m.depth,
                        stencil: m.stencil,
                        framebufferScaleFactor: s
                    };
                    d = new XRWebGLLayer(r,t,fe),
                    r.updateRenderState({
                        baseLayer: d
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                    E = new Bi(d.framebufferWidth,d.framebufferHeight,{
                        format: Oi,
                        type: hi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: m.stencil,
                        resolveDepthBuffer: d.ignoreDepthValues === !1,
                        resolveStencilBuffer: d.ignoreDepthValues === !1
                    })
                }
                E.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                we.setContext(r),
                we.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return g.getDepthTexture()
        }
        ;
        function X(q) {
            for (let te = 0; te < q.removed.length; te++) {
                const fe = q.removed[te]
                  , oe = v.indexOf(fe);
                oe >= 0 && (v[oe] = null,
                S[oe].disconnect(fe))
            }
            for (let te = 0; te < q.added.length; te++) {
                const fe = q.added[te];
                let oe = v.indexOf(fe);
                if (oe === -1) {
                    for (let He = 0; He < S.length; He++)
                        if (He >= v.length) {
                            v.push(fe),
                            oe = He;
                            break
                        } else if (v[He] === null) {
                            v[He] = fe,
                            oe = He;
                            break
                        }
                    if (oe === -1)
                        break
                }
                const me = S[oe];
                me && me.connect(fe)
            }
        }
        const H = new Z
          , Y = new Z;
        function N(q, te, fe) {
            H.setFromMatrixPosition(te.matrixWorld),
            Y.setFromMatrixPosition(fe.matrixWorld);
            const oe = H.distanceTo(Y)
              , me = te.projectionMatrix.elements
              , He = fe.projectionMatrix.elements
              , ze = me[14] / (me[10] - 1)
              , Qe = me[14] / (me[10] + 1)
              , et = (me[9] + 1) / me[5]
              , De = (me[9] - 1) / me[5]
              , I = (me[8] - 1) / me[0]
              , Je = (He[8] + 1) / He[0]
              , Ge = ze * I
              , G = ze * Je
              , Ee = oe / (-I + Je)
              , Ke = Ee * -I;
            if (te.matrixWorld.decompose(q.position, q.quaternion, q.scale),
            q.translateX(Ke),
            q.translateZ(Ee),
            q.matrixWorld.compose(q.position, q.quaternion, q.scale),
            q.matrixWorldInverse.copy(q.matrixWorld).invert(),
            me[10] === -1)
                q.projectionMatrix.copy(te.projectionMatrix),
                q.projectionMatrixInverse.copy(te.projectionMatrixInverse);
            else {
                const Ue = ze + Ee
                  , ge = Qe + Ee
                  , ht = Ge - Ke
                  , D = G + (oe - Ke)
                  , M = et * Qe / ge * Ue
                  , V = De * Qe / ge * Ue;
                q.projectionMatrix.makePerspective(ht, D, M, V, Ue, ge),
                q.projectionMatrixInverse.copy(q.projectionMatrix).invert()
            }
        }
        function k(q, te) {
            te === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(te.matrixWorld, q.matrix),
            q.matrixWorldInverse.copy(q.matrixWorld).invert()
        }
        this.updateCamera = function(q) {
            if (r === null)
                return;
            let te = q.near
              , fe = q.far;
            g.texture !== null && (g.depthNear > 0 && (te = g.depthNear),
            g.depthFar > 0 && (fe = g.depthFar)),
            x.near = R.near = T.near = te,
            x.far = R.far = T.far = fe,
            (P !== x.near || U !== x.far) && (r.updateRenderState({
                depthNear: x.near,
                depthFar: x.far
            }),
            P = x.near,
            U = x.far),
            T.layers.mask = q.layers.mask | 2,
            R.layers.mask = q.layers.mask | 4,
            x.layers.mask = T.layers.mask | R.layers.mask;
            const oe = q.parent
              , me = x.cameras;
            k(x, oe);
            for (let He = 0; He < me.length; He++)
                k(me[He], oe);
            me.length === 2 ? N(x, T, R) : x.projectionMatrix.copy(T.projectionMatrix),
            C(q, x, oe)
        }
        ;
        function C(q, te, fe) {
            fe === null ? q.matrix.copy(te.matrixWorld) : (q.matrix.copy(fe.matrixWorld),
            q.matrix.invert(),
            q.matrix.multiply(te.matrixWorld)),
            q.matrix.decompose(q.position, q.quaternion, q.scale),
            q.updateMatrixWorld(!0),
            q.projectionMatrix.copy(te.projectionMatrix),
            q.projectionMatrixInverse.copy(te.projectionMatrixInverse),
            q.isPerspectiveCamera && (q.fov = Lf * 2 * Math.atan(1 / q.projectionMatrix.elements[5]),
            q.zoom = 1)
        }
        this.getCamera = function() {
            return x
        }
        ,
        this.getFoveation = function() {
            if (!(h === null && d === null))
                return l
        }
        ,
        this.setFoveation = function(q) {
            l = q,
            h !== null && (h.fixedFoveation = q),
            d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = q)
        }
        ,
        this.hasDepthSensing = function() {
            return g.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return g.getMesh(x)
        }
        ;
        let re = null;
        function ue(q, te) {
            if (u = te.getViewerPose(c || o),
            _ = te,
            u !== null) {
                const fe = u.views;
                d !== null && (e.setRenderTargetFramebuffer(E, d.framebuffer),
                e.setRenderTarget(E));
                let oe = !1;
                fe.length !== x.cameras.length && (x.cameras.length = 0,
                oe = !0);
                for (let ze = 0; ze < fe.length; ze++) {
                    const Qe = fe[ze];
                    let et = null;
                    if (d !== null)
                        et = d.getViewport(Qe);
                    else {
                        const I = f.getViewSubImage(h, Qe);
                        et = I.viewport,
                        ze === 0 && (e.setRenderTargetTextures(E, I.colorTexture, I.depthStencilTexture),
                        e.setRenderTarget(E))
                    }
                    let De = y[ze];
                    De === void 0 && (De = new Mi,
                    De.layers.enable(ze),
                    De.viewport = new Wt,
                    y[ze] = De),
                    De.matrix.fromArray(Qe.transform.matrix),
                    De.matrix.decompose(De.position, De.quaternion, De.scale),
                    De.projectionMatrix.fromArray(Qe.projectionMatrix),
                    De.projectionMatrixInverse.copy(De.projectionMatrix).invert(),
                    De.viewport.set(et.x, et.y, et.width, et.height),
                    ze === 0 && (x.matrix.copy(De.matrix),
                    x.matrix.decompose(x.position, x.quaternion, x.scale)),
                    oe === !0 && x.cameras.push(De)
                }
                const me = r.enabledFeatures;
                if (me && me.includes("depth-sensing") && r.depthUsage == "gpu-optimized" && f) {
                    const ze = f.getDepthInformation(fe[0]);
                    ze && ze.isValid && ze.texture && g.init(e, ze, r.renderState)
                }
            }
            for (let fe = 0; fe < S.length; fe++) {
                const oe = v[fe]
                  , me = S[fe];
                oe !== null && me !== void 0 && me.update(oe, te, c || o)
            }
            re && re(q, te),
            te.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: te
            }),
            _ = null
        }
        const we = new Ng;
        we.setAnimationLoop(ue),
        this.setAnimationLoop = function(q) {
            re = q
        }
        ,
        this.dispose = function() {}
    }
}
const rs = new vr
  , Bb = new jt;
function zb(i, e) {
    function t(m, p) {
        m.matrixAutoUpdate === !0 && m.updateMatrix(),
        p.value.copy(m.matrix)
    }
    function n(m, p) {
        p.color.getRGB(m.fogColor.value, Dg(i)),
        p.isFog ? (m.fogNear.value = p.near,
        m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density)
    }
    function r(m, p, E, S, v) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(m, p) : p.isMeshToonMaterial ? (s(m, p),
        f(m, p)) : p.isMeshPhongMaterial ? (s(m, p),
        u(m, p)) : p.isMeshStandardMaterial ? (s(m, p),
        h(m, p),
        p.isMeshPhysicalMaterial && d(m, p, v)) : p.isMeshMatcapMaterial ? (s(m, p),
        _(m, p)) : p.isMeshDepthMaterial ? s(m, p) : p.isMeshDistanceMaterial ? (s(m, p),
        g(m, p)) : p.isMeshNormalMaterial ? s(m, p) : p.isLineBasicMaterial ? (o(m, p),
        p.isLineDashedMaterial && a(m, p)) : p.isPointsMaterial ? l(m, p, E, S) : p.isSpriteMaterial ? c(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color),
        m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function s(m, p) {
        m.opacity.value = p.opacity,
        p.color && m.diffuse.value.copy(p.color),
        p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.bumpMap && (m.bumpMap.value = p.bumpMap,
        t(p.bumpMap, m.bumpMapTransform),
        m.bumpScale.value = p.bumpScale,
        p.side === an && (m.bumpScale.value *= -1)),
        p.normalMap && (m.normalMap.value = p.normalMap,
        t(p.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(p.normalScale),
        p.side === an && m.normalScale.value.negate()),
        p.displacementMap && (m.displacementMap.value = p.displacementMap,
        t(p.displacementMap, m.displacementMapTransform),
        m.displacementScale.value = p.displacementScale,
        m.displacementBias.value = p.displacementBias),
        p.emissiveMap && (m.emissiveMap.value = p.emissiveMap,
        t(p.emissiveMap, m.emissiveMapTransform)),
        p.specularMap && (m.specularMap.value = p.specularMap,
        t(p.specularMap, m.specularMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        const E = e.get(p)
          , S = E.envMap
          , v = E.envMapRotation;
        S && (m.envMap.value = S,
        rs.copy(v),
        rs.x *= -1,
        rs.y *= -1,
        rs.z *= -1,
        S.isCubeTexture && S.isRenderTargetTexture === !1 && (rs.y *= -1,
        rs.z *= -1),
        m.envMapRotation.value.setFromMatrix4(Bb.makeRotationFromEuler(rs)),
        m.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1,
        m.reflectivity.value = p.reflectivity,
        m.ior.value = p.ior,
        m.refractionRatio.value = p.refractionRatio),
        p.lightMap && (m.lightMap.value = p.lightMap,
        m.lightMapIntensity.value = p.lightMapIntensity,
        t(p.lightMap, m.lightMapTransform)),
        p.aoMap && (m.aoMap.value = p.aoMap,
        m.aoMapIntensity.value = p.aoMapIntensity,
        t(p.aoMap, m.aoMapTransform))
    }
    function o(m, p) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform))
    }
    function a(m, p) {
        m.dashSize.value = p.dashSize,
        m.totalSize.value = p.dashSize + p.gapSize,
        m.scale.value = p.scale
    }
    function l(m, p, E, S) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        m.size.value = p.size * E,
        m.scale.value = S * .5,
        p.map && (m.map.value = p.map,
        t(p.map, m.uvTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
    }
    function c(m, p) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        m.rotation.value = p.rotation,
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
    }
    function u(m, p) {
        m.specular.value.copy(p.specular),
        m.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function f(m, p) {
        p.gradientMap && (m.gradientMap.value = p.gradientMap)
    }
    function h(m, p) {
        m.metalness.value = p.metalness,
        p.metalnessMap && (m.metalnessMap.value = p.metalnessMap,
        t(p.metalnessMap, m.metalnessMapTransform)),
        m.roughness.value = p.roughness,
        p.roughnessMap && (m.roughnessMap.value = p.roughnessMap,
        t(p.roughnessMap, m.roughnessMapTransform)),
        p.envMap && (m.envMapIntensity.value = p.envMapIntensity)
    }
    function d(m, p, E) {
        m.ior.value = p.ior,
        p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        m.sheenRoughness.value = p.sheenRoughness,
        p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap,
        t(p.sheenColorMap, m.sheenColorMapTransform)),
        p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap,
        t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
        p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat,
        m.clearcoatRoughness.value = p.clearcoatRoughness,
        p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap,
        t(p.clearcoatMap, m.clearcoatMapTransform)),
        p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap,
        t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap,
        t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform),
        m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
        p.side === an && m.clearcoatNormalScale.value.negate())),
        p.dispersion > 0 && (m.dispersion.value = p.dispersion),
        p.iridescence > 0 && (m.iridescence.value = p.iridescence,
        m.iridescenceIOR.value = p.iridescenceIOR,
        m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0],
        m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1],
        p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap,
        t(p.iridescenceMap, m.iridescenceMapTransform)),
        p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap,
        t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
        p.transmission > 0 && (m.transmission.value = p.transmission,
        m.transmissionSamplerMap.value = E.texture,
        m.transmissionSamplerSize.value.set(E.width, E.height),
        p.transmissionMap && (m.transmissionMap.value = p.transmissionMap,
        t(p.transmissionMap, m.transmissionMapTransform)),
        m.thickness.value = p.thickness,
        p.thicknessMap && (m.thicknessMap.value = p.thicknessMap,
        t(p.thicknessMap, m.thicknessMapTransform)),
        m.attenuationDistance.value = p.attenuationDistance,
        m.attenuationColor.value.copy(p.attenuationColor)),
        p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)),
        p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap,
        t(p.anisotropyMap, m.anisotropyMapTransform))),
        m.specularIntensity.value = p.specularIntensity,
        m.specularColor.value.copy(p.specularColor),
        p.specularColorMap && (m.specularColorMap.value = p.specularColorMap,
        t(p.specularColorMap, m.specularColorMapTransform)),
        p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap,
        t(p.specularIntensityMap, m.specularIntensityMapTransform))
    }
    function _(m, p) {
        p.matcap && (m.matcap.value = p.matcap)
    }
    function g(m, p) {
        const E = e.get(p).light;
        m.referencePosition.value.setFromMatrixPosition(E.matrixWorld),
        m.nearDistance.value = E.shadow.camera.near,
        m.farDistance.value = E.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: r
    }
}
function kb(i, e, t, n) {
    let r = {}
      , s = {}
      , o = [];
    const a = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(E, S) {
        const v = S.program;
        n.uniformBlockBinding(E, v)
    }
    function c(E, S) {
        let v = r[E.id];
        v === void 0 && (_(E),
        v = u(E),
        r[E.id] = v,
        E.addEventListener("dispose", m));
        const b = S.program;
        n.updateUBOMapping(E, b);
        const A = e.render.frame;
        s[E.id] !== A && (h(E),
        s[E.id] = A)
    }
    function u(E) {
        const S = f();
        E.__bindingPointIndex = S;
        const v = i.createBuffer()
          , b = E.__size
          , A = E.usage;
        return i.bindBuffer(i.UNIFORM_BUFFER, v),
        i.bufferData(i.UNIFORM_BUFFER, b, A),
        i.bindBuffer(i.UNIFORM_BUFFER, null),
        i.bindBufferBase(i.UNIFORM_BUFFER, S, v),
        v
    }
    function f() {
        for (let E = 0; E < a; E++)
            if (o.indexOf(E) === -1)
                return o.push(E),
                E;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function h(E) {
        const S = r[E.id]
          , v = E.uniforms
          , b = E.__cache;
        i.bindBuffer(i.UNIFORM_BUFFER, S);
        for (let A = 0, T = v.length; A < T; A++) {
            const R = Array.isArray(v[A]) ? v[A] : [v[A]];
            for (let y = 0, x = R.length; y < x; y++) {
                const P = R[y];
                if (d(P, A, y, b) === !0) {
                    const U = P.__offset
                      , O = Array.isArray(P.value) ? P.value : [P.value];
                    let B = 0;
                    for (let X = 0; X < O.length; X++) {
                        const H = O[X]
                          , Y = g(H);
                        typeof H == "number" || typeof H == "boolean" ? (P.__data[0] = H,
                        i.bufferSubData(i.UNIFORM_BUFFER, U + B, P.__data)) : H.isMatrix3 ? (P.__data[0] = H.elements[0],
                        P.__data[1] = H.elements[1],
                        P.__data[2] = H.elements[2],
                        P.__data[3] = 0,
                        P.__data[4] = H.elements[3],
                        P.__data[5] = H.elements[4],
                        P.__data[6] = H.elements[5],
                        P.__data[7] = 0,
                        P.__data[8] = H.elements[6],
                        P.__data[9] = H.elements[7],
                        P.__data[10] = H.elements[8],
                        P.__data[11] = 0) : (H.toArray(P.__data, B),
                        B += Y.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    i.bufferSubData(i.UNIFORM_BUFFER, U, P.__data)
                }
            }
        }
        i.bindBuffer(i.UNIFORM_BUFFER, null)
    }
    function d(E, S, v, b) {
        const A = E.value
          , T = S + "_" + v;
        if (b[T] === void 0)
            return typeof A == "number" || typeof A == "boolean" ? b[T] = A : b[T] = A.clone(),
            !0;
        {
            const R = b[T];
            if (typeof A == "number" || typeof A == "boolean") {
                if (R !== A)
                    return b[T] = A,
                    !0
            } else if (R.equals(A) === !1)
                return R.copy(A),
                !0
        }
        return !1
    }
    function _(E) {
        const S = E.uniforms;
        let v = 0;
        const b = 16;
        for (let T = 0, R = S.length; T < R; T++) {
            const y = Array.isArray(S[T]) ? S[T] : [S[T]];
            for (let x = 0, P = y.length; x < P; x++) {
                const U = y[x]
                  , O = Array.isArray(U.value) ? U.value : [U.value];
                for (let B = 0, X = O.length; B < X; B++) {
                    const H = O[B]
                      , Y = g(H)
                      , N = v % b
                      , k = N % Y.boundary
                      , C = N + k;
                    v += k,
                    C !== 0 && b - C < Y.storage && (v += b - C),
                    U.__data = new Float32Array(Y.storage / Float32Array.BYTES_PER_ELEMENT),
                    U.__offset = v,
                    v += Y.storage
                }
            }
        }
        const A = v % b;
        return A > 0 && (v += b - A),
        E.__size = v,
        E.__cache = {},
        this
    }
    function g(E) {
        const S = {
            boundary: 0,
            storage: 0
        };
        return typeof E == "number" || typeof E == "boolean" ? (S.boundary = 4,
        S.storage = 4) : E.isVector2 ? (S.boundary = 8,
        S.storage = 8) : E.isVector3 || E.isColor ? (S.boundary = 16,
        S.storage = 12) : E.isVector4 ? (S.boundary = 16,
        S.storage = 16) : E.isMatrix3 ? (S.boundary = 48,
        S.storage = 48) : E.isMatrix4 ? (S.boundary = 64,
        S.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E),
        S
    }
    function m(E) {
        const S = E.target;
        S.removeEventListener("dispose", m);
        const v = o.indexOf(S.__bindingPointIndex);
        o.splice(v, 1),
        i.deleteBuffer(r[S.id]),
        delete r[S.id],
        delete s[S.id]
    }
    function p() {
        for (const E in r)
            i.deleteBuffer(r[E]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: p
    }
}
class Hb {
    constructor(e={}) {
        const {canvas: t=Sy(), context: n=null, depth: r=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: f=!1, reverseDepthBuffer: h=!1} = e;
        this.isWebGLRenderer = !0;
        let d;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            d = n.getContextAttributes().alpha
        } else
            d = o;
        const _ = new Uint32Array(4)
          , g = new Int32Array(4);
        let m = null
          , p = null;
        const E = []
          , S = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = Br,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const v = this;
        let b = !1;
        this._outputColorSpace = kt;
        let A = 0
          , T = 0
          , R = null
          , y = -1
          , x = null;
        const P = new Wt
          , U = new Wt;
        let O = null;
        const B = new St(0);
        let X = 0
          , H = t.width
          , Y = t.height
          , N = 1
          , k = null
          , C = null;
        const re = new Wt(0,0,H,Y)
          , ue = new Wt(0,0,H,Y);
        let we = !1;
        const q = new Ug;
        let te = !1
          , fe = !1;
        const oe = new jt
          , me = new jt
          , He = new Z
          , ze = new Wt
          , Qe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let et = !1;
        function De() {
            return R === null ? N : 1
        }
        let I = n;
        function Je(w, z) {
            return t.getContext(w, z)
        }
        try {
            const w = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: f
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", "three.js r".concat(uc)),
            t.addEventListener("webglcontextlost", pe, !1),
            t.addEventListener("webglcontextrestored", se, !1),
            t.addEventListener("webglcontextcreationerror", Q, !1),
            I === null) {
                const z = "webgl2";
                if (I = Je(z, w),
                I === null)
                    throw Je(z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (w) {
            throw console.error("THREE.WebGLRenderer: " + w.message),
            w
        }
        let Ge, G, Ee, Ke, Ue, ge, ht, D, M, V, ne, ee, J, Ae, de, Ce, $, K, ae, Me, Te, ce, Ne, L;
        function he() {
            Ge = new ZM(I),
            Ge.init(),
            ce = new Ib(I,Ge),
            G = new WM(I,Ge,e,ce),
            Ee = new Db(I,Ge),
            G.reverseDepthBuffer && h && Ee.buffers.depth.setReversed(!0),
            Ke = new eT(I),
            Ue = new vb,
            ge = new Lb(I,Ge,Ee,Ue,G,ce,Ke),
            ht = new qM(v),
            D = new KM(v),
            M = new oS(I),
            Ne = new VM(I,M),
            V = new JM(I,M,Ke,Ne),
            ne = new nT(I,V,M,Ke),
            ae = new tT(I,G,ge),
            Ce = new XM(Ue),
            ee = new _b(v,ht,D,Ge,G,Ne,Ce),
            J = new zb(v,Ue),
            Ae = new yb,
            de = new wb(Ge),
            K = new HM(v,ht,D,Ee,ne,d,l),
            $ = new Cb(v,ne,G),
            L = new kb(I,Ke,G,Ee),
            Me = new GM(I,Ge,Ke),
            Te = new QM(I,Ge,Ke),
            Ke.programs = ee.programs,
            v.capabilities = G,
            v.extensions = Ge,
            v.properties = Ue,
            v.renderLists = Ae,
            v.shadowMap = $,
            v.state = Ee,
            v.info = Ke
        }
        he();
        const ie = new Fb(v,I);
        this.xr = ie,
        this.getContext = function() {
            return I
        }
        ,
        this.getContextAttributes = function() {
            return I.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const w = Ge.get("WEBGL_lose_context");
            w && w.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const w = Ge.get("WEBGL_lose_context");
            w && w.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return N
        }
        ,
        this.setPixelRatio = function(w) {
            w !== void 0 && (N = w,
            this.setSize(H, Y, !1))
        }
        ,
        this.getSize = function(w) {
            return w.set(H, Y)
        }
        ,
        this.setSize = function(w, z, j=!0) {
            if (ie.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            H = w,
            Y = z,
            t.width = Math.floor(w * N),
            t.height = Math.floor(z * N),
            j === !0 && (t.style.width = w + "px",
            t.style.height = z + "px"),
            this.setViewport(0, 0, w, z)
        }
        ,
        this.getDrawingBufferSize = function(w) {
            return w.set(H * N, Y * N).floor()
        }
        ,
        this.setDrawingBufferSize = function(w, z, j) {
            H = w,
            Y = z,
            N = j,
            t.width = Math.floor(w * j),
            t.height = Math.floor(z * j),
            this.setViewport(0, 0, w, z)
        }
        ,
        this.getCurrentViewport = function(w) {
            return w.copy(P)
        }
        ,
        this.getViewport = function(w) {
            return w.copy(re)
        }
        ,
        this.setViewport = function(w, z, j, W) {
            w.isVector4 ? re.set(w.x, w.y, w.z, w.w) : re.set(w, z, j, W),
            Ee.viewport(P.copy(re).multiplyScalar(N).round())
        }
        ,
        this.getScissor = function(w) {
            return w.copy(ue)
        }
        ,
        this.setScissor = function(w, z, j, W) {
            w.isVector4 ? ue.set(w.x, w.y, w.z, w.w) : ue.set(w, z, j, W),
            Ee.scissor(U.copy(ue).multiplyScalar(N).round())
        }
        ,
        this.getScissorTest = function() {
            return we
        }
        ,
        this.setScissorTest = function(w) {
            Ee.setScissorTest(we = w)
        }
        ,
        this.setOpaqueSort = function(w) {
            k = w
        }
        ,
        this.setTransparentSort = function(w) {
            C = w
        }
        ,
        this.getClearColor = function(w) {
            return w.copy(K.getClearColor())
        }
        ,
        this.setClearColor = function() {
            K.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return K.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            K.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(w=!0, z=!0, j=!0) {
            let W = 0;
            if (w) {
                let F = !1;
                if (R !== null) {
                    const le = R.texture.format;
                    F = le === xh || le === vh || le === _h
                }
                if (F) {
                    const le = R.texture.type
                      , ve = le === hi || le === Gr || le === Ra || le === Ro || le === mh || le === gh
                      , Ie = K.getClearColor()
                      , Re = K.getClearAlpha()
                      , ke = Ie.r
                      , We = Ie.g
                      , Be = Ie.b;
                    ve ? (_[0] = ke,
                    _[1] = We,
                    _[2] = Be,
                    _[3] = Re,
                    I.clearBufferuiv(I.COLOR, 0, _)) : (g[0] = ke,
                    g[1] = We,
                    g[2] = Be,
                    g[3] = Re,
                    I.clearBufferiv(I.COLOR, 0, g))
                } else
                    W |= I.COLOR_BUFFER_BIT
            }
            z && (W |= I.DEPTH_BUFFER_BIT),
            j && (W |= I.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            I.clear(W)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", pe, !1),
            t.removeEventListener("webglcontextrestored", se, !1),
            t.removeEventListener("webglcontextcreationerror", Q, !1),
            K.dispose(),
            Ae.dispose(),
            de.dispose(),
            Ue.dispose(),
            ht.dispose(),
            D.dispose(),
            ne.dispose(),
            Ne.dispose(),
            L.dispose(),
            ee.dispose(),
            ie.dispose(),
            ie.removeEventListener("sessionstart", _e),
            ie.removeEventListener("sessionend", $e),
            Fe.stop()
        }
        ;
        function pe(w) {
            w.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            b = !0
        }
        function se() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            b = !1;
            const w = Ke.autoReset
              , z = $.enabled
              , j = $.autoUpdate
              , W = $.needsUpdate
              , F = $.type;
            he(),
            Ke.autoReset = w,
            $.enabled = z,
            $.autoUpdate = j,
            $.needsUpdate = W,
            $.type = F
        }
        function Q(w) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", w.statusMessage)
        }
        function Pe(w) {
            const z = w.target;
            z.removeEventListener("dispose", Pe),
            Ve(z)
        }
        function Ve(w) {
            gt(w),
            Ue.remove(w)
        }
        function gt(w) {
            const z = Ue.get(w).programs;
            z !== void 0 && (z.forEach(function(j) {
                ee.releaseProgram(j)
            }),
            w.isShaderMaterial && ee.releaseShaderCache(w))
        }
        this.renderBufferDirect = function(w, z, j, W, F, le) {
            z === null && (z = Qe);
            const ve = F.isMesh && F.matrixWorld.determinant() < 0
              , Ie = Kn(w, z, j, W, F);
            Ee.setMaterial(W, ve);
            let Re = j.index
              , ke = 1;
            if (W.wireframe === !0) {
                if (Re = V.getWireframeAttribute(j),
                Re === void 0)
                    return;
                ke = 2
            }
            const We = j.drawRange
              , Be = j.attributes.position;
            let Ze = We.start * ke
              , Et = (We.start + We.count) * ke;
            le !== null && (Ze = Math.max(Ze, le.start * ke),
            Et = Math.min(Et, (le.start + le.count) * ke)),
            Re !== null ? (Ze = Math.max(Ze, 0),
            Et = Math.min(Et, Re.count)) : Be != null && (Ze = Math.max(Ze, 0),
            Et = Math.min(Et, Be.count));
            const Nt = Et - Ze;
            if (Nt < 0 || Nt === 1 / 0)
                return;
            Ne.setup(F, W, Ie, j, Re);
            let zt, dt = Me;
            if (Re !== null && (zt = M.get(Re),
            dt = Te,
            dt.setIndex(zt)),
            F.isMesh)
                W.wireframe === !0 ? (Ee.setLineWidth(W.wireframeLinewidth * De()),
                dt.setMode(I.LINES)) : dt.setMode(I.TRIANGLES);
            else if (F.isLine) {
                let Xe = W.linewidth;
                Xe === void 0 && (Xe = 1),
                Ee.setLineWidth(Xe * De()),
                F.isLineSegments ? dt.setMode(I.LINES) : F.isLineLoop ? dt.setMode(I.LINE_LOOP) : dt.setMode(I.LINE_STRIP)
            } else
                F.isPoints ? dt.setMode(I.POINTS) : F.isSprite && dt.setMode(I.TRIANGLES);
            if (F.isBatchedMesh)
                if (F._multiDrawInstances !== null)
                    go("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    dt.renderMultiDrawInstances(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount, F._multiDrawInstances);
                else if (Ge.get("WEBGL_multi_draw"))
                    dt.renderMultiDraw(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount);
                else {
                    const Xe = F._multiDrawStarts
                      , fn = F._multiDrawCounts
                      , xt = F._multiDrawCount
                      , Ri = Re ? M.get(Re).bytesPerElement : 1
                      , Is = Ue.get(W).currentProgram.getUniforms();
                    for (let Zn = 0; Zn < xt; Zn++)
                        Is.setValue(I, "_gl_DrawID", Zn),
                        dt.render(Xe[Zn] / Ri, fn[Zn])
                }
            else if (F.isInstancedMesh)
                dt.renderInstances(Ze, Nt, F.count);
            else if (j.isInstancedBufferGeometry) {
                const Xe = j._maxInstanceCount !== void 0 ? j._maxInstanceCount : 1 / 0
                  , fn = Math.min(j.instanceCount, Xe);
                dt.renderInstances(Ze, Nt, fn)
            } else
                dt.render(Ze, Nt)
        }
        ;
        function be(w, z, j) {
            w.transparent === !0 && w.side === pn && w.forceSinglePass === !1 ? (w.side = an,
            w.needsUpdate = !0,
            Tt(w, z, j),
            w.side = _r,
            w.needsUpdate = !0,
            Tt(w, z, j),
            w.side = pn) : Tt(w, z, j)
        }
        this.compile = function(w, z, j=null) {
            j === null && (j = w),
            p = de.get(j),
            p.init(z),
            S.push(p),
            j.traverseVisible(function(F) {
                F.isLight && F.layers.test(z.layers) && (p.pushLight(F),
                F.castShadow && p.pushShadow(F))
            }),
            w !== j && w.traverseVisible(function(F) {
                F.isLight && F.layers.test(z.layers) && (p.pushLight(F),
                F.castShadow && p.pushShadow(F))
            }),
            p.setupLights();
            const W = new Set;
            return w.traverse(function(F) {
                if (!(F.isMesh || F.isPoints || F.isLine || F.isSprite))
                    return;
                const le = F.material;
                if (le)
                    if (Array.isArray(le))
                        for (let ve = 0; ve < le.length; ve++) {
                            const Ie = le[ve];
                            be(Ie, j, F),
                            W.add(Ie)
                        }
                    else
                        be(le, j, F),
                        W.add(le)
            }),
            p = S.pop(),
            W
        }
        ,
        this.compileAsync = function(w, z, j=null) {
            const W = this.compile(w, z, j);
            return new Promise(F => {
                function le() {
                    if (W.forEach(function(ve) {
                        Ue.get(ve).currentProgram.isReady() && W.delete(ve)
                    }),
                    W.size === 0) {
                        F(w);
                        return
                    }
                    setTimeout(le, 10)
                }
                Ge.get("KHR_parallel_shader_compile") !== null ? le() : setTimeout(le, 10)
            }
            )
        }
        ;
        let Oe = null;
        function tt(w) {
            Oe && Oe(w)
        }
        function _e() {
            Fe.stop()
        }
        function $e() {
            Fe.start()
        }
        const Fe = new Ng;
        Fe.setAnimationLoop(tt),
        typeof self < "u" && Fe.setContext(self),
        this.setAnimationLoop = function(w) {
            Oe = w,
            ie.setAnimationLoop(w),
            w === null ? Fe.stop() : Fe.start()
        }
        ,
        ie.addEventListener("sessionstart", _e),
        ie.addEventListener("sessionend", $e),
        this.render = function(w, z) {
            if (z !== void 0 && z.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (b === !0)
                return;
            if (w.matrixWorldAutoUpdate === !0 && w.updateMatrixWorld(),
            z.parent === null && z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
            ie.enabled === !0 && ie.isPresenting === !0 && (ie.cameraAutoUpdate === !0 && ie.updateCamera(z),
            z = ie.getCamera()),
            w.isScene === !0 && w.onBeforeRender(v, w, z, R),
            p = de.get(w, S.length),
            p.init(z),
            S.push(p),
            me.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse),
            q.setFromProjectionMatrix(me),
            fe = this.localClippingEnabled,
            te = Ce.init(this.clippingPlanes, fe),
            m = Ae.get(w, E.length),
            m.init(),
            E.push(m),
            ie.enabled === !0 && ie.isPresenting === !0) {
                const le = v.xr.getDepthSensingMesh();
                le !== null && Ye(le, z, -1 / 0, v.sortObjects)
            }
            Ye(w, z, 0, v.sortObjects),
            m.finish(),
            v.sortObjects === !0 && m.sort(k, C),
            et = ie.enabled === !1 || ie.isPresenting === !1 || ie.hasDepthSensing() === !1,
            et && K.addToRenderList(m, w),
            this.info.render.frame++,
            te === !0 && Ce.beginShadows();
            const j = p.state.shadowsArray;
            $.render(j, w, z),
            te === !0 && Ce.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const W = m.opaque
              , F = m.transmissive;
            if (p.setupLights(),
            z.isArrayCamera) {
                const le = z.cameras;
                if (F.length > 0)
                    for (let ve = 0, Ie = le.length; ve < Ie; ve++) {
                        const Re = le[ve];
                        st(W, F, w, Re)
                    }
                et && K.render(w);
                for (let ve = 0, Ie = le.length; ve < Ie; ve++) {
                    const Re = le[ve];
                    Vt(m, w, Re, Re.viewport)
                }
            } else
                F.length > 0 && st(W, F, w, z),
                et && K.render(w),
                Vt(m, w, z);
            R !== null && T === 0 && (ge.updateMultisampleRenderTarget(R),
            ge.updateRenderTargetMipmap(R)),
            w.isScene === !0 && w.onAfterRender(v, w, z),
            Ne.resetDefaultState(),
            y = -1,
            x = null,
            S.pop(),
            S.length > 0 ? (p = S[S.length - 1],
            te === !0 && Ce.setGlobalState(v.clippingPlanes, p.state.camera)) : p = null,
            E.pop(),
            E.length > 0 ? m = E[E.length - 1] : m = null
        }
        ;
        function Ye(w, z, j, W) {
            if (w.visible === !1)
                return;
            if (w.layers.test(z.layers)) {
                if (w.isGroup)
                    j = w.renderOrder;
                else if (w.isLOD)
                    w.autoUpdate === !0 && w.update(z);
                else if (w.isLight)
                    p.pushLight(w),
                    w.castShadow && p.pushShadow(w);
                else if (w.isSprite) {
                    if (!w.frustumCulled || q.intersectsSprite(w)) {
                        W && ze.setFromMatrixPosition(w.matrixWorld).applyMatrix4(me);
                        const ve = ne.update(w)
                          , Ie = w.material;
                        Ie.visible && m.push(w, ve, Ie, j, ze.z, null)
                    }
                } else if ((w.isMesh || w.isLine || w.isPoints) && (!w.frustumCulled || q.intersectsObject(w))) {
                    const ve = ne.update(w)
                      , Ie = w.material;
                    if (W && (w.boundingSphere !== void 0 ? (w.boundingSphere === null && w.computeBoundingSphere(),
                    ze.copy(w.boundingSphere.center)) : (ve.boundingSphere === null && ve.computeBoundingSphere(),
                    ze.copy(ve.boundingSphere.center)),
                    ze.applyMatrix4(w.matrixWorld).applyMatrix4(me)),
                    Array.isArray(Ie)) {
                        const Re = ve.groups;
                        for (let ke = 0, We = Re.length; ke < We; ke++) {
                            const Be = Re[ke]
                              , Ze = Ie[Be.materialIndex];
                            Ze && Ze.visible && m.push(w, ve, Ze, j, ze.z, Be)
                        }
                    } else
                        Ie.visible && m.push(w, ve, Ie, j, ze.z, null)
                }
            }
            const le = w.children;
            for (let ve = 0, Ie = le.length; ve < Ie; ve++)
                Ye(le[ve], z, j, W)
        }
        function Vt(w, z, j, W) {
            const F = w.opaque
              , le = w.transmissive
              , ve = w.transparent;
            p.setupLightsView(j),
            te === !0 && Ce.setGlobalState(v.clippingPlanes, j),
            W && Ee.viewport(P.copy(W)),
            F.length > 0 && Rt(F, z, j),
            le.length > 0 && Rt(le, z, j),
            ve.length > 0 && Rt(ve, z, j),
            Ee.buffers.depth.setTest(!0),
            Ee.buffers.depth.setMask(!0),
            Ee.buffers.color.setMask(!0),
            Ee.setPolygonOffset(!1)
        }
        function st(w, z, j, W) {
            if ((j.isScene === !0 ? j.overrideMaterial : null) !== null)
                return;
            p.state.transmissionRenderTarget[W.id] === void 0 && (p.state.transmissionRenderTarget[W.id] = new Bi(1,1,{
                generateMipmaps: !0,
                type: Ge.has("EXT_color_buffer_half_float") || Ge.has("EXT_color_buffer_float") ? Ia : hi,
                minFilter: _s,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: pt.workingColorSpace
            }));
            const le = p.state.transmissionRenderTarget[W.id]
              , ve = W.viewport || P;
            le.setSize(ve.z * v.transmissionResolutionScale, ve.w * v.transmissionResolutionScale);
            const Ie = v.getRenderTarget();
            v.setRenderTarget(le),
            v.getClearColor(B),
            X = v.getClearAlpha(),
            X < 1 && v.setClearColor(16777215, .5),
            v.clear(),
            et && K.render(j);
            const Re = v.toneMapping;
            v.toneMapping = Br;
            const ke = W.viewport;
            if (W.viewport !== void 0 && (W.viewport = void 0),
            p.setupLightsView(W),
            te === !0 && Ce.setGlobalState(v.clippingPlanes, W),
            Rt(w, j, W),
            ge.updateMultisampleRenderTarget(le),
            ge.updateRenderTargetMipmap(le),
            Ge.has("WEBGL_multisampled_render_to_texture") === !1) {
                let We = !1;
                for (let Be = 0, Ze = z.length; Be < Ze; Be++) {
                    const Et = z[Be]
                      , Nt = Et.object
                      , zt = Et.geometry
                      , dt = Et.material
                      , Xe = Et.group;
                    if (dt.side === pn && Nt.layers.test(W.layers)) {
                        const fn = dt.side;
                        dt.side = an,
                        dt.needsUpdate = !0,
                        Kt(Nt, j, W, zt, dt, Xe),
                        dt.side = fn,
                        dt.needsUpdate = !0,
                        We = !0
                    }
                }
                We === !0 && (ge.updateMultisampleRenderTarget(le),
                ge.updateRenderTargetMipmap(le))
            }
            v.setRenderTarget(Ie),
            v.setClearColor(B, X),
            ke !== void 0 && (W.viewport = ke),
            v.toneMapping = Re
        }
        function Rt(w, z, j) {
            const W = z.isScene === !0 ? z.overrideMaterial : null;
            for (let F = 0, le = w.length; F < le; F++) {
                const ve = w[F]
                  , Ie = ve.object
                  , Re = ve.geometry
                  , ke = ve.group;
                let We = ve.material;
                We.allowOverride === !0 && W !== null && (We = W),
                Ie.layers.test(j.layers) && Kt(Ie, z, j, Re, We, ke)
            }
        }
        function Kt(w, z, j, W, F, le) {
            w.onBeforeRender(v, z, j, W, F, le),
            w.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, w.matrixWorld),
            w.normalMatrix.getNormalMatrix(w.modelViewMatrix),
            F.onBeforeRender(v, z, j, W, w, le),
            F.transparent === !0 && F.side === pn && F.forceSinglePass === !1 ? (F.side = an,
            F.needsUpdate = !0,
            v.renderBufferDirect(j, z, W, F, w, le),
            F.side = _r,
            F.needsUpdate = !0,
            v.renderBufferDirect(j, z, W, F, w, le),
            F.side = pn) : v.renderBufferDirect(j, z, W, F, w, le),
            w.onAfterRender(v, z, j, W, F, le)
        }
        function Tt(w, z, j) {
            z.isScene !== !0 && (z = Qe);
            const W = Ue.get(w)
              , F = p.state.lights
              , le = p.state.shadowsArray
              , ve = F.state.version
              , Ie = ee.getParameters(w, F.state, le, z, j)
              , Re = ee.getProgramCacheKey(Ie);
            let ke = W.programs;
            W.environment = w.isMeshStandardMaterial ? z.environment : null,
            W.fog = z.fog,
            W.envMap = (w.isMeshStandardMaterial ? D : ht).get(w.envMap || W.environment),
            W.envMapRotation = W.environment !== null && w.envMap === null ? z.environmentRotation : w.envMapRotation,
            ke === void 0 && (w.addEventListener("dispose", Pe),
            ke = new Map,
            W.programs = ke);
            let We = ke.get(Re);
            if (We !== void 0) {
                if (W.currentProgram === We && W.lightsStateVersion === ve)
                    return vt(w, Ie),
                    We
            } else
                Ie.uniforms = ee.getUniforms(w),
                w.onBeforeCompile(Ie, v),
                We = ee.acquireProgram(Ie, Re),
                ke.set(Re, We),
                W.uniforms = Ie.uniforms;
            const Be = W.uniforms;
            return (!w.isShaderMaterial && !w.isRawShaderMaterial || w.clipping === !0) && (Be.clippingPlanes = Ce.uniform),
            vt(w, Ie),
            W.needsLights = bn(w),
            W.lightsStateVersion = ve,
            W.needsLights && (Be.ambientLightColor.value = F.state.ambient,
            Be.lightProbe.value = F.state.probe,
            Be.directionalLights.value = F.state.directional,
            Be.directionalLightShadows.value = F.state.directionalShadow,
            Be.spotLights.value = F.state.spot,
            Be.spotLightShadows.value = F.state.spotShadow,
            Be.rectAreaLights.value = F.state.rectArea,
            Be.ltc_1.value = F.state.rectAreaLTC1,
            Be.ltc_2.value = F.state.rectAreaLTC2,
            Be.pointLights.value = F.state.point,
            Be.pointLightShadows.value = F.state.pointShadow,
            Be.hemisphereLights.value = F.state.hemi,
            Be.directionalShadowMap.value = F.state.directionalShadowMap,
            Be.directionalShadowMatrix.value = F.state.directionalShadowMatrix,
            Be.spotShadowMap.value = F.state.spotShadowMap,
            Be.spotLightMatrix.value = F.state.spotLightMatrix,
            Be.spotLightMap.value = F.state.spotLightMap,
            Be.pointShadowMap.value = F.state.pointShadowMap,
            Be.pointShadowMatrix.value = F.state.pointShadowMatrix),
            W.currentProgram = We,
            W.uniformsList = null,
            We
        }
        function bt(w) {
            if (w.uniformsList === null) {
                const z = w.currentProgram.getUniforms();
                w.uniformsList = Bl.seqWithValue(z.seq, w.uniforms)
            }
            return w.uniformsList
        }
        function vt(w, z) {
            const j = Ue.get(w);
            j.outputColorSpace = z.outputColorSpace,
            j.batching = z.batching,
            j.batchingColor = z.batchingColor,
            j.instancing = z.instancing,
            j.instancingColor = z.instancingColor,
            j.instancingMorph = z.instancingMorph,
            j.skinning = z.skinning,
            j.morphTargets = z.morphTargets,
            j.morphNormals = z.morphNormals,
            j.morphColors = z.morphColors,
            j.morphTargetsCount = z.morphTargetsCount,
            j.numClippingPlanes = z.numClippingPlanes,
            j.numIntersection = z.numClipIntersection,
            j.vertexAlphas = z.vertexAlphas,
            j.vertexTangents = z.vertexTangents,
            j.toneMapping = z.toneMapping
        }
        function Kn(w, z, j, W, F) {
            z.isScene !== !0 && (z = Qe),
            ge.resetTextureUnits();
            const le = z.fog
              , ve = W.isMeshStandardMaterial ? z.environment : null
              , Ie = R === null ? v.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : Wr
              , Re = (W.isMeshStandardMaterial ? D : ht).get(W.envMap || ve)
              , ke = W.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4
              , We = !!j.attributes.tangent && (!!W.normalMap || W.anisotropy > 0)
              , Be = !!j.morphAttributes.position
              , Ze = !!j.morphAttributes.normal
              , Et = !!j.morphAttributes.color;
            let Nt = Br;
            W.toneMapped && (R === null || R.isXRRenderTarget === !0) && (Nt = v.toneMapping);
            const zt = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color
              , dt = zt !== void 0 ? zt.length : 0
              , Xe = Ue.get(W)
              , fn = p.state.lights;
            if (te === !0 && (fe === !0 || w !== x)) {
                const wn = w === x && W.id === y;
                Ce.setState(W, w, wn)
            }
            let xt = !1;
            W.version === Xe.__version ? (Xe.needsLights && Xe.lightsStateVersion !== fn.state.version || Xe.outputColorSpace !== Ie || F.isBatchedMesh && Xe.batching === !1 || !F.isBatchedMesh && Xe.batching === !0 || F.isBatchedMesh && Xe.batchingColor === !0 && F.colorTexture === null || F.isBatchedMesh && Xe.batchingColor === !1 && F.colorTexture !== null || F.isInstancedMesh && Xe.instancing === !1 || !F.isInstancedMesh && Xe.instancing === !0 || F.isSkinnedMesh && Xe.skinning === !1 || !F.isSkinnedMesh && Xe.skinning === !0 || F.isInstancedMesh && Xe.instancingColor === !0 && F.instanceColor === null || F.isInstancedMesh && Xe.instancingColor === !1 && F.instanceColor !== null || F.isInstancedMesh && Xe.instancingMorph === !0 && F.morphTexture === null || F.isInstancedMesh && Xe.instancingMorph === !1 && F.morphTexture !== null || Xe.envMap !== Re || W.fog === !0 && Xe.fog !== le || Xe.numClippingPlanes !== void 0 && (Xe.numClippingPlanes !== Ce.numPlanes || Xe.numIntersection !== Ce.numIntersection) || Xe.vertexAlphas !== ke || Xe.vertexTangents !== We || Xe.morphTargets !== Be || Xe.morphNormals !== Ze || Xe.morphColors !== Et || Xe.toneMapping !== Nt || Xe.morphTargetsCount !== dt) && (xt = !0) : (xt = !0,
            Xe.__version = W.version);
            let Ri = Xe.currentProgram;
            xt === !0 && (Ri = Tt(W, z, F));
            let Is = !1
              , Zn = !1
              , Uo = !1;
            const Lt = Ri.getUniforms()
              , pi = Xe.uniforms;
            if (Ee.useProgram(Ri.program) && (Is = !0,
            Zn = !0,
            Uo = !0),
            W.id !== y && (y = W.id,
            Zn = !0),
            Is || x !== w) {
                Ee.buffers.depth.getReversed() ? (oe.copy(w.projectionMatrix),
                My(oe),
                Ty(oe),
                Lt.setValue(I, "projectionMatrix", oe)) : Lt.setValue(I, "projectionMatrix", w.projectionMatrix),
                Lt.setValue(I, "viewMatrix", w.matrixWorldInverse);
                const On = Lt.map.cameraPosition;
                On !== void 0 && On.setValue(I, He.setFromMatrixPosition(w.matrixWorld)),
                G.logarithmicDepthBuffer && Lt.setValue(I, "logDepthBufFC", 2 / (Math.log(w.far + 1) / Math.LN2)),
                (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial) && Lt.setValue(I, "isOrthographic", w.isOrthographicCamera === !0),
                x !== w && (x = w,
                Zn = !0,
                Uo = !0)
            }
            if (F.isSkinnedMesh) {
                Lt.setOptional(I, F, "bindMatrix"),
                Lt.setOptional(I, F, "bindMatrixInverse");
                const wn = F.skeleton;
                wn && (wn.boneTexture === null && wn.computeBoneTexture(),
                Lt.setValue(I, "boneTexture", wn.boneTexture, ge))
            }
            F.isBatchedMesh && (Lt.setOptional(I, F, "batchingTexture"),
            Lt.setValue(I, "batchingTexture", F._matricesTexture, ge),
            Lt.setOptional(I, F, "batchingIdTexture"),
            Lt.setValue(I, "batchingIdTexture", F._indirectTexture, ge),
            Lt.setOptional(I, F, "batchingColorTexture"),
            F._colorsTexture !== null && Lt.setValue(I, "batchingColorTexture", F._colorsTexture, ge));
            const mi = j.morphAttributes;
            if ((mi.position !== void 0 || mi.normal !== void 0 || mi.color !== void 0) && ae.update(F, j, Ri),
            (Zn || Xe.receiveShadow !== F.receiveShadow) && (Xe.receiveShadow = F.receiveShadow,
            Lt.setValue(I, "receiveShadow", F.receiveShadow)),
            W.isMeshGouraudMaterial && W.envMap !== null && (pi.envMap.value = Re,
            pi.flipEnvMap.value = Re.isCubeTexture && Re.isRenderTargetTexture === !1 ? -1 : 1),
            W.isMeshStandardMaterial && W.envMap === null && z.environment !== null && (pi.envMapIntensity.value = z.environmentIntensity),
            Zn && (Lt.setValue(I, "toneMappingExposure", v.toneMappingExposure),
            Xe.needsLights && Pt(pi, Uo),
            le && W.fog === !0 && J.refreshFogUniforms(pi, le),
            J.refreshMaterialUniforms(pi, W, N, Y, p.state.transmissionRenderTarget[w.id]),
            Bl.upload(I, bt(Xe), pi, ge)),
            W.isShaderMaterial && W.uniformsNeedUpdate === !0 && (Bl.upload(I, bt(Xe), pi, ge),
            W.uniformsNeedUpdate = !1),
            W.isSpriteMaterial && Lt.setValue(I, "center", F.center),
            Lt.setValue(I, "modelViewMatrix", F.modelViewMatrix),
            Lt.setValue(I, "normalMatrix", F.normalMatrix),
            Lt.setValue(I, "modelMatrix", F.matrixWorld),
            W.isShaderMaterial || W.isRawShaderMaterial) {
                const wn = W.uniformsGroups;
                for (let On = 0, dc = wn.length; On < dc; On++) {
                    const Kr = wn[On];
                    L.update(Kr, Ri),
                    L.bind(Kr, Ri)
                }
            }
            return Ri
        }
        function Pt(w, z) {
            w.ambientLightColor.needsUpdate = z,
            w.lightProbe.needsUpdate = z,
            w.directionalLights.needsUpdate = z,
            w.directionalLightShadows.needsUpdate = z,
            w.pointLights.needsUpdate = z,
            w.pointLightShadows.needsUpdate = z,
            w.spotLights.needsUpdate = z,
            w.spotLightShadows.needsUpdate = z,
            w.rectAreaLights.needsUpdate = z,
            w.hemisphereLights.needsUpdate = z
        }
        function bn(w) {
            return w.isMeshLambertMaterial || w.isMeshToonMaterial || w.isMeshPhongMaterial || w.isMeshStandardMaterial || w.isShadowMaterial || w.isShaderMaterial && w.lights === !0
        }
        this.getActiveCubeFace = function() {
            return A
        }
        ,
        this.getActiveMipmapLevel = function() {
            return T
        }
        ,
        this.getRenderTarget = function() {
            return R
        }
        ,
        this.setRenderTargetTextures = function(w, z, j) {
            const W = Ue.get(w);
            W.__autoAllocateDepthBuffer = w.resolveDepthBuffer === !1,
            W.__autoAllocateDepthBuffer === !1 && (W.__useRenderToTexture = !1),
            Ue.get(w.texture).__webglTexture = z,
            Ue.get(w.depthTexture).__webglTexture = W.__autoAllocateDepthBuffer ? void 0 : j,
            W.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(w, z) {
            const j = Ue.get(w);
            j.__webglFramebuffer = z,
            j.__useDefaultFramebuffer = z === void 0
        }
        ;
        const di = I.createFramebuffer();
        this.setRenderTarget = function(w, z=0, j=0) {
            R = w,
            A = z,
            T = j;
            let W = !0
              , F = null
              , le = !1
              , ve = !1;
            if (w) {
                const Re = Ue.get(w);
                if (Re.__useDefaultFramebuffer !== void 0)
                    Ee.bindFramebuffer(I.FRAMEBUFFER, null),
                    W = !1;
                else if (Re.__webglFramebuffer === void 0)
                    ge.setupRenderTarget(w);
                else if (Re.__hasExternalTextures)
                    ge.rebindTextures(w, Ue.get(w.texture).__webglTexture, Ue.get(w.depthTexture).__webglTexture);
                else if (w.depthBuffer) {
                    const Be = w.depthTexture;
                    if (Re.__boundDepthTexture !== Be) {
                        if (Be !== null && Ue.has(Be) && (w.width !== Be.image.width || w.height !== Be.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        ge.setupDepthRenderbuffer(w)
                    }
                }
                const ke = w.texture;
                (ke.isData3DTexture || ke.isDataArrayTexture || ke.isCompressedArrayTexture) && (ve = !0);
                const We = Ue.get(w).__webglFramebuffer;
                w.isWebGLCubeRenderTarget ? (Array.isArray(We[z]) ? F = We[z][j] : F = We[z],
                le = !0) : w.samples > 0 && ge.useMultisampledRTT(w) === !1 ? F = Ue.get(w).__webglMultisampledFramebuffer : Array.isArray(We) ? F = We[j] : F = We,
                P.copy(w.viewport),
                U.copy(w.scissor),
                O = w.scissorTest
            } else
                P.copy(re).multiplyScalar(N).floor(),
                U.copy(ue).multiplyScalar(N).floor(),
                O = we;
            if (j !== 0 && (F = di),
            Ee.bindFramebuffer(I.FRAMEBUFFER, F) && W && Ee.drawBuffers(w, F),
            Ee.viewport(P),
            Ee.scissor(U),
            Ee.setScissorTest(O),
            le) {
                const Re = Ue.get(w.texture);
                I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_CUBE_MAP_POSITIVE_X + z, Re.__webglTexture, j)
            } else if (ve) {
                const Re = Ue.get(w.texture)
                  , ke = z;
                I.framebufferTextureLayer(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, Re.__webglTexture, j, ke)
            } else if (w !== null && j !== 0) {
                const Re = Ue.get(w.texture);
                I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_2D, Re.__webglTexture, j)
            }
            y = -1
        }
        ,
        this.readRenderTargetPixels = function(w, z, j, W, F, le, ve, Ie=0) {
            if (!(w && w.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Re = Ue.get(w).__webglFramebuffer;
            if (w.isWebGLCubeRenderTarget && ve !== void 0 && (Re = Re[ve]),
            Re) {
                Ee.bindFramebuffer(I.FRAMEBUFFER, Re);
                try {
                    const ke = w.textures[Ie]
                      , We = ke.format
                      , Be = ke.type;
                    if (!G.textureFormatReadable(We)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!G.textureTypeReadable(Be)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    z >= 0 && z <= w.width - W && j >= 0 && j <= w.height - F && (w.textures.length > 1 && I.readBuffer(I.COLOR_ATTACHMENT0 + Ie),
                    I.readPixels(z, j, W, F, ce.convert(We), ce.convert(Be), le))
                } finally {
                    const ke = R !== null ? Ue.get(R).__webglFramebuffer : null;
                    Ee.bindFramebuffer(I.FRAMEBUFFER, ke)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(w, z, j, W, F, le, ve, Ie=0) {
            if (!(w && w.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Re = Ue.get(w).__webglFramebuffer;
            if (w.isWebGLCubeRenderTarget && ve !== void 0 && (Re = Re[ve]),
            Re)
                if (z >= 0 && z <= w.width - W && j >= 0 && j <= w.height - F) {
                    Ee.bindFramebuffer(I.FRAMEBUFFER, Re);
                    const ke = w.textures[Ie]
                      , We = ke.format
                      , Be = ke.type;
                    if (!G.textureFormatReadable(We))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!G.textureTypeReadable(Be))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const Ze = I.createBuffer();
                    I.bindBuffer(I.PIXEL_PACK_BUFFER, Ze),
                    I.bufferData(I.PIXEL_PACK_BUFFER, le.byteLength, I.STREAM_READ),
                    w.textures.length > 1 && I.readBuffer(I.COLOR_ATTACHMENT0 + Ie),
                    I.readPixels(z, j, W, F, ce.convert(We), ce.convert(Be), 0);
                    const Et = R !== null ? Ue.get(R).__webglFramebuffer : null;
                    Ee.bindFramebuffer(I.FRAMEBUFFER, Et);
                    const Nt = I.fenceSync(I.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return I.flush(),
                    await Ey(I, Nt, 4),
                    I.bindBuffer(I.PIXEL_PACK_BUFFER, Ze),
                    I.getBufferSubData(I.PIXEL_PACK_BUFFER, 0, le),
                    I.deleteBuffer(Ze),
                    I.deleteSync(Nt),
                    le
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(w, z=null, j=0) {
            const W = Math.pow(2, -j)
              , F = Math.floor(w.image.width * W)
              , le = Math.floor(w.image.height * W)
              , ve = z !== null ? z.x : 0
              , Ie = z !== null ? z.y : 0;
            ge.setTexture2D(w, 0),
            I.copyTexSubImage2D(I.TEXTURE_2D, j, 0, 0, ve, Ie, F, le),
            Ee.unbindTexture()
        }
        ;
        const Zt = I.createFramebuffer()
          , Jt = I.createFramebuffer();
        this.copyTextureToTexture = function(w, z, j=null, W=null, F=0, le=null) {
            le === null && (F !== 0 ? (go("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            le = F,
            F = 0) : le = 0);
            let ve, Ie, Re, ke, We, Be, Ze, Et, Nt;
            const zt = w.isCompressedTexture ? w.mipmaps[le] : w.image;
            if (j !== null)
                ve = j.max.x - j.min.x,
                Ie = j.max.y - j.min.y,
                Re = j.isBox3 ? j.max.z - j.min.z : 1,
                ke = j.min.x,
                We = j.min.y,
                Be = j.isBox3 ? j.min.z : 0;
            else {
                const mi = Math.pow(2, -F);
                ve = Math.floor(zt.width * mi),
                Ie = Math.floor(zt.height * mi),
                w.isDataArrayTexture ? Re = zt.depth : w.isData3DTexture ? Re = Math.floor(zt.depth * mi) : Re = 1,
                ke = 0,
                We = 0,
                Be = 0
            }
            W !== null ? (Ze = W.x,
            Et = W.y,
            Nt = W.z) : (Ze = 0,
            Et = 0,
            Nt = 0);
            const dt = ce.convert(z.format)
              , Xe = ce.convert(z.type);
            let fn;
            z.isData3DTexture ? (ge.setTexture3D(z, 0),
            fn = I.TEXTURE_3D) : z.isDataArrayTexture || z.isCompressedArrayTexture ? (ge.setTexture2DArray(z, 0),
            fn = I.TEXTURE_2D_ARRAY) : (ge.setTexture2D(z, 0),
            fn = I.TEXTURE_2D),
            I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, z.flipY),
            I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
            I.pixelStorei(I.UNPACK_ALIGNMENT, z.unpackAlignment);
            const xt = I.getParameter(I.UNPACK_ROW_LENGTH)
              , Ri = I.getParameter(I.UNPACK_IMAGE_HEIGHT)
              , Is = I.getParameter(I.UNPACK_SKIP_PIXELS)
              , Zn = I.getParameter(I.UNPACK_SKIP_ROWS)
              , Uo = I.getParameter(I.UNPACK_SKIP_IMAGES);
            I.pixelStorei(I.UNPACK_ROW_LENGTH, zt.width),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, zt.height),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, ke),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, We),
            I.pixelStorei(I.UNPACK_SKIP_IMAGES, Be);
            const Lt = w.isDataArrayTexture || w.isData3DTexture
              , pi = z.isDataArrayTexture || z.isData3DTexture;
            if (w.isDepthTexture) {
                const mi = Ue.get(w)
                  , wn = Ue.get(z)
                  , On = Ue.get(mi.__renderTarget)
                  , dc = Ue.get(wn.__renderTarget);
                Ee.bindFramebuffer(I.READ_FRAMEBUFFER, On.__webglFramebuffer),
                Ee.bindFramebuffer(I.DRAW_FRAMEBUFFER, dc.__webglFramebuffer);
                for (let Kr = 0; Kr < Re; Kr++)
                    Lt && (I.framebufferTextureLayer(I.READ_FRAMEBUFFER, I.COLOR_ATTACHMENT0, Ue.get(w).__webglTexture, F, Be + Kr),
                    I.framebufferTextureLayer(I.DRAW_FRAMEBUFFER, I.COLOR_ATTACHMENT0, Ue.get(z).__webglTexture, le, Nt + Kr)),
                    I.blitFramebuffer(ke, We, ve, Ie, Ze, Et, ve, Ie, I.DEPTH_BUFFER_BIT, I.NEAREST);
                Ee.bindFramebuffer(I.READ_FRAMEBUFFER, null),
                Ee.bindFramebuffer(I.DRAW_FRAMEBUFFER, null)
            } else if (F !== 0 || w.isRenderTargetTexture || Ue.has(w)) {
                const mi = Ue.get(w)
                  , wn = Ue.get(z);
                Ee.bindFramebuffer(I.READ_FRAMEBUFFER, Zt),
                Ee.bindFramebuffer(I.DRAW_FRAMEBUFFER, Jt);
                for (let On = 0; On < Re; On++)
                    Lt ? I.framebufferTextureLayer(I.READ_FRAMEBUFFER, I.COLOR_ATTACHMENT0, mi.__webglTexture, F, Be + On) : I.framebufferTexture2D(I.READ_FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_2D, mi.__webglTexture, F),
                    pi ? I.framebufferTextureLayer(I.DRAW_FRAMEBUFFER, I.COLOR_ATTACHMENT0, wn.__webglTexture, le, Nt + On) : I.framebufferTexture2D(I.DRAW_FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_2D, wn.__webglTexture, le),
                    F !== 0 ? I.blitFramebuffer(ke, We, ve, Ie, Ze, Et, ve, Ie, I.COLOR_BUFFER_BIT, I.NEAREST) : pi ? I.copyTexSubImage3D(fn, le, Ze, Et, Nt + On, ke, We, ve, Ie) : I.copyTexSubImage2D(fn, le, Ze, Et, ke, We, ve, Ie);
                Ee.bindFramebuffer(I.READ_FRAMEBUFFER, null),
                Ee.bindFramebuffer(I.DRAW_FRAMEBUFFER, null)
            } else
                pi ? w.isDataTexture || w.isData3DTexture ? I.texSubImage3D(fn, le, Ze, Et, Nt, ve, Ie, Re, dt, Xe, zt.data) : z.isCompressedArrayTexture ? I.compressedTexSubImage3D(fn, le, Ze, Et, Nt, ve, Ie, Re, dt, zt.data) : I.texSubImage3D(fn, le, Ze, Et, Nt, ve, Ie, Re, dt, Xe, zt) : w.isDataTexture ? I.texSubImage2D(I.TEXTURE_2D, le, Ze, Et, ve, Ie, dt, Xe, zt.data) : w.isCompressedTexture ? I.compressedTexSubImage2D(I.TEXTURE_2D, le, Ze, Et, zt.width, zt.height, dt, zt.data) : I.texSubImage2D(I.TEXTURE_2D, le, Ze, Et, ve, Ie, dt, Xe, zt);
            I.pixelStorei(I.UNPACK_ROW_LENGTH, xt),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Ri),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, Is),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, Zn),
            I.pixelStorei(I.UNPACK_SKIP_IMAGES, Uo),
            le === 0 && z.generateMipmaps && I.generateMipmap(fn),
            Ee.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(w, z, j=null, W=null, F=0) {
            return go('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
            this.copyTextureToTexture(w, z, j, W, F)
        }
        ,
        this.initRenderTarget = function(w) {
            Ue.get(w).__webglFramebuffer === void 0 && ge.setupRenderTarget(w)
        }
        ,
        this.initTexture = function(w) {
            w.isCubeTexture ? ge.setTextureCube(w, 0) : w.isData3DTexture ? ge.setTexture3D(w, 0) : w.isDataArrayTexture || w.isCompressedArrayTexture ? ge.setTexture2DArray(w, 0) : ge.setTexture2D(w, 0),
            Ee.unbindTexture()
        }
        ,
        this.resetState = function() {
            A = 0,
            T = 0,
            R = null,
            Ee.reset(),
            Ne.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return fr
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = pt._getDrawingBufferColorSpace(e),
        t.unpackColorSpace = pt._getUnpackColorSpace()
    }
}
/**
 * postprocessing v6.38.2 build Mon Dec 22 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rschen
 * @license Zlib
 */
var fu = 1 / 1e3
  , Vb = 1e3
  , Gb = class {
    constructor() {
        this.startTime = performance.now(),
        this.previousTime = 0,
        this.currentTime = 0,
        this._delta = 0,
        this._elapsed = 0,
        this._fixedDelta = 1e3 / 60,
        this.timescale = 1,
        this.useFixedDelta = !1,
        this._autoReset = !1
    }
    get autoReset() {
        return this._autoReset
    }
    set autoReset(i) {
        typeof document < "u" && document.hidden !== void 0 && (i ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
        this._autoReset = i)
    }
    get delta() {
        return this._delta * fu
    }
    get fixedDelta() {
        return this._fixedDelta * fu
    }
    set fixedDelta(i) {
        this._fixedDelta = i * Vb
    }
    get elapsed() {
        return this._elapsed * fu
    }
    update(i) {
        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
        this.currentTime = (i !== void 0 ? i : performance.now()) - this.startTime,
        this._delta = this.currentTime - this.previousTime),
        this._delta *= this.timescale,
        this._elapsed += this._delta
    }
    reset() {
        this._delta = 0,
        this._elapsed = 0,
        this.currentTime = performance.now() - this.startTime
    }
    getDelta() {
        return this.delta
    }
    getElapsed() {
        return this.elapsed
    }
    handleEvent(i) {
        document.hidden || (this.currentTime = performance.now() - this.startTime)
    }
    dispose() {
        this.autoReset = !1
    }
}
  , Wb = ( () => {
    const i = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
      , e = new Float32Array([0, 0, 2, 0, 0, 2])
      , t = new $r;
    return t.setAttribute("position", new Ai(i,3)),
    t.setAttribute("uv", new Ai(e,2)),
    t
}
)()
  , jr = class Nf {
    static get fullscreenGeometry() {
        return Wb
    }
    constructor(e="Pass", t=new If, n=new Th) {
        this.name = e,
        this.renderer = null,
        this.scene = t,
        this.camera = n,
        this.screen = null,
        this.rtt = !0,
        this.needsSwap = !0,
        this.needsDepthTexture = !1,
        this.enabled = !0
    }
    get renderToScreen() {
        return !this.rtt
    }
    set renderToScreen(e) {
        if (this.rtt === e) {
            const t = this.fullscreenMaterial;
            t !== null && (t.needsUpdate = !0),
            this.rtt = !e
        }
    }
    set mainScene(e) {}
    set mainCamera(e) {}
    setRenderer(e) {
        this.renderer = e
    }
    isEnabled() {
        return this.enabled
    }
    setEnabled(e) {
        this.enabled = e
    }
    get fullscreenMaterial() {
        return this.screen !== null ? this.screen.material : null
    }
    set fullscreenMaterial(e) {
        let t = this.screen;
        t !== null ? t.material = e : (t = new Wn(Nf.fullscreenGeometry,e),
        t.frustumCulled = !1,
        this.scene === null && (this.scene = new If),
        this.scene.add(t),
        this.screen = t)
    }
    getFullscreenMaterial() {
        return this.fullscreenMaterial
    }
    setFullscreenMaterial(e) {
        this.fullscreenMaterial = e
    }
    getDepthTexture() {
        return null
    }
    setDepthTexture(e, t=Ua) {}
    render(e, t, n, r, s) {
        throw new Error("Render method not implemented!")
    }
    setSize(e, t) {}
    initialize(e, t, n) {}
    dispose() {
        for (const e of Object.keys(this)) {
            const t = this[e];
            (t instanceof Bi || t instanceof Lo || t instanceof cn || t instanceof Nf) && this[e].dispose()
        }
        this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose()
    }
}
  , Xb = class extends jr {
    constructor() {
        super("ClearMaskPass", null, null),
        this.needsSwap = !1
    }
    render(i, e, t, n, r) {
        const s = i.state.buffers.stencil;
        s.setLocked(!1),
        s.setTest(!1)
    }
}
  , qb = "#ifdef COLOR_WRITE\n#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#endif\n#ifdef DEPTH_WRITE\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\n#ifdef USE_WEIGHTS\nuniform vec4 channelWeights;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){\n#ifdef COLOR_WRITE\nvec4 texel=texture2D(inputBuffer,vUv);\n#ifdef USE_WEIGHTS\ntexel*=channelWeights;\n#endif\ngl_FragColor=opacity*texel;\n#ifdef COLOR_SPACE_CONVERSION\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n#else\ngl_FragColor=vec4(0.0);\n#endif\n#ifdef DEPTH_WRITE\ngl_FragDepth=readDepth(vUv);\n#endif\n}"
  , Yb = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
  , $b = class extends zi {
    constructor() {
        super({
            name: "CopyMaterial",
            defines: {
                COLOR_SPACE_CONVERSION: "1",
                DEPTH_PACKING: "0",
                COLOR_WRITE: "1"
            },
            uniforms: {
                inputBuffer: new dn(null),
                depthBuffer: new dn(null),
                channelWeights: new dn(null),
                opacity: new dn(1)
            },
            blending: Zi,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: qb,
            vertexShader: Yb
        }),
        this.depthFunc = Ql
    }
    get inputBuffer() {
        return this.uniforms.inputBuffer.value
    }
    set inputBuffer(i) {
        const e = i !== null;
        this.colorWrite !== e && (e ? this.defines.COLOR_WRITE = !0 : delete this.defines.COLOR_WRITE,
        this.colorWrite = e,
        this.needsUpdate = !0),
        this.uniforms.inputBuffer.value = i
    }
    get depthBuffer() {
        return this.uniforms.depthBuffer.value
    }
    set depthBuffer(i) {
        const e = i !== null;
        this.depthWrite !== e && (e ? this.defines.DEPTH_WRITE = !0 : delete this.defines.DEPTH_WRITE,
        this.depthTest = e,
        this.depthWrite = e,
        this.needsUpdate = !0),
        this.uniforms.depthBuffer.value = i
    }
    set depthPacking(i) {
        this.defines.DEPTH_PACKING = i.toFixed(0),
        this.needsUpdate = !0
    }
    get colorSpaceConversion() {
        return this.defines.COLOR_SPACE_CONVERSION !== void 0
    }
    set colorSpaceConversion(i) {
        this.colorSpaceConversion !== i && (i ? this.defines.COLOR_SPACE_CONVERSION = !0 : delete this.defines.COLOR_SPACE_CONVERSION,
        this.needsUpdate = !0)
    }
    get channelWeights() {
        return this.uniforms.channelWeights.value
    }
    set channelWeights(i) {
        i !== null ? (this.defines.USE_WEIGHTS = "1",
        this.uniforms.channelWeights.value = i) : delete this.defines.USE_WEIGHTS,
        this.needsUpdate = !0
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i
    }
    getOpacity(i) {
        return this.uniforms.opacity.value
    }
    setOpacity(i) {
        this.uniforms.opacity.value = i
    }
}
  , jb = class extends jr {
    constructor(i, e=!0) {
        super("CopyPass"),
        this.fullscreenMaterial = new $b,
        this.needsSwap = !1,
        this.renderTarget = i,
        i === void 0 && (this.renderTarget = new Bi(1,1,{
            minFilter: ln,
            magFilter: ln,
            stencilBuffer: !1,
            depthBuffer: !1
        }),
        this.renderTarget.texture.name = "CopyPass.Target"),
        this.autoResize = e
    }
    get resize() {
        return this.autoResize
    }
    set resize(i) {
        this.autoResize = i
    }
    get texture() {
        return this.renderTarget.texture
    }
    getTexture() {
        return this.renderTarget.texture
    }
    setAutoResizeEnabled(i) {
        this.autoResize = i
    }
    render(i, e, t, n, r) {
        this.fullscreenMaterial.inputBuffer = e.texture,
        i.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        i.render(this.scene, this.camera)
    }
    setSize(i, e) {
        this.autoResize && this.renderTarget.setSize(i, e)
    }
    initialize(i, e, t) {
        t !== void 0 && (this.renderTarget.texture.type = t,
        t !== hi ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : i !== null && i.outputColorSpace === kt && (this.renderTarget.texture.colorSpace = kt))
    }
}
  , Ep = new St
  , kg = class extends jr {
    constructor(i=!0, e=!0, t=!1) {
        super("ClearPass", null, null),
        this.needsSwap = !1,
        this.color = i,
        this.depth = e,
        this.stencil = t,
        this.overrideClearColor = null,
        this.overrideClearAlpha = -1
    }
    setClearFlags(i, e, t) {
        this.color = i,
        this.depth = e,
        this.stencil = t
    }
    getOverrideClearColor() {
        return this.overrideClearColor
    }
    setOverrideClearColor(i) {
        this.overrideClearColor = i
    }
    getOverrideClearAlpha() {
        return this.overrideClearAlpha
    }
    setOverrideClearAlpha(i) {
        this.overrideClearAlpha = i
    }
    render(i, e, t, n, r) {
        const s = this.overrideClearColor
          , o = this.overrideClearAlpha
          , a = i.getClearAlpha()
          , l = s !== null
          , c = o >= 0;
        l ? (i.getClearColor(Ep),
        i.setClearColor(s, c ? o : a)) : c && i.setClearAlpha(o),
        i.setRenderTarget(this.renderToScreen ? null : e),
        i.clear(this.color, this.depth, this.stencil),
        l ? i.setClearColor(Ep, a) : c && i.setClearAlpha(a)
    }
}
  , Kb = class extends jr {
    constructor(i, e) {
        super("MaskPass", i, e),
        this.needsSwap = !1,
        this.clearPass = new kg(!1,!1,!0),
        this.inverse = !1
    }
    set mainScene(i) {
        this.scene = i
    }
    set mainCamera(i) {
        this.camera = i
    }
    get inverted() {
        return this.inverse
    }
    set inverted(i) {
        this.inverse = i
    }
    get clear() {
        return this.clearPass.enabled
    }
    set clear(i) {
        this.clearPass.enabled = i
    }
    getClearPass() {
        return this.clearPass
    }
    isInverted() {
        return this.inverted
    }
    setInverted(i) {
        this.inverted = i
    }
    render(i, e, t, n, r) {
        const s = i.getContext()
          , o = i.state.buffers
          , a = this.scene
          , l = this.camera
          , c = this.clearPass
          , u = this.inverted ? 0 : 1
          , f = 1 - u;
        o.color.setMask(!1),
        o.depth.setMask(!1),
        o.color.setLocked(!0),
        o.depth.setLocked(!0),
        o.stencil.setTest(!0),
        o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
        o.stencil.setFunc(s.ALWAYS, u, 4294967295),
        o.stencil.setClear(f),
        o.stencil.setLocked(!0),
        this.clearPass.enabled && (this.renderToScreen ? c.render(i, null) : (c.render(i, e),
        c.render(i, t))),
        this.renderToScreen ? (i.setRenderTarget(null),
        i.render(a, l)) : (i.setRenderTarget(e),
        i.render(a, l),
        i.setRenderTarget(t),
        i.render(a, l)),
        o.color.setLocked(!1),
        o.depth.setLocked(!1),
        o.stencil.setLocked(!1),
        o.stencil.setFunc(s.EQUAL, 1, 4294967295),
        o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
        o.stencil.setLocked(!0)
    }
}
  , Zb = class {
    constructor(i=null, {depthBuffer: e=!0, stencilBuffer: t=!1, multisampling: n=0, frameBufferType: r}={}) {
        this.renderer = null,
        this.inputBuffer = this.createBuffer(e, t, r, n),
        this.outputBuffer = this.inputBuffer.clone(),
        this.copyPass = new jb,
        this.depthTexture = null,
        this.passes = [],
        this.timer = new Gb,
        this.autoRenderToScreen = !0,
        this.setRenderer(i)
    }
    get multisampling() {
        return this.inputBuffer.samples || 0
    }
    set multisampling(i) {
        const e = this.inputBuffer
          , t = this.multisampling;
        t > 0 && i > 0 ? (this.inputBuffer.samples = i,
        this.outputBuffer.samples = i,
        this.inputBuffer.dispose(),
        this.outputBuffer.dispose()) : t !== i && (this.inputBuffer.dispose(),
        this.outputBuffer.dispose(),
        this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, i),
        this.inputBuffer.depthTexture = this.depthTexture,
        this.outputBuffer = this.inputBuffer.clone())
    }
    getTimer() {
        return this.timer
    }
    getRenderer() {
        return this.renderer
    }
    setRenderer(i) {
        if (this.renderer = i,
        i !== null) {
            const e = i.getSize(new lt)
              , t = i.getContext().getContextAttributes().alpha
              , n = this.inputBuffer.texture.type;
            n === hi && i.outputColorSpace === kt && (this.inputBuffer.texture.colorSpace = kt,
            this.outputBuffer.texture.colorSpace = kt,
            this.inputBuffer.dispose(),
            this.outputBuffer.dispose()),
            i.autoClear = !1,
            this.setSize(e.width, e.height);
            for (const r of this.passes)
                r.initialize(i, t, n)
        }
    }
    replaceRenderer(i, e=!0) {
        const t = this.renderer
          , n = t.domElement.parentNode;
        return this.setRenderer(i),
        e && n !== null && (n.removeChild(t.domElement),
        n.appendChild(i.domElement)),
        t
    }
    createDepthTexture() {
        const i = this.depthTexture = new Eh;
        return this.inputBuffer.depthTexture = i,
        this.inputBuffer.dispose(),
        this.inputBuffer.stencilBuffer ? (i.format = Co,
        i.type = Ro) : i.type = Gr,
        i
    }
    deleteDepthTexture() {
        if (this.depthTexture !== null) {
            this.depthTexture.dispose(),
            this.depthTexture = null,
            this.inputBuffer.depthTexture = null,
            this.inputBuffer.dispose();
            for (const i of this.passes)
                i.setDepthTexture(null)
        }
    }
    createBuffer(i, e, t, n) {
        const r = this.renderer
          , s = r === null ? new lt : r.getDrawingBufferSize(new lt)
          , o = {
            minFilter: ln,
            magFilter: ln,
            stencilBuffer: e,
            depthBuffer: i,
            type: t
        }
          , a = new Bi(s.width,s.height,o);
        return n > 0 && (a.samples = n),
        t === hi && r !== null && r.outputColorSpace === kt && (a.texture.colorSpace = kt),
        a.texture.name = "EffectComposer.Buffer",
        a.texture.generateMipmaps = !1,
        a
    }
    setMainScene(i) {
        for (const e of this.passes)
            e.mainScene = i
    }
    setMainCamera(i) {
        for (const e of this.passes)
            e.mainCamera = i
    }
    addPass(i, e) {
        const t = this.passes
          , n = this.renderer
          , r = n.getDrawingBufferSize(new lt)
          , s = n.getContext().getContextAttributes().alpha
          , o = this.inputBuffer.texture.type;
        if (i.setRenderer(n),
        i.setSize(r.width, r.height),
        i.initialize(n, s, o),
        this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1),
        i.renderToScreen && (this.autoRenderToScreen = !1)),
        e !== void 0 ? t.splice(e, 0, i) : t.push(i),
        this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0),
        i.needsDepthTexture || this.depthTexture !== null)
            if (this.depthTexture === null) {
                const a = this.createDepthTexture();
                for (i of t)
                    i.setDepthTexture(a)
            } else
                i.setDepthTexture(this.depthTexture)
    }
    removePass(i) {
        const e = this.passes
          , t = e.indexOf(i);
        if (t !== -1 && e.splice(t, 1).length > 0) {
            if (this.depthTexture !== null) {
                const s = (a, l) => a || l.needsDepthTexture;
                e.reduce(s, !1) || (i.getDepthTexture() === this.depthTexture && i.setDepthTexture(null),
                this.deleteDepthTexture())
            }
            this.autoRenderToScreen && t === e.length && (i.renderToScreen = !1,
            e.length > 0 && (e[e.length - 1].renderToScreen = !0))
        }
    }
    removeAllPasses() {
        const i = this.passes;
        this.deleteDepthTexture(),
        i.length > 0 && (this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !1),
        this.passes = [])
    }
    render(i) {
        const e = this.renderer
          , t = this.copyPass;
        let n = this.inputBuffer, r = this.outputBuffer, s = !1, o, a, l;
        i === void 0 && (this.timer.update(),
        i = this.timer.getDelta());
        for (const c of this.passes)
            c.enabled && (c.render(e, n, r, i, s),
            c.needsSwap && (s && (t.renderToScreen = c.renderToScreen,
            o = e.getContext(),
            a = e.state.buffers.stencil,
            a.setFunc(o.NOTEQUAL, 1, 4294967295),
            t.render(e, n, r, i, s),
            a.setFunc(o.EQUAL, 1, 4294967295)),
            l = n,
            n = r,
            r = l),
            c instanceof Kb ? s = !0 : c instanceof Xb && (s = !1))
    }
    setSize(i, e, t) {
        const n = this.renderer
          , r = n.getSize(new lt);
        (i === void 0 || e === void 0) && (i = r.width,
        e = r.height),
        (r.width !== i || r.height !== e) && n.setSize(i, e, t);
        const s = n.getDrawingBufferSize(new lt);
        this.inputBuffer.setSize(s.width, s.height),
        this.outputBuffer.setSize(s.width, s.height);
        for (const o of this.passes)
            o.setSize(s.width, s.height)
    }
    reset() {
        this.dispose(),
        this.autoRenderToScreen = !0
    }
    dispose() {
        for (const i of this.passes)
            i.dispose();
        this.passes = [],
        this.inputBuffer !== null && this.inputBuffer.dispose(),
        this.outputBuffer !== null && this.outputBuffer.dispose(),
        this.deleteDepthTexture(),
        this.copyPass.dispose(),
        this.timer.dispose(),
        jr.fullscreenGeometry.dispose()
    }
}
  , Rs = {
    NONE: 0,
    DEPTH: 1,
    CONVOLUTION: 2
}
  , mt = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}
  , Jb = class {
    constructor() {
        this.shaderParts = new Map([[mt.FRAGMENT_HEAD, null], [mt.FRAGMENT_MAIN_UV, null], [mt.FRAGMENT_MAIN_IMAGE, null], [mt.VERTEX_HEAD, null], [mt.VERTEX_MAIN_SUPPORT, null]]),
        this.defines = new Map,
        this.uniforms = new Map,
        this.blendModes = new Map,
        this.extensions = new Set,
        this.attributes = Rs.NONE,
        this.varyings = new Set,
        this.uvTransformation = !1,
        this.readDepth = !1,
        this.colorSpace = Wr
    }
}
  , hu = !1
  , Mp = class {
    constructor(i=null) {
        this.originalMaterials = new Map,
        this.material = null,
        this.materials = null,
        this.materialsBackSide = null,
        this.materialsDoubleSide = null,
        this.materialsFlatShaded = null,
        this.materialsFlatShadedBackSide = null,
        this.materialsFlatShadedDoubleSide = null,
        this.setMaterial(i),
        this.meshCount = 0,
        this.replaceMaterial = e => {
            if (e.isMesh) {
                let t;
                if (e.material.flatShading)
                    switch (e.material.side) {
                    case pn:
                        t = this.materialsFlatShadedDoubleSide;
                        break;
                    case an:
                        t = this.materialsFlatShadedBackSide;
                        break;
                    default:
                        t = this.materialsFlatShaded;
                        break
                    }
                else
                    switch (e.material.side) {
                    case pn:
                        t = this.materialsDoubleSide;
                        break;
                    case an:
                        t = this.materialsBackSide;
                        break;
                    default:
                        t = this.materials;
                        break
                    }
                this.originalMaterials.set(e, e.material),
                e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0],
                ++this.meshCount
            }
        }
    }
    cloneMaterial(i) {
        if (!(i instanceof zi))
            return i.clone();
        const e = i.uniforms
          , t = new Map;
        for (const r in e) {
            const s = e[r].value;
            s.isRenderTargetTexture && (e[r].value = null,
            t.set(r, s))
        }
        const n = i.clone();
        for (const r of t)
            e[r[0]].value = r[1],
            n.uniforms[r[0]].value = r[1];
        return n
    }
    setMaterial(i) {
        if (this.disposeMaterials(),
        this.material = i,
        i !== null) {
            const e = this.materials = [this.cloneMaterial(i), this.cloneMaterial(i), this.cloneMaterial(i)];
            for (const t of e)
                t.uniforms = Object.assign({}, i.uniforms),
                t.side = _r;
            e[2].skinning = !0,
            this.materialsBackSide = e.map(t => {
                const n = this.cloneMaterial(t);
                return n.uniforms = Object.assign({}, i.uniforms),
                n.side = an,
                n
            }
            ),
            this.materialsDoubleSide = e.map(t => {
                const n = this.cloneMaterial(t);
                return n.uniforms = Object.assign({}, i.uniforms),
                n.side = pn,
                n
            }
            ),
            this.materialsFlatShaded = e.map(t => {
                const n = this.cloneMaterial(t);
                return n.uniforms = Object.assign({}, i.uniforms),
                n.flatShading = !0,
                n
            }
            ),
            this.materialsFlatShadedBackSide = e.map(t => {
                const n = this.cloneMaterial(t);
                return n.uniforms = Object.assign({}, i.uniforms),
                n.flatShading = !0,
                n.side = an,
                n
            }
            ),
            this.materialsFlatShadedDoubleSide = e.map(t => {
                const n = this.cloneMaterial(t);
                return n.uniforms = Object.assign({}, i.uniforms),
                n.flatShading = !0,
                n.side = pn,
                n
            }
            )
        }
    }
    render(i, e, t) {
        const n = i.shadowMap.enabled;
        if (i.shadowMap.enabled = !1,
        hu) {
            const r = this.originalMaterials;
            this.meshCount = 0,
            e.traverse(this.replaceMaterial),
            i.render(e, t);
            for (const s of r)
                s[0].material = s[1];
            this.meshCount !== r.size && r.clear()
        } else {
            const r = e.overrideMaterial;
            e.overrideMaterial = this.material,
            i.render(e, t),
            e.overrideMaterial = r
        }
        i.shadowMap.enabled = n
    }
    disposeMaterials() {
        if (this.material !== null) {
            const i = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
            for (const e of i)
                e.dispose()
        }
    }
    dispose() {
        this.originalMaterials.clear(),
        this.disposeMaterials()
    }
    static get workaroundEnabled() {
        return hu
    }
    static set workaroundEnabled(i) {
        hu = i
    }
}
  , ct = {
    ADD: 0,
    ALPHA: 1,
    AVERAGE: 2,
    COLOR: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    DIVIDE: 8,
    DST: 9,
    EXCLUSION: 10,
    HARD_LIGHT: 11,
    HARD_MIX: 12,
    HUE: 13,
    INVERT: 14,
    INVERT_RGB: 15,
    LIGHTEN: 16,
    LINEAR_BURN: 17,
    LINEAR_DODGE: 18,
    LINEAR_LIGHT: 19,
    LUMINOSITY: 20,
    MULTIPLY: 21,
    NEGATION: 22,
    NORMAL: 23,
    OVERLAY: 24,
    PIN_LIGHT: 25,
    REFLECT: 26,
    SATURATION: 27,
    SCREEN: 28,
    SOFT_LIGHT: 29,
    SRC: 30,
    SUBTRACT: 31,
    VIVID_LIGHT: 32
}
  , Qb = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , ew = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return mix(dst,src,src.a*opacity);}"
  , tw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=(dst.rgb+src.rgb)*0.5;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , nw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(b.xy,a.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , iw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=dst.rgb,b=src.rgb;vec3 c=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/max(b,1e-9))),vec3(1.0),step(1.0,a));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , rw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=dst.rgb,b=src.rgb;vec3 c=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , sw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=min(dst.rgb,src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , ow = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=abs(dst.rgb-src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , aw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb/max(src.rgb,1e-9);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , lw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb-2.0*dst.rgb*src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , cw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=min(dst.rgb,1.0);vec3 b=min(src.rgb,1.0);vec3 c=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , uw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=step(1.0,dst.rgb+src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , fw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(b.x,a.yz));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , hw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(1.0-src.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , dw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=src.rgb*max(1.0-dst.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , pw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(dst.rgb,src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , mw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=clamp(src.rgb+dst.rgb-1.0,0.0,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , gw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=min(dst.rgb+src.rgb,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , _w = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=clamp(2.0*src.rgb+dst.rgb-1.0,0.0,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , vw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(a.xy,b.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , xw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb*src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , yw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(1.0-abs(1.0-dst.rgb-src.rgb),0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Sw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return mix(dst,src,opacity);}"
  , Ew = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=2.0*src.rgb*dst.rgb;vec3 b=1.0-2.0*(1.0-src.rgb)*(1.0-dst.rgb);vec3 c=mix(a,b,step(0.5,dst.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Mw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 src2=2.0*src.rgb;vec3 c=mix(mix(src2,dst.rgb,step(0.5*dst.rgb,src.rgb)),max(src2-1.0,vec3(0.0)),step(dst.rgb,src2-1.0));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Tw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=min(dst.rgb*dst.rgb/max(1.0-src.rgb,1e-9),1.0);vec3 c=mix(a,src.rgb,step(1.0,src.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , bw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(a.x,b.y,a.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , ww = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb-min(dst.rgb*src.rgb,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Aw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 src2=2.0*src.rgb;vec3 d=dst.rgb+(src2-1.0);vec3 w=step(0.5,src.rgb);vec3 a=dst.rgb-(1.0-src2)*dst.rgb*(1.0-dst.rgb);vec3 b=mix(d*(sqrt(dst.rgb)-dst.rgb),d*dst.rgb*((16.0*dst.rgb-12.0)*dst.rgb+3.0),w*(1.0-step(0.25,dst.rgb)));vec3 c=mix(a,b,w);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Rw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return src;}"
  , Cw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(dst.rgb-src.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Pw = "vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=mix(max(1.0-min((1.0-dst.rgb)/(2.0*src.rgb),1.0),0.0),min(dst.rgb/(2.0*(1.0-src.rgb)),1.0),step(0.5,src.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}"
  , Dw = new Map([[ct.ADD, Qb], [ct.ALPHA, ew], [ct.AVERAGE, tw], [ct.COLOR, nw], [ct.COLOR_BURN, iw], [ct.COLOR_DODGE, rw], [ct.DARKEN, sw], [ct.DIFFERENCE, ow], [ct.DIVIDE, aw], [ct.DST, null], [ct.EXCLUSION, lw], [ct.HARD_LIGHT, cw], [ct.HARD_MIX, uw], [ct.HUE, fw], [ct.INVERT, hw], [ct.INVERT_RGB, dw], [ct.LIGHTEN, pw], [ct.LINEAR_BURN, mw], [ct.LINEAR_DODGE, gw], [ct.LINEAR_LIGHT, _w], [ct.LUMINOSITY, vw], [ct.MULTIPLY, xw], [ct.NEGATION, yw], [ct.NORMAL, Sw], [ct.OVERLAY, Ew], [ct.PIN_LIGHT, Mw], [ct.REFLECT, Tw], [ct.SATURATION, bw], [ct.SCREEN, ww], [ct.SOFT_LIGHT, Aw], [ct.SRC, Rw], [ct.SUBTRACT, Cw], [ct.VIVID_LIGHT, Pw]])
  , Lw = class extends Yr {
    constructor(i, e=1) {
        super(),
        this._blendFunction = i,
        this.opacity = new dn(e)
    }
    getOpacity() {
        return this.opacity.value
    }
    setOpacity(i) {
        this.opacity.value = i
    }
    get blendFunction() {
        return this._blendFunction
    }
    set blendFunction(i) {
        this._blendFunction = i,
        this.dispatchEvent({
            type: "change"
        })
    }
    getBlendFunction() {
        return this.blendFunction
    }
    setBlendFunction(i) {
        this.blendFunction = i
    }
    getShaderCode() {
        return Dw.get(this.blendFunction)
    }
}
  , Iw = class extends Yr {
    constructor(i, e, {attributes: t=Rs.NONE, blendFunction: n=ct.NORMAL, defines: r=new Map, uniforms: s=new Map, extensions: o=null, vertexShader: a=null}={}) {
        super(),
        this.name = i,
        this.renderer = null,
        this.attributes = t,
        this.fragmentShader = e,
        this.vertexShader = a,
        this.defines = r,
        this.uniforms = s,
        this.extensions = o,
        this.blendMode = new Lw(n),
        this.blendMode.addEventListener("change", l => this.setChanged()),
        this._inputColorSpace = Wr,
        this._outputColorSpace = Xi
    }
    get inputColorSpace() {
        return this._inputColorSpace
    }
    set inputColorSpace(i) {
        this._inputColorSpace = i,
        this.setChanged()
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(i) {
        this._outputColorSpace = i,
        this.setChanged()
    }
    set mainScene(i) {}
    set mainCamera(i) {}
    getName() {
        return this.name
    }
    setRenderer(i) {
        this.renderer = i
    }
    getDefines() {
        return this.defines
    }
    getUniforms() {
        return this.uniforms
    }
    getExtensions() {
        return this.extensions
    }
    getBlendMode() {
        return this.blendMode
    }
    getAttributes() {
        return this.attributes
    }
    setAttributes(i) {
        this.attributes = i,
        this.setChanged()
    }
    getFragmentShader() {
        return this.fragmentShader
    }
    setFragmentShader(i) {
        this.fragmentShader = i,
        this.setChanged()
    }
    getVertexShader() {
        return this.vertexShader
    }
    setVertexShader(i) {
        this.vertexShader = i,
        this.setChanged()
    }
    setChanged() {
        this.dispatchEvent({
            type: "change"
        })
    }
    setDepthTexture(i, e=Ua) {}
    update(i, e, t) {}
    setSize(i, e) {}
    initialize(i, e, t) {}
    dispose() {
        for (const i of Object.keys(this)) {
            const e = this[i];
            (e instanceof Bi || e instanceof Lo || e instanceof cn || e instanceof jr) && this[i].dispose()
        }
    }
}
  , Uw = class extends jr {
    constructor(i, e, t=null) {
        super("RenderPass", i, e),
        this.needsSwap = !1,
        this.clearPass = new kg,
        this.overrideMaterialManager = t === null ? null : new Mp(t),
        this.ignoreBackground = !1,
        this.skipShadowMapUpdate = !1,
        this.selection = null
    }
    set mainScene(i) {
        this.scene = i
    }
    set mainCamera(i) {
        this.camera = i
    }
    get renderToScreen() {
        return super.renderToScreen
    }
    set renderToScreen(i) {
        super.renderToScreen = i,
        this.clearPass.renderToScreen = i
    }
    get overrideMaterial() {
        const i = this.overrideMaterialManager;
        return i !== null ? i.material : null
    }
    set overrideMaterial(i) {
        const e = this.overrideMaterialManager;
        i !== null ? e !== null ? e.setMaterial(i) : this.overrideMaterialManager = new Mp(i) : e !== null && (e.dispose(),
        this.overrideMaterialManager = null)
    }
    getOverrideMaterial() {
        return this.overrideMaterial
    }
    setOverrideMaterial(i) {
        this.overrideMaterial = i
    }
    get clear() {
        return this.clearPass.enabled
    }
    set clear(i) {
        this.clearPass.enabled = i
    }
    getSelection() {
        return this.selection
    }
    setSelection(i) {
        this.selection = i
    }
    isBackgroundDisabled() {
        return this.ignoreBackground
    }
    setBackgroundDisabled(i) {
        this.ignoreBackground = i
    }
    isShadowMapDisabled() {
        return this.skipShadowMapUpdate
    }
    setShadowMapDisabled(i) {
        this.skipShadowMapUpdate = i
    }
    getClearPass() {
        return this.clearPass
    }
    render(i, e, t, n, r) {
        const s = this.scene
          , o = this.camera
          , a = this.selection
          , l = o.layers.mask
          , c = s.background
          , u = i.shadowMap.autoUpdate
          , f = this.renderToScreen ? null : e;
        a !== null && o.layers.set(a.getLayer()),
        this.skipShadowMapUpdate && (i.shadowMap.autoUpdate = !1),
        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null),
        this.clearPass.enabled && this.clearPass.render(i, e),
        i.setRenderTarget(f),
        this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(i, s, o) : i.render(s, o),
        o.layers.mask = l,
        s.background = c,
        i.shadowMap.autoUpdate = u
    }
}
  , Nw = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#elif defined(USE_REVERSED_DEPTH_BUFFER)\ndepth=1.0-depth;\n#endif\nreturn depth;}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}"
  , Ow = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
  , Fw = class extends zi {
    constructor(i, e, t, n, r=!1) {
        super({
            name: "EffectMaterial",
            defines: {
                THREE_REVISION: uc.replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1"
            },
            uniforms: {
                inputBuffer: new dn(null),
                depthBuffer: new dn(null),
                resolution: new dn(new lt),
                texelSize: new dn(new lt),
                cameraNear: new dn(.3),
                cameraFar: new dn(1e3),
                aspect: new dn(1),
                time: new dn(0)
            },
            blending: Zi,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            dithering: r
        }),
        i && this.setShaderParts(i),
        e && this.setDefines(e),
        t && this.setUniforms(t),
        this.copyCameraSettings(n)
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i
    }
    get depthBuffer() {
        return this.uniforms.depthBuffer.value
    }
    set depthBuffer(i) {
        this.uniforms.depthBuffer.value = i
    }
    get depthPacking() {
        return Number(this.defines.DEPTH_PACKING)
    }
    set depthPacking(i) {
        this.defines.DEPTH_PACKING = i.toFixed(0),
        this.needsUpdate = !0
    }
    setDepthBuffer(i, e=Ua) {
        this.depthBuffer = i,
        this.depthPacking = e
    }
    setShaderData(i) {
        this.setShaderParts(i.shaderParts),
        this.setDefines(i.defines),
        this.setUniforms(i.uniforms),
        this.setExtensions(i.extensions)
    }
    setShaderParts(i) {
        return this.fragmentShader = Nw.replace(mt.FRAGMENT_HEAD, i.get(mt.FRAGMENT_HEAD) || "").replace(mt.FRAGMENT_MAIN_UV, i.get(mt.FRAGMENT_MAIN_UV) || "").replace(mt.FRAGMENT_MAIN_IMAGE, i.get(mt.FRAGMENT_MAIN_IMAGE) || ""),
        this.vertexShader = Ow.replace(mt.VERTEX_HEAD, i.get(mt.VERTEX_HEAD) || "").replace(mt.VERTEX_MAIN_SUPPORT, i.get(mt.VERTEX_MAIN_SUPPORT) || ""),
        this.needsUpdate = !0,
        this
    }
    setDefines(i) {
        for (const e of i.entries())
            this.defines[e[0]] = e[1];
        return this.needsUpdate = !0,
        this
    }
    setUniforms(i) {
        for (const e of i.entries())
            this.uniforms[e[0]] = e[1];
        return this
    }
    setExtensions(i) {
        this.extensions = {};
        for (const e of i)
            this.extensions[e] = !0;
        return this
    }
    get encodeOutput() {
        return this.defines.ENCODE_OUTPUT !== void 0
    }
    set encodeOutput(i) {
        this.encodeOutput !== i && (i ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
        this.needsUpdate = !0)
    }
    isOutputEncodingEnabled(i) {
        return this.encodeOutput
    }
    setOutputEncodingEnabled(i) {
        this.encodeOutput = i
    }
    get time() {
        return this.uniforms.time.value
    }
    set time(i) {
        this.uniforms.time.value = i
    }
    setDeltaTime(i) {
        this.uniforms.time.value += i
    }
    adoptCameraSettings(i) {
        this.copyCameraSettings(i)
    }
    copyCameraSettings(i) {
        i && (this.uniforms.cameraNear.value = i.near,
        this.uniforms.cameraFar.value = i.far,
        i instanceof Mi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
        this.needsUpdate = !0)
    }
    setSize(i, e) {
        const t = this.uniforms;
        t.resolution.value.set(i, e),
        t.texelSize.value.set(1 / i, 1 / e),
        t.aspect.value = i / e
    }
    static get Section() {
        return mt
    }
}
;
function Tp(i, e, t) {
    for (const n of e) {
        const r = "$1" + i + n.charAt(0).toUpperCase() + n.slice(1)
          , s = new RegExp("([^\\.])(\\b" + n + "\\b)","g");
        for (const o of t.entries())
            o[1] !== null && t.set(o[0], o[1].replace(s, r))
    }
}
function Bw(i, e, t) {
    let n = e.getFragmentShader()
      , r = e.getVertexShader();
    const s = n !== void 0 && /mainImage/.test(n)
      , o = n !== void 0 && /mainUv/.test(n);
    if (t.attributes |= e.getAttributes(),
    n === void 0)
        throw new Error("Missing fragment shader (".concat(e.name, ")"));
    if (o && (t.attributes & Rs.CONVOLUTION) !== 0)
        throw new Error("Effects that transform UVs are incompatible with convolution effects (".concat(e.name, ")"));
    if (!s && !o)
        throw new Error("Could not find mainImage or mainUv function (".concat(e.name, ")"));
    {
        const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
          , l = t.shaderParts;
        let c = l.get(mt.FRAGMENT_HEAD) || ""
          , u = l.get(mt.FRAGMENT_MAIN_UV) || ""
          , f = l.get(mt.FRAGMENT_MAIN_IMAGE) || ""
          , h = l.get(mt.VERTEX_HEAD) || ""
          , d = l.get(mt.VERTEX_MAIN_SUPPORT) || "";
        const _ = new Set
          , g = new Set;
        if (o && (u += "	".concat(i, "MainUv(UV);\n"),
        t.uvTransformation = !0),
        r !== null && /mainSupport/.test(r)) {
            const E = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
            d += "	".concat(i, "MainSupport("),
            d += E ? "vUv);\n" : ");\n";
            for (const S of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                for (const v of S[1].split(/\s*,\s*/))
                    t.varyings.add(v),
                    _.add(v),
                    g.add(v);
            for (const S of r.matchAll(a))
                g.add(S[1])
        }
        for (const E of n.matchAll(a))
            g.add(E[1]);
        for (const E of e.defines.keys())
            g.add(E.replace(/\([\w\s,]*\)/g, ""));
        for (const E of e.uniforms.keys())
            g.add(E);
        g.delete("while"),
        g.delete("for"),
        g.delete("if"),
        e.uniforms.forEach( (E, S) => t.uniforms.set(i + S.charAt(0).toUpperCase() + S.slice(1), E)),
        e.defines.forEach( (E, S) => t.defines.set(i + S.charAt(0).toUpperCase() + S.slice(1), E));
        const m = new Map([["fragment", n], ["vertex", r]]);
        Tp(i, g, t.defines),
        Tp(i, g, m),
        n = m.get("fragment"),
        r = m.get("vertex");
        const p = e.blendMode;
        if (t.blendModes.set(p.blendFunction, p),
        s) {
            e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (f += e.inputColorSpace === kt ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	"),
            e.outputColorSpace !== Xi ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
            const E = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            f += "".concat(i, "MainImage(color0, UV, "),
            (t.attributes & Rs.DEPTH) !== 0 && E.test(n) && (f += "depth, ",
            t.readDepth = !0),
            f += "color1);\n	";
            const S = i + "BlendOpacity";
            t.uniforms.set(S, p.opacity),
            f += "color0 = blend".concat(p.blendFunction, "(color0, color1, ").concat(S, ");\n\n	"),
            c += "uniform float ".concat(S, ";\n\n")
        }
        if (c += n + "\n",
        r !== null && (h += r + "\n"),
        l.set(mt.FRAGMENT_HEAD, c),
        l.set(mt.FRAGMENT_MAIN_UV, u),
        l.set(mt.FRAGMENT_MAIN_IMAGE, f),
        l.set(mt.VERTEX_HEAD, h),
        l.set(mt.VERTEX_MAIN_SUPPORT, d),
        e.extensions !== null)
            for (const E of e.extensions)
                t.extensions.add(E)
    }
}
var zw = class extends jr {
    constructor(i, ...e) {
        super("EffectPass"),
        this.fullscreenMaterial = new Fw(null,null,null,i),
        this.listener = t => this.handleEvent(t),
        this.effects = [],
        this.setEffects(e),
        this.skipRendering = !1,
        this.minTime = 1,
        this.maxTime = Number.POSITIVE_INFINITY,
        this.timeScale = 1
    }
    set mainScene(i) {
        for (const e of this.effects)
            e.mainScene = i
    }
    set mainCamera(i) {
        this.fullscreenMaterial.copyCameraSettings(i);
        for (const e of this.effects)
            e.mainCamera = i
    }
    get encodeOutput() {
        return this.fullscreenMaterial.encodeOutput
    }
    set encodeOutput(i) {
        this.fullscreenMaterial.encodeOutput = i
    }
    get dithering() {
        return this.fullscreenMaterial.dithering
    }
    set dithering(i) {
        const e = this.fullscreenMaterial;
        e.dithering = i,
        e.needsUpdate = !0
    }
    setEffects(i) {
        for (const e of this.effects)
            e.removeEventListener("change", this.listener);
        this.effects = i.sort( (e, t) => t.attributes - e.attributes);
        for (const e of this.effects)
            e.addEventListener("change", this.listener)
    }
    updateMaterial() {
        const i = new Jb;
        let e = 0;
        for (const o of this.effects)
            if (o.blendMode.blendFunction === ct.DST)
                i.attributes |= o.getAttributes() & Rs.DEPTH;
            else {
                if ((i.attributes & o.getAttributes() & Rs.CONVOLUTION) !== 0)
                    throw new Error("Convolution effects cannot be merged (".concat(o.name, ")"));
                Bw("e" + e++, o, i)
            }
        let t = i.shaderParts.get(mt.FRAGMENT_HEAD)
          , n = i.shaderParts.get(mt.FRAGMENT_MAIN_IMAGE)
          , r = i.shaderParts.get(mt.FRAGMENT_MAIN_UV);
        const s = /\bblend\b/g;
        for (const o of i.blendModes.values())
            t += o.getShaderCode().replace(s, "blend".concat(o.blendFunction)) + "\n";
        (i.attributes & Rs.DEPTH) !== 0 ? (i.readDepth && (n = "float depth = readDepth(UV);\n\n	" + n),
        this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1,
        i.colorSpace === kt && (n += "color0 = sRGBToLinear(color0);\n	"),
        i.uvTransformation ? (r = "vec2 transformedUv = vUv;\n" + r,
        i.defines.set("UV", "transformedUv")) : i.defines.set("UV", "vUv"),
        i.shaderParts.set(mt.FRAGMENT_HEAD, t),
        i.shaderParts.set(mt.FRAGMENT_MAIN_IMAGE, n),
        i.shaderParts.set(mt.FRAGMENT_MAIN_UV, r);
        for (const [o,a] of i.shaderParts)
            a !== null && i.shaderParts.set(o, a.trim().replace(/^#/, "\n#"));
        this.skipRendering = e === 0,
        this.needsSwap = !this.skipRendering,
        this.fullscreenMaterial.setShaderData(i)
    }
    recompile() {
        this.updateMaterial()
    }
    getDepthTexture() {
        return this.fullscreenMaterial.depthBuffer
    }
    setDepthTexture(i, e=Ua) {
        this.fullscreenMaterial.depthBuffer = i,
        this.fullscreenMaterial.depthPacking = e;
        for (const t of this.effects)
            t.setDepthTexture(i, e)
    }
    render(i, e, t, n, r) {
        for (const s of this.effects)
            s.update(i, e, n);
        if (!this.skipRendering || this.renderToScreen) {
            const s = this.fullscreenMaterial;
            s.inputBuffer = e.texture,
            s.time += n * this.timeScale,
            i.setRenderTarget(this.renderToScreen ? null : t),
            i.render(this.scene, this.camera)
        }
    }
    setSize(i, e) {
        this.fullscreenMaterial.setSize(i, e);
        for (const t of this.effects)
            t.setSize(i, e)
    }
    initialize(i, e, t) {
        this.renderer = i;
        for (const n of this.effects)
            n.initialize(i, e, t);
        this.updateMaterial(),
        t !== void 0 && t !== hi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
    }
    dispose() {
        super.dispose();
        for (const i of this.effects)
            i.removeEventListener("change", this.listener),
            i.dispose()
    }
    handleEvent(i) {
        switch (i.type) {
        case "change":
            this.recompile();
            break
        }
    }
}
;
class kw extends Iw {
    constructor({distance: e=34, strength: t=1}={}) {
        super("CurveEffect", " \n        uniform float uDistance;\n        uniform float uStrength;\n\n        void mainUv(inout vec2 uv) {\n          float str = uStrength * -.05;\n          uv.x += (uv.x * 2. - 1.) * str * pow(1. - uv.y, uDistance);\n        }\n      ", {
            blendFunction: ct.NORMAL,
            uniforms: new Map([["uDistance", new dn(e)], ["uStrength", new dn(t)]])
        })
    }
}
var vs, vi, Ii, yn, Ui, kn, xi, Hn, yi, xs, Bf, ic, qe, Hg, Vg, Gg, Wg, Xg, ta, eo, qg, na, Yg, $g, jg, Kg, Zg, Jg, Of, Qg, e_, t_;
class Hw {
    constructor(e, t={}) {
        Fn(this, qe);
        Fn(this, vs);
        Fn(this, vi);
        Fn(this, Ii);
        Fn(this, yn);
        Fn(this, Ui);
        Fn(this, kn);
        Fn(this, xi);
        Fn(this, Hn);
        Fn(this, yi);
        xe(this, "composer");
        Fn(this, xs);
        Fn(this, Bf);
        Fn(this, ic, {
            root: null,
            rootMargin: "25% 0px",
            threshold: 0
        });
        if (Bn(this, vs, e),
        Bn(this, Ii, {
            autoStart: !1,
            sceneSelector: "[data-scene]",
            assetSelector: "img:not(.video-poster-image__img),video,[data-scene-fill]",
            fillSelector: "data-scene-fill",
            uniforms: {
                distance: 0,
                strength: 0
            },
            ...t
        }),
        Bn(this, yn, []),
        Bn(this, Ui, []),
        Bn(this, kn, {
            width: window.innerWidth,
            height: window.innerHeight
        }),
        !ye(this, vs))
            return () => {}
            ;
        _t(this, qe, Hg).call(this),
        _t(this, qe, Gg).call(this),
        _t(this, qe, Wg).call(this),
        _t(this, qe, Xg).call(this),
        _t(this, qe, Qg).call(this),
        _t(this, qe, Yg).call(this),
        this._sharedGeometry = new Do(1,1),
        this._sharedMaterials = {
            image: new oo({
                transparent: !0,
                side: pn,
                opacity: 0
            }),
            fill: new oo({
                transparent: !0,
                side: pn,
                opacity: 0
            }),
            video: new oo({
                transparent: !0,
                side: pn,
                opacity: 0
            })
        },
        this._scratchVec2 = new lt,
        this._scratchVec3 = new Z,
        It.on("ExperienceController:update", n => {
            n.forEach(r => {
                ye(this, vi).observe(r)
            }
            )
        }
        ),
        ye(this, Ii).autoStart && this.start()
    }
    init({node: e}) {
        const t = e.querySelectorAll(ye(this, Ii).sceneSelector);
        Bn(this, Ui, Array.from(t)),
        ye(this, Ui).forEach(n => {
            ye(this, vi).observe(n)
        }
        )
    }
    showScene(e) {
        const t = e.querySelectorAll(ye(this, Ii).assetSelector);
        if (!t.length)
            return !1;
        if (e.classList.contains("has-rendered"))
            return t.forEach(n => this.showMeshByElement(n)),
            !1;
        ye(this, Ui).find(n => n === e) || ye(this, Ui).push(e),
        t.forEach(n => {
            _t(this, qe, $g).call(this, n)
        }
        ),
        e.classList.add("has-rendered"),
        ye(this, vi).unobserve(e)
    }
    hideScene(e) {
        e.querySelectorAll(ye(this, Ii).assetSelector).forEach(n => {
            this.hideMeshByElement(n)
        }
        )
    }
    destroy() {
        this.cleanupObserver(),
        ye(this, vi).disconnect(),
        ye(this, yn).forEach(e => {
            this.destroyMesh(e)
        }
        ),
        ye(this, xi).clear(),
        ye(this, yi).renderLists.dispose(),
        ye(this, Ui).forEach(e => {
            e.classList.remove("has-rendered")
        }
        ),
        Bn(this, Ui, []),
        Bn(this, yn, [])
    }
    destroyMesh(e) {
        var t, n, r, s, o, a, l;
        e && (ye(this, xi).remove(e.current),
        e._cleanup && Array.isArray(e._cleanup) && e._cleanup.forEach(c => {
            try {
                c()
            } catch (u) {}
        }
        ),
        (r = (n = (t = e.current) == null ? void 0 : t.material) == null ? void 0 : n.map) == null || r.dispose(),
        (o = (s = e.current) == null ? void 0 : s.geometry) == null || o.dispose(),
        (l = (a = e.current) == null ? void 0 : a.material) == null || l.dispose(),
        ye(this, yn).splice(ye(this, yn).indexOf(e), 1))
    }
    hideMeshByElement(e) {
        const t = ye(this, yn).find(n => n.domElement === e);
        t && (t.current.visible = !1)
    }
    showMeshByElement(e) {
        const t = ye(this, yn).find(n => n.domElement === e);
        t && (t.current.visible = !0)
    }
    observe(e) {
        ye(this, vi).observe(e)
    }
    unobserve(e) {
        ye(this, vi).unobserve(e)
    }
    cleanupObserver() {
        ye(this, vi) && ye(this, Ui).forEach(e => {
            ye(this, vi).unobserve(e)
        }
        )
    }
    start() {
        Jl.add(e => {
            _t(this, qe, t_).call(this, e)
        }
        , {
            priority: 1,
            fps: 60
        }),
        this.init({
            node: document.body
        }),
        ye(this, vs).classList.remove("hidden")
    }
}
vs = new WeakMap,
vi = new WeakMap,
Ii = new WeakMap,
yn = new WeakMap,
Ui = new WeakMap,
kn = new WeakMap,
xi = new WeakMap,
Hn = new WeakMap,
yi = new WeakMap,
xs = new WeakMap,
Bf = new WeakMap,
ic = new WeakMap,
qe = new WeakSet,
Hg = function() {
    Bn(this, xi, new If)
}
,
Vg = function(e) {
    const t = window.innerWidth
      , n = window.innerHeight
      , r = t / n;
    let s, o, a, l;
    return r >= 1 ? (s = -e,
    o = e,
    a = e / r,
    l = -e / r) : (s = -e * r,
    o = e * r,
    a = e,
    l = -e),
    {
        left: s,
        right: o,
        top: a,
        bottom: l
    }
}
,
Gg = function() {
    const e = _t(this, qe, Vg).call(this, 10);
    Bn(this, Hn, new Th(e.left,e.right,e.top,e.bottom,.1,1e3)),
    ye(this, Hn).position.set(0, 0, 10),
    ye(this, xi).add(ye(this, Hn))
}
,
Wg = function() {
    Bn(this, yi, new Hb({
        canvas: ye(this, vs),
        powerPreference: "high-performance",
        antialias: !1,
        stencil: !1,
        depth: !1,
        alpha: !0
    })),
    ye(this, yi).setSize(ye(this, kn).width, ye(this, kn).height),
    ye(this, yi).setPixelRatio(Math.min(window.devicePixelRatio, 2))
}
,
Xg = function() {
    this.composer = new Zb(ye(this, yi)),
    this.composer.addPass(new Uw(ye(this, xi),ye(this, Hn))),
    Bn(this, xs, new kw({
        distance: ye(this, Ii).uniforms.distance,
        strength: ye(this, Ii).uniforms.strength
    })),
    this.composer.addPass(new zw(ye(this, Hn),ye(this, xs)))
}
,
ta = function(e) {
    const t = e.getBoundingClientRect()
      , n = (t.left + t.width / 2) / window.innerWidth * 2 - 1
      , r = -((t.top + t.height / 2 + window.lenis.scroll - window.lenis.scroll) / window.innerHeight) * 2 + 1;
    this._scratchVec3.set(n, r, 0).unproject(ye(this, Hn));
    const {x: s, y: o} = this._scratchVec3
      , a = t.width / window.innerWidth * 2 + 1
      , l = t.height / window.innerHeight * 2 + 1;
    return [s, o, a, l]
}
,
eo = function(e, t, n, r, s) {
    const {width: o, height: a} = _t(this, qe, qg).call(this);
    e.current.position.x = t,
    e.current.position.y = n;
    const l = (f, h) => f * (1 - Math.abs(h)) / 2;
    let c = l(o, r)
      , u = l(a, s);
    e.current.scale.x = c,
    e.current.scale.y = u
}
,
qg = function() {
    const e = new lt;
    ye(this, yi).getSize(e);
    let t, n;
    if (ye(this, Hn).isOrthographicCamera)
        t = ye(this, Hn).right - ye(this, Hn).left,
        n = ye(this, Hn).top - ye(this, Hn).bottom;
    else
        throw new Error("Camera must be an OrthographicCamera");
    return {
        width: t,
        height: n
    }
}
,
na = function(e, t, n, r, s) {
    if (!t) {
        console.warn("Invalid texture: texture is null or undefined");
        return
    }
    try {
        if (!t.image) {
            console.warn("Texture image not loaded yet");
            return
        }
        t.flipY = !1,
        t.colorSpace = kt,
        t.wrapS = ec,
        t.repeat.x = -1,
        t.image.width > 0 && (t.minFilter = ln,
        t.magFilter = ln);
        const o = n / r;
        s > o ? (t.repeat.y = o / s,
        t.offset.y = (1 - t.repeat.y) / 2) : s < o && (t.repeat.x = s / o * -1,
        t.offset.x = (1 - t.repeat.x) / 2),
        e.current.material.map = t,
        e.current.material.transparent = !0,
        e.current.material.needsUpdate = !0,
        e.current.material.opacity = 0,
        ye(this, yi).initTexture(t)
    } catch (o) {
        console.warn("Error applying texture:", o)
    }
}
,
Yg = function() {
    Bn(this, vi, new IntersectionObserver(e => {
        e.forEach(t => {
            const n = t.target;
            t.isIntersecting ? this.showScene(n) : this.hideScene(n)
        }
        )
    }
    ,ye(this, ic)))
}
,
$g = function(e) {
    e && (e.tagName === "VIDEO" ? _t(this, qe, jg).call(this, e) : e.tagName === "IMG" ? _t(this, qe, Kg).call(this, e) : e.hasAttribute(ye(this, Ii).fillSelector) && _t(this, qe, Zg).call(this, e))
}
,
jg = function(e) {
    var u, f;
    const t = _t(this, qe, ta).call(this, e)
      , n = this._sharedGeometry.clone()
      , r = this._sharedMaterials.video.clone()
      , s = {
        current: new Wn(n,r),
        domElement: e,
        type: "video",
        _cleanup: []
    }
      , o = e.clientWidth / e.clientHeight
      , a = (u = e.parentNode) != null ? u : null
      , l = (f = a == null ? void 0 : a.querySelector(".video-poster-image img")) != null ? f : null
      , c = () => {
        const h = new Jy(e)
          , {videoWidth: d, videoHeight: _} = h.source.data;
        _t(this, qe, na).call(this, s, h, d, _, o),
        e.hasAttribute("data-play-on-hover") || (e.play(),
        Dt.to(s.current.material, {
            opacity: 1,
            duration: .3,
            delay: .25,
            ease: "linear"
        })),
        _t(this, qe, eo).call(this, s, ...t),
        ye(this, xi).add(s.current),
        ye(this, yn).push(s)
    }
    ;
    if (e.readyState >= 3)
        c();
    else {
        l && (e.readyState < 2 || e.hasAttribute("data-play-on-hover")) ? _t(this, qe, Jg).call(this, s, l, t, o) : console.log("no poster image");
        const h = () => {
            c(),
            e.removeEventListener("canplay", h)
        }
        ;
        e.addEventListener("canplay", h),
        s._cleanup.push( () => e.removeEventListener("canplay", h))
    }
}
,
Kg = function(e) {
    const t = _t(this, qe, ta).call(this, e)
      , n = this._sharedGeometry.clone()
      , r = this._sharedMaterials.image.clone()
      , s = {
        current: new Wn(n,r),
        domElement: e,
        type: "image",
        _cleanup: []
    }
      , o = e.clientWidth / e.clientHeight
      , a = () => {
        const c = e.currentSrc || e.src;
        if (!c)
            return;
        new Kd().load(c, f => {
            const {naturalWidth: h, naturalHeight: d} = e;
            _t(this, qe, na).call(this, s, f, h, d, o),
            Dt.to(s.current.material, {
                opacity: 1,
                duration: .25,
                ease: "linear"
            })
        }
        , void 0, f => {
            console.error("Error loading texture:", f)
        }
        )
    }
    ;
    e.complete && !e.classList.contains("lazyload") ? a() : (e.addEventListener("lazyloaded", a),
    s._cleanup.push( () => e.removeEventListener("lazyloaded", a)));
    const l = new MutationObserver(c => {
        for (const u of c)
            u.type === "attributes" && ["src", "srcset"].includes(u.attributeName) && setTimeout(a, 100)
    }
    );
    l.observe(e, {
        attributes: !0,
        attributeFilter: ["src", "srcset"]
    }),
    s._cleanup.push( () => l.disconnect()),
    _t(this, qe, eo).call(this, s, ...t),
    ye(this, xi).add(s.current),
    ye(this, yn).push(s)
}
,
Zg = function(e) {
    const t = _t(this, qe, ta).call(this, e)
      , n = this._sharedGeometry.clone()
      , r = this._sharedMaterials.fill.clone();
    r.color = new St(e.dataset.sceneFill);
    const s = {
        current: new Wn(n,r),
        domElement: e,
        type: "fill",
        _cleanup: []
    };
    Dt.to(s.current.material, {
        opacity: 1,
        duration: .25,
        ease: "linear"
    }),
    _t(this, qe, eo).call(this, s, ...t),
    ye(this, xi).add(s.current),
    ye(this, yn).push(s)
}
,
Jg = function(e, t, n, r) {
    const s = {
        current: null,
        domElement: t,
        type: "poster",
        _cleanup: []
    }
      , o = _ => {
        const g = t.currentSrc || t.src;
        if (!g)
            return;
        new Kd().load(g, p => {
            const {naturalWidth: E, naturalHeight: S} = t;
            if (e.domElement.readyState >= 3)
                return !1;
            if (s.current)
                _t(this, qe, na).call(this, s, p, E, S, r),
                Dt.to(s.current.material, {
                    opacity: 1,
                    duration: .25,
                    ease: "linear"
                });
            else {
                const v = new Do(1,1)
                  , b = new oo({
                    map: p,
                    transparent: !0,
                    opacity: 1,
                    side: pn,
                    depthWrite: !1
                });
                s.current = new Wn(v,b),
                _t(this, qe, na).call(this, s, p, E, S, r),
                _t(this, qe, eo).call(this, s, ...n),
                ye(this, xi).add(s.current),
                ye(this, yn).push(s),
                Dt.to(s.current.material, {
                    opacity: 1,
                    duration: .25,
                    ease: "linear"
                })
            }
        }
        )
    }
    ;
    t.complete && t.naturalWidth > 0 && !t.classList.contains("lazyload") ? o() : (t.addEventListener("lazyloaded", o, {
        once: !0
    }),
    s._cleanup.push( () => t.removeEventListener("lazyloaded", o, {
        once: !0
    })));
    const a = new MutationObserver(_ => {
        for (const g of _)
            g.type === "attributes" && ["src", "srcset"].includes(g.attributeName) && setTimeout(o, 100)
    }
    );
    a.observe(t, {
        attributes: !0,
        attributeFilter: ["src", "srcset"]
    }),
    s._cleanup.push( () => a.disconnect());
    const l = () => {
        var _;
        return (_ = s.current) == null ? void 0 : _.material
    }
      , c = () => {
        var _;
        return (_ = e.current) == null ? void 0 : _.material
    }
      , u = () => {
        l() && (Dt.to(l(), {
            opacity: 0,
            delay: e.domElement.hasAttribute("data-play-on-hover") ? 0 : .1,
            duration: .25,
            overwrite: !0,
            onComplete: () => {
                s.current.visible = !1
            }
        }),
        Dt.to(c(), {
            opacity: 1,
            duration: .1,
            overwrite: !0,
            onComplete: () => {
                e.current.visible = !0
            }
        }))
    }
      , f = () => {
        l() && (Dt.to(l(), {
            opacity: 1,
            duration: .25,
            overwrite: !0,
            onStart: () => {
                s.current.visible = !0
            }
        }),
        Dt.to(c(), {
            opacity: 0,
            duration: .1,
            delay: .15,
            overwrite: !0,
            onComplete: () => {
                e.current.visible = !1
            }
        }))
    }
      , h = u
      , d = () => {
        e.domElement.hasAttribute("data-play-on-hover") && f()
    }
    ;
    return e.domElement.addEventListener("playing", h),
    e.domElement.addEventListener("pause", d),
    e._cleanup.push( () => e.domElement.removeEventListener("playing", h)),
    e._cleanup.push( () => e.domElement.removeEventListener("pause", d)),
    e.domElement.paused ? f() : u(),
    s
}
,
Of = function() {
    if (!ye(this, yn).length)
        return;
    ye(this, yn).map(t => {
        const n = _t(this, qe, ta).call(this, t.domElement);
        return {
            mesh: t,
            specs: n
        }
    }
    ).forEach( ({mesh: t, specs: n}) => {
        _t(this, qe, eo).call(this, t, ...n)
    }
    )
}
,
Qg = function() {
    window.addEventListener("resize", () => {
        _t(this, qe, e_).call(this)
    }
    )
}
,
e_ = function() {
    ye(this, kn).width = window.innerWidth,
    ye(this, kn).height = window.innerHeight,
    _t(this, qe, Of).call(this),
    ye(this, yi).setSize(ye(this, kn).width, ye(this, kn).height),
    ye(this, yi).setPixelRatio(Math.min(window.devicePixelRatio, 2)),
    this.composer.setSize(ye(this, kn).width, ye(this, kn).height),
    ye(this, xs) && ye(this, xs).setSize(ye(this, kn).width, ye(this, kn).height)
}
,
t_ = function(e) {
    _t(this, qe, Of).call(this),
    this.composer.render()
}
;
var du = {
    exports: {}
}, bp;
function Vw() {
    return bp || (bp = 1,
    (function(i) {
        (function() {
            function e(g, m) {
                document.addEventListener ? g.addEventListener("scroll", m, !1) : g.attachEvent("scroll", m)
            }
            function t(g) {
                document.body ? g() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function m() {
                    document.removeEventListener("DOMContentLoaded", m),
                    g()
                }) : document.attachEvent("onreadystatechange", function m() {
                    (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", m),
                    g())
                })
            }
            function n(g) {
                this.g = document.createElement("div"),
                this.g.setAttribute("aria-hidden", "true"),
                this.g.appendChild(document.createTextNode(g)),
                this.h = document.createElement("span"),
                this.i = document.createElement("span"),
                this.m = document.createElement("span"),
                this.j = document.createElement("span"),
                this.l = -1,
                this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",
                this.h.appendChild(this.m),
                this.i.appendChild(this.j),
                this.g.appendChild(this.h),
                this.g.appendChild(this.i)
            }
            function r(g, m) {
                g.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + m + ";"
            }
            function s(g) {
                var m = g.g.offsetWidth
                  , p = m + 100;
                return g.j.style.width = p + "px",
                g.i.scrollLeft = p,
                g.h.scrollLeft = g.h.scrollWidth + 100,
                g.l !== m ? (g.l = m,
                !0) : !1
            }
            function o(g, m) {
                function p() {
                    var S = E;
                    s(S) && S.g.parentNode !== null && m(S.l)
                }
                var E = g;
                e(g.h, p),
                e(g.i, p),
                s(g)
            }
            function a(g, m, p) {
                m = m || {},
                p = p || window,
                this.family = g,
                this.style = m.style || "normal",
                this.weight = m.weight || "normal",
                this.stretch = m.stretch || "normal",
                this.context = p
            }
            var l = null
              , c = null
              , u = null
              , f = null;
            function h(g) {
                return c === null && (d(g) && /Apple/.test(window.navigator.vendor) ? (g = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent),
                c = !!g && 603 > parseInt(g[1], 10)) : c = !1),
                c
            }
            function d(g) {
                return f === null && (f = !!g.document.fonts),
                f
            }
            function _(g, m) {
                var p = g.style
                  , E = g.weight;
                if (u === null) {
                    var S = document.createElement("div");
                    try {
                        S.style.font = "condensed 100px sans-serif"
                    } catch (v) {}
                    u = S.style.font !== ""
                }
                return [p, E, u ? g.stretch : "", "100px", m].join(" ")
            }
            a.prototype.load = function(g, m) {
                var p = this
                  , E = g || "BESbswy"
                  , S = 0
                  , v = m || 3e3
                  , b = new Date().getTime();
                return new Promise(function(A, T) {
                    if (d(p.context) && !h(p.context)) {
                        var R = new Promise(function(x, P) {
                            function U() {
                                new Date().getTime() - b >= v ? P(Error("" + v + "ms timeout exceeded")) : p.context.document.fonts.load(_(p, '"' + p.family + '"'), E).then(function(O) {
                                    1 <= O.length ? x() : setTimeout(U, 25)
                                }, P)
                            }
                            U()
                        }
                        )
                          , y = new Promise(function(x, P) {
                            S = setTimeout(function() {
                                P(Error("" + v + "ms timeout exceeded"))
                            }, v)
                        }
                        );
                        Promise.race([y, R]).then(function() {
                            clearTimeout(S),
                            A(p)
                        }, T)
                    } else
                        t(function() {
                            function x() {
                                var ue;
                                (ue = X != -1 && H != -1 || X != -1 && Y != -1 || H != -1 && Y != -1) && ((ue = X != H && X != Y && H != Y) || (l === null && (ue = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),
                                l = !!ue && (536 > parseInt(ue[1], 10) || parseInt(ue[1], 10) === 536 && 11 >= parseInt(ue[2], 10))),
                                ue = l && (X == N && H == N && Y == N || X == k && H == k && Y == k || X == C && H == C && Y == C)),
                                ue = !ue),
                                ue && (re.parentNode !== null && re.parentNode.removeChild(re),
                                clearTimeout(S),
                                A(p))
                            }
                            function P() {
                                if (new Date().getTime() - b >= v)
                                    re.parentNode !== null && re.parentNode.removeChild(re),
                                    T(Error("" + v + "ms timeout exceeded"));
                                else {
                                    var ue = p.context.document.hidden;
                                    (ue === !0 || ue === void 0) && (X = U.g.offsetWidth,
                                    H = O.g.offsetWidth,
                                    Y = B.g.offsetWidth,
                                    x()),
                                    S = setTimeout(P, 50)
                                }
                            }
                            var U = new n(E)
                              , O = new n(E)
                              , B = new n(E)
                              , X = -1
                              , H = -1
                              , Y = -1
                              , N = -1
                              , k = -1
                              , C = -1
                              , re = document.createElement("div");
                            re.dir = "ltr",
                            r(U, _(p, "sans-serif")),
                            r(O, _(p, "serif")),
                            r(B, _(p, "monospace")),
                            re.appendChild(U.g),
                            re.appendChild(O.g),
                            re.appendChild(B.g),
                            p.context.document.body.appendChild(re),
                            N = U.g.offsetWidth,
                            k = O.g.offsetWidth,
                            C = B.g.offsetWidth,
                            P(),
                            o(U, function(ue) {
                                X = ue,
                                x()
                            }),
                            r(U, _(p, '"' + p.family + '",sans-serif')),
                            o(O, function(ue) {
                                H = ue,
                                x()
                            }),
                            r(O, _(p, '"' + p.family + '",serif')),
                            o(B, function(ue) {
                                Y = ue,
                                x()
                            }),
                            r(B, _(p, '"' + p.family + '",monospace'))
                        })
                }
                )
            }
            ,
            i.exports = a
        }
        )()
    }
    )(du)),
    du.exports
}
var Gw = Vw();
const pu = rc(Gw)
  , Ww = () => {
    const i = document.getElementsByTagName("html")[0]
      , e = new pu("ABCDiatypeExpanded-Bold")
      , t = new pu("ABCDiatype-Regular")
      , n = new pu("Grit-Regular");
    Promise.all([e.load(), t.load(), n.load()]).then( () => i.classList.add("fonts-loaded")).catch( () => i.classList.add("fonts-failed"))
}
;
function qo(i) {
    return i.replace(/(^\/+|\/+$)/g, "")
}
const n_ = i => {
    [...document.querySelectorAll("a.is-active, a.is-current")].forEach(e => {
        e.classList.remove("is-current")
    }
    ),
    [...document.querySelectorAll("a")].forEach(e => {
        (qo(e.pathname) === qo(i) || qo(e.pathname).length && qo(i).indexOf(qo(e.pathname)) >= 0) && e.classList.add("is-current")
    }
    )
}
;
var mu, wp;
function Xw() {
    if (wp)
        return mu;
    wp = 1;
    function i(f) {
        return f && typeof f == "object" && f.nodeType === 1 && typeof f.style == "object" && typeof f.ownerDocument == "object"
    }
    function e(f) {
        return i(f) && f.tagName === "A"
    }
    function t(f) {
        do
            if (e(f))
                return f;
        while (f = f.parentNode)
    }
    function n(f) {
        return f.charAt(0) !== "/" && (f = "/" + f),
        f
    }
    function r(f) {
        var h = /^https?:\/\/|^\/\//i;
        return !h.test(f)
    }
    function s(f) {
        return typeof f == "object" && "button"in f && f.button !== 0
    }
    function o(f, h, d) {
        if (f || (f = {}),
        f.altKey || f.ctrlKey || f.metaKey || f.shiftKey || s(f) || (h && !e(h) && (h = t(h)),
        !h || !e(h)) || h.target === "_blank")
            return null;
        var _ = n(h.pathname)
          , g = n(window.location.pathname)
          , m = h.host
          , p = h.port
          , E = window.location.host
          , S = window.location.port;
        m === "" && "attributes"in h && "href"in h.attributes && "value"in h.attributes.href && r(h.attributes.href.value) && (m = E);
        var v = h.hash || (h.href.indexOf("#") > -1 ? "#" + h.href.split("#")[1] : null), b;
        return !S && p && (p === "80" || p === "443") && (E += ":" + p,
        m += m.indexOf(p, m.length - p.length) === -1 ? ":" + p : ""),
        m === E ? (b = _ === g && h.search === window.location.search && v,
        d === !0 ? b : b ? null : _ + (h.search || "") + (v || "")) : null
    }
    function a(f, h) {
        var d = null
          , _ = null;
        return arguments.length === 2 ? (d = f,
        _ = h) : i(f) ? _ = f : d = f,
        !_ && d && d.target && (_ = d.target),
        [d, _]
    }
    function l() {
        return o.apply(null, a.apply(null, arguments))
    }
    function c() {
        return o.apply(null, a.apply(null, arguments).concat(!0))
    }
    function u() {
        var f = Array.prototype.slice.call(arguments)
          , h = f[f.length - 1]
          , d = window.location.pathname;
        return typeof h == "string" && (d = h,
        f = f.slice(0, -1)),
        l.apply(null, f) === n(d)
    }
    return mu = {
        isLocal: o,
        pathname: l,
        getLocalPathname: l,
        hash: c,
        getLocalHash: c,
        active: u,
        isActive: u
    },
    mu
}
var qw = Xw();
const Yw = rc(qw)
  , wh = (i=document) => {
    [...i.querySelectorAll("a")].filter(e => Yw.isLocal("click", e, !0) === null && e.href !== window.location.href).forEach(e => {
        e.setAttribute("target", "_blank"),
        e.setAttribute("rel", "noopener")
    }
    )
}
;
window.log = () => {}
;
Dt.registerPlugin(je);
window.deviceType = window.matchMedia("(pointer: coarse)").matches ? "mobile" : "desktop";
const Ff = {};
document.querySelector(".bg-rainbow-container");
const gu = document.querySelector(".bg-rainbow")
  , Xr = window.deviceType === "mobile" ? null : new Hw(document.getElementById("canvas"),{
    autoStart: !0,
    uniforms: {
        distance: 34,
        strength: 1
    }
})
  , za = c_(i => a_(Object.assign({
    "./behaviours/Accordions.js": () => An( () => import("./Accordions-CNaIxqKJ.js"), []),
    "./behaviours/Chapters.js": () => An( () => import("./Chapters-C7c9abHf.js"), []),
    "./behaviours/ColorCycle.js": () => An( () => import("./ColorCycle-Msmd3mno.js"), []),
    "./behaviours/Cursor.js": () => An( () => import("./Cursor-BQcdVxuC.js"), []),
    "./behaviours/GSAPSticky.js": () => An( () => import("./GSAPSticky-D7OTLyRL.js"), []),
    "./behaviours/GoogleMap.js": () => An( () => import("./GoogleMap-DE4ELYV8.js"), []),
    "./behaviours/HomeIntro.js": () => An( () => import("./HomeIntro-DE6bugpW.js"), []),
    "./behaviours/InfiniteCarousel.js": () => An( () => import("./InfiniteCarousel-Bt2PSVV_.js"), []),
    "./behaviours/LazyVideo.js": () => An( () => import("./LazyVideo-CTUogpyd.js"), []),
    "./behaviours/LoadMore.js": () => An( () => import("./LoadMore-Ft-N99Mx.js"), []),
    "./behaviours/OpeningCredits.js": () => An( () => import("./OpeningCredits-BivqJm8d.js"), []),
    "./behaviours/PlayOnHover.js": () => An( () => import("./PlayOnHover-GB9v-O-b.js"), []),
    "./behaviours/SwiperCarousel.js": () => An( () => import("./SwiperCarousel-BlR1ZK0H.js"), __vite__mapDeps([0, 1])),
    "./behaviours/Video.js": () => An( () => import("./Video-Ct9qKm9W.js"), []),
    "./behaviours/VideoPlayer.js": () => An( () => import("./VideoPlayer-CR6nB002.js").then(e => e.ao), __vite__mapDeps([2, 3]))
}), "./behaviours/".concat(i, ".js"), 3));
Gn({
    module: Ax,
    id: "scroll",
    node: document.body,
    keepAlive: !0
});
Gn({
    module: ax,
    id: "header",
    node: document.getElementById("header"),
    keepAlive: !0
});
Gn({
    module: fx,
    id: "set-vh",
    node: document.body,
    keepAlive: !0
});
Gn({
    module: lg,
    id: "footer",
    node: document.getElementById("footer")
});
Gn({
    module: hh,
    id: "scroll-text",
    node: document.body
});
Gn({
    module: dh,
    id: "scroll-color",
    node: document.body
});
Gn({
    module: hg,
    id: "card-hover",
    node: document.body
});
za.hydrate();
Ww();
n_(window.location.pathname);
wh(document.body);
pr.init({
    requestError: (i, e, t, n) => {
        if (console.log("barba requestError", i, e, t, n),
        e === "click" && n.status && (n.status === 404 || n.status === 500))
            return pr.force("/".concat(n.status))
    }
    ,
    cacheFirstPage: !0,
    cacheIgnore: !1,
    debug: !0,
    prefetchIgnore: !1,
    prevent: ({el: i}) => i ? i.closest(".yii-debug-toolbar") ? !0 : i.classList && i.classList.contains("no-barba") : !1,
    preventRunning: !0,
    timeout: 5e3,
    transitions: [{
        name: "default-transition",
        sync: !1,
        async leave(i) {
            const {trigger: e, next: {url: {path: t}}} = i;
            await new Promise(n => {
                Dt.to(gu, {
                    duration: .5,
                    y: "-25%",
                    ease: "power2.out",
                    onComplete: () => {
                        window.lenis.scrollTo("top", {
                            duration: .1,
                            force: !0,
                            lock: !0,
                            onComplete: () => {
                                n()
                            }
                        })
                    }
                })
            }
            )
        },
        enter(i) {
            const {trigger: e, current: {url: {path: t}}, next: {url: {path: n}}} = i
              , r = Ff["".concat(n)] || 0;
            console.log("enter", n);
            const s = () => Dt.to(gu, {
                duration: .5,
                delay: .1,
                y: "-150%",
                ease: "power2.in"
            }).then( () => {
                Dt.set(gu, {
                    y: "50%"
                })
            }
            );
            r !== 0 && e === "back" && t !== "/happenings" ? window.lenis.scrollTo(r, {
                immediate: !0,
                force: !0,
                lock: !0,
                onComplete: () => {
                    s()
                }
            }) : s()
        }
    }]
});
pr.hooks.leave(i => {
    var t;
    const {url: {path: e}} = i.current;
    Ff["".concat(e)] = (t = window.lenis.scroll) != null ? t : 0,
    console.log("scrollPositions", Ff)
}
);
pr.hooks.afterLeave(i => {
    window.lenis.scrollTo(0, {
        duration: .1,
        force: !0,
        lock: !0
    }),
    za.destroy(),
    Xr && Xr.destroy(),
    It.emit("barba:afterLeave", i)
}
);
pr.hooks.beforeEnter(i => {
    const {container: e} = i.next;
    za.hydrate(e)
}
);
pr.hooks.enter(i => {
    const {url: {path: e}, container: t} = i.next;
    document.getElementById("header").classList.remove("not-at-top");
    const r = e || window.location.origin;
    n_(r),
    wh(t),
    document.body.dataset.bodyNamespace = i.next.container.dataset.barbaNamespace,
    It.emit("barba:enter", i)
}
);
pr.hooks.after(i => {
    Xr && Xr.init({
        node: document.body
    }),
    Gn({
        module: hh,
        id: "scroll-text",
        node: document.body
    }),
    Gn({
        module: dh,
        id: "scroll-color",
        node: document.body
    }),
    Gn({
        module: hg,
        id: "card-hover",
        node: document.body
    }),
    Gn({
        module: lg,
        id: "footer",
        node: document.getElementById("footer")
    }),
    je.refresh()
}
);
htmx.on("htmx:afterSwap", ({target: i, detail: {path: e}}) => {
    wh(i)
}
);
htmx.on("htmx:afterSettle", ({target: i}) => {
    vu("scroll-color"),
    vu("scroll-text"),
    za.hydrate(i),
    Gn({
        module: dh,
        id: "scroll-color",
        node: document.body
    }),
    Gn({
        module: hh,
        id: "scroll-text",
        node: document.body
    }),
    document.activeElement && document.activeElement === i && document.activeElement.blur(),
    [...i.querySelectorAll("[data-scene]")].forEach(e => {
        Xr && Xr.observe(e)
    }
    )
}
);
function $w(i, e) {
    let t = null;
    return function() {
        if (t)
            return;
        const n = this
          , r = arguments;
        t = setTimeout( () => {
            i.call(n, ...r),
            t = null
        }
        , e)
    }
}
const zl = 767;
let _u = innerWidth <= zl;
const jw = $w( () => {
    (_u && innerWidth > zl || !_u && innerWidth <= zl) && (_u = innerWidth <= zl,
    pr.go(location.pathname))
}
, 300);
window.addEventListener("resize", jw);
It.on("App:paginate", ({url: i, container: e}) => {
    vu("load-more"),
    za.hydrate(e),
    [...e.querySelectorAll("[data-scene]")].forEach(t => {
        Xr && Xr.observe(t)
    }
    ),
    pr.history.add(i, "barba", "push")
}
);
export {ln as L, Wn as M, Th as O, Do as P, Oi as R, It as S, Jl as T, Jy as V, Hb as W, Da as _, Zw as __vite_legacy_guard, je as a, If as b, zi as c, Dp as d, An as e, Dt as g, z_ as h, Lp as j};
//# sourceMappingURL=app-LpT9mD6r.js.map
